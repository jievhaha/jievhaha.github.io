<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>十三、解析bean标签子元素二</title>
    <link href="/2022/06/11/%E8%A7%A3%E6%9E%90%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE%E4%BA%8C/"/>
    <url>/2022/06/11/%E8%A7%A3%E6%9E%90%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">解析bean标签子元素二</font></div><h4 id="自定义标签的使用"><a href="#自定义标签的使用" class="headerlink" title="自定义标签的使用"></a>自定义标签的使用</h4><p>自定义标签的使用大致分为以下步骤：</p><ol><li>定义一个自定义标签组件，就是一个普通的<code>Java Bean</code>。</li><li>定义一个<code>xsd</code>文件，用来描述自定义标签的属性内容。</li><li>创建一个实现了 <code>org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser</code> 接口的<code>Parser</code>，用来解析<code>xsd</code>文件中的自定义标签内容。</li><li>创建一个继承了 <code>org.springframework.beans.factory.xml.NamespaceHandlerSupport</code> 抽象类的<code>NameSpaceHandler</code>，用于将自定义标签组件注册到 Spring 容器。</li><li>编写 <code>spring.handlers</code> 和 <code>spring.schemas</code> 文件，放在<code>resource/META-INF</code>目录下。</li></ol><p>文件结构图：</p><p><img src="/images/spring_IOC/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="自定义标签目录结构图"></p><h5 id="自定义标签组件"><a href="#自定义标签组件" class="headerlink" title="自定义标签组件"></a>自定义标签组件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br><span class="hljs-keyword">private</span> String id;<br><span class="hljs-keyword">private</span> Integer age;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> String address;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> id;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(String id)</span> &#123;<br><span class="hljs-built_in">this</span>.id = id;<br>&#125;<br><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> address;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAddress</span><span class="hljs-params">(String address)</span> &#123;<br><span class="hljs-built_in">this</span>.address = address;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Hello</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;今年&quot;</span> + <span class="hljs-built_in">this</span>.age + <span class="hljs-string">&quot;岁，&quot;</span> + <span class="hljs-string">&quot;住在&quot;</span> + <span class="hljs-built_in">this</span>.address);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="定义xsd文件"><a href="#定义xsd文件" class="headerlink" title="定义xsd文件"></a>定义<code>xsd</code>文件</h5><p>该文件用来对自定义标签组件进行描述，还定义了<code>xmlns=&quot;http://www.jievhaha.com/schema/hello&quot; </code>和<code>targetNamespace=&quot;http://www.jievhaha.com/schema/hello&quot;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">xsd:schema</span> <span class="hljs-attr">xmlns:xsd</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.jievhaha.com/schema/hello&quot;</span> <span class="hljs-attr">targetNamespace</span>=<span class="hljs-string">&quot;http://www.jievhaha.com/schema/hello&quot;</span> <span class="hljs-attr">elementFormDefault</span>=<span class="hljs-string">&quot;qualified&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">xsd:element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">xsd:complexType</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">xsd:attribute</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;xsd:string&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">xsd:attribute</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;xsd:string&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">xsd:attribute</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;xsd:string&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">xsd:attribute</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;xsd:string&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">xsd:complexType</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">xsd:element</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">xsd:schema</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="定义Parser类"><a href="#定义Parser类" class="headerlink" title="定义Parser类"></a>定义<code>Parser</code>类</h5><p>该类继承了<code>AbstractSingleBeanDefinitionParser</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloDefinitionParser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSingleBeanDefinitionParser</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;<br><span class="hljs-keyword">return</span> Hello.class;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doParse</span><span class="hljs-params">(Element element, BeanDefinitionBuilder builder)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> element.getAttribute(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> element.getAttribute(<span class="hljs-string">&quot;age&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> element.getAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> element.getAttribute(<span class="hljs-string">&quot;address&quot;</span>);<br><span class="hljs-keyword">if</span>(StringUtils.hasLength(<span class="hljs-string">&quot;id&quot;</span>))&#123;<br>builder.addPropertyValue(<span class="hljs-string">&quot;id&quot;</span>, id);<br>&#125;<br><span class="hljs-keyword">if</span>(StringUtils.hasLength(age))&#123;<br>builder.addPropertyValue(<span class="hljs-string">&quot;age&quot;</span>, age);<br>&#125;<br><span class="hljs-keyword">if</span>(StringUtils.hasText(name))&#123;<br>builder.addPropertyValue(<span class="hljs-string">&quot;name&quot;</span>, name);<br>&#125;<br><span class="hljs-keyword">if</span>(StringUtils.hasLength(address))&#123;<br>builder.addPropertyValue(<span class="hljs-string">&quot;address&quot;</span>, address);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="定义NameSpaceHandler类"><a href="#定义NameSpaceHandler类" class="headerlink" title="定义NameSpaceHandler类"></a>定义<code>NameSpaceHandler</code>类</h5><p>该类继承了<code>NamespaceHandlerSupport</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloNameSpaceHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NamespaceHandlerSupport</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>registerBeanDefinitionParser(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloDefinitionParser</span>());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="定义spring-handlers和spring-schemas文件"><a href="#定义spring-handlers和spring-schemas文件" class="headerlink" title="定义spring.handlers和spring.schemas文件"></a>定义<code>spring.handlers</code>和<code>spring.schemas</code>文件</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">#spring.handlers<br>http\://www.jievhaha.com/schema/hello=com.jievhaha.HelloNameSpaceHandler<br><br>#spring.schemas<br>http\://www.jievhaha.com/schema/hello.xsd=hello.xsd<br></code></pre></td></tr></table></figure><h5 id="配置spring配置文件并测试"><a href="#配置spring配置文件并测试" class="headerlink" title="配置spring配置文件并测试"></a>配置spring配置文件并测试</h5><p>spring.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:mytag</span>=<span class="hljs-string">&quot;http://www.jievhaha.com/schema/hello&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.jievhaha.com/schema/hello http://www.jievhaha.com/schema/hello.xsd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mytag:hello</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jievhaha&quot;</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&quot;27&quot;</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;山西&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>MyApplication.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;hello.xml&quot;</span>);<br><span class="hljs-type">Hello</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> (Hello) applicationContext.getBean(<span class="hljs-string">&quot;hello&quot;</span>);<br>hello.sayHello();<span class="hljs-comment">//jievhaha今年27岁，住在山西</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/spring_IOC/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="自定义标签运行结果"></p><h4 id="解析自定义标签"><a href="#解析自定义标签" class="headerlink" title="解析自定义标签"></a>解析自定义标签</h4><h5 id="parseCustomElement-方法"><a href="#parseCustomElement-方法" class="headerlink" title="parseCustomElement()方法"></a><code>parseCustomElement()</code>方法</h5><p>applicationContext.xml文件开始读取的入口方法：<code>DefaultBeanDefinitionDocumentReader.parseBeanDefinitions()</code>方法，该方法负责标签的解析工作，根据命名空间的不同进行不同标签的解析。其中，<strong>自定义标签</strong>由<code>BeanDefinitionParserDelegate</code>的 <code>parseCustomElement(Element ele, BeanDefinition containingBd)</code> 方法来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title function_">parseCustomElement</span><span class="hljs-params">(Element ele)</span> &#123;<br>    <span class="hljs-keyword">return</span> parseCustomElement(ele, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title function_">parseCustomElement</span><span class="hljs-params">(Element ele, <span class="hljs-meta">@Nullable</span> BeanDefinition containingBd)</span> &#123;<br>    <span class="hljs-comment">// &lt;1&gt; 获取 namespaceUri</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">namespaceUri</span> <span class="hljs-operator">=</span> getNamespaceURI(ele);<br>    <span class="hljs-keyword">if</span> (namespaceUri == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// &lt;2&gt; 根据 namespaceUri 获取相应的 Handler</span><br>    <span class="hljs-type">NamespaceHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);<br>    <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>        error(<span class="hljs-string">&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot;</span> + namespaceUri + <span class="hljs-string">&quot;]&quot;</span>, ele);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 调用自定义的 Handler 处理</span><br>    <span class="hljs-keyword">return</span> handler.parse(ele, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParserContext</span>(<span class="hljs-built_in">this</span>.readerContext, <span class="hljs-built_in">this</span>, containingBd));<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="getNamespaceURI-方法"><a href="#getNamespaceURI-方法" class="headerlink" title="getNamespaceURI()方法"></a><code>getNamespaceURI()</code>方法</h6><p>先获取了NamespaceURI：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNamespaceURI</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-keyword">return</span> node.getNamespaceURI();<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="getNamespaceHandlerResolver-方法"><a href="#getNamespaceHandlerResolver-方法" class="headerlink" title="getNamespaceHandlerResolver()方法"></a><code>getNamespaceHandlerResolver()</code>方法</h6><p>调用 <code>XmlReaderContext.getNamespaceHandlerResolver()</code> 方法，获得命名空间的解析器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> NamespaceHandlerResolver namespaceHandlerResolver;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> NamespaceHandlerResolver <span class="hljs-title function_">getNamespaceHandlerResolver</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.namespaceHandlerResolver;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NamespaceHandlerResolver</code>的初始化：</p><p>在《注册BeanDefinitions》中提到注册BeanDefinitions时：</p><ul><li>首先，是通过<code>XmlBeanDefinitionReader</code>的<code>createBeanDefinitionDocumentReader()</code>方法，获取 Document解析器<code>BeanDefinitionDocumentReader</code>实例。</li><li>然后，调用<code>BeanDefinitionDocumentReader</code>实例的<code>registerBeanDefinitions(Document doc, XmlReaderContext readerContext)</code>方法，进行注册。而该方法需要提供两个参数，一个是<code>Document</code>实例 <code>doc</code>，一个是<code>XmlReaderContext</code>实例 <code>readerContext</code> 。</li></ul><p><code>readerContext</code> 实例对象由<code>XmlBeanDefinitionReader</code>的<code>createReaderContext(Resource resource)</code>方法创建。<code>namespaceHandlerResolver</code> 实例对象就是在这个时候初始化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// XmlBeanDefinitionReader.java</span><br><span class="hljs-comment">//该方法最后一个参数为`NamespaceHandlerResolver`对象，通过`getNamespaceHandlerResolver()`方法获取</span><br><span class="hljs-keyword">public</span> XmlReaderContext <span class="hljs-title function_">createReaderContext</span><span class="hljs-params">(Resource resource)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlReaderContext</span>(resource, <span class="hljs-built_in">this</span>.problemReporter, <span class="hljs-built_in">this</span>.eventListener,<br><span class="hljs-built_in">this</span>.sourceExtractor, <span class="hljs-built_in">this</span>, getNamespaceHandlerResolver());<br>&#125;<br><br><span class="hljs-comment">//获取`NamespaceHandlerResolver`对象</span><br><span class="hljs-keyword">public</span> NamespaceHandlerResolver <span class="hljs-title function_">getNamespaceHandlerResolver</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.namespaceHandlerResolver == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.namespaceHandlerResolver;<br>&#125;<br><br><span class="hljs-comment">//可以看出`NamespaceHandlerResolver`对象类型默认为DefaultNamespaceHandlerResolver</span><br><span class="hljs-keyword">protected</span> NamespaceHandlerResolver <span class="hljs-title function_">createDefaultNamespaceHandlerResolver</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> (getResourceLoader() != <span class="hljs-literal">null</span> ? getResourceLoader().getClassLoader() : getBeanClassLoader());<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultNamespaceHandlerResolver</span>(cl);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="resolve-方法"><a href="#resolve-方法" class="headerlink" title="resolve()方法"></a><code>resolve()</code>方法</h5><p>由上可以看出<code>this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri)</code>最终调用的就是<code>DefaultNamespaceHandlerResolver</code>类的<code>resolve()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> NamespaceHandler <span class="hljs-title function_">resolve</span><span class="hljs-params">(String namespaceUri)</span> &#123;<br>    <span class="hljs-comment">// &lt;1&gt; 获取所有已经配置的 Handler 映射</span><br>    Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();<br>    <span class="hljs-comment">// &lt;2&gt; 根据 namespaceUri 获取 handler 的信息</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">handlerOrClassName</span> <span class="hljs-operator">=</span> handlerMappings.get(namespaceUri);<br>    <span class="hljs-keyword">if</span> (handlerOrClassName == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//不存在返回null</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//已经初始化过了直接强制类型转换</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (handlerOrClassName <span class="hljs-keyword">instanceof</span> NamespaceHandler) &#123;<br>        <span class="hljs-keyword">return</span> (NamespaceHandler) handlerOrClassName;<br>    &#125;<br>    <span class="hljs-comment">//未初始化</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> (String) handlerOrClassName;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// &lt;2&gt; 根据 namespaceUri 获取 handler 的信息</span><br>            Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="hljs-built_in">this</span>.classLoader);<br>            <span class="hljs-keyword">if</span> (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FatalBeanException</span>(<span class="hljs-string">&quot;Class [&quot;</span> + className + <span class="hljs-string">&quot;] for namespace [&quot;</span> + namespaceUri +<br>                                             <span class="hljs-string">&quot;] does not implement the [&quot;</span> + NamespaceHandler.class.getName() + <span class="hljs-string">&quot;] interface&quot;</span>);<br>            &#125;<br>            <span class="hljs-type">NamespaceHandler</span> <span class="hljs-variable">namespaceHandler</span> <span class="hljs-operator">=</span> (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);<br>            <span class="hljs-comment">// 初始化 NamespaceHandler 对象</span><br>            namespaceHandler.init();<br>            <span class="hljs-comment">// 添加到缓存</span><br>            handlerMappings.put(namespaceUri, namespaceHandler);<br>            <span class="hljs-keyword">return</span> namespaceHandler;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FatalBeanException</span>(<span class="hljs-string">&quot;Could not find NamespaceHandler class [&quot;</span> + className +<br>                                         <span class="hljs-string">&quot;] for namespace [&quot;</span> + namespaceUri + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (LinkageError err) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FatalBeanException</span>(<span class="hljs-string">&quot;Unresolvable class definition for NamespaceHandler class [&quot;</span> +<br>                                         className + <span class="hljs-string">&quot;] for namespace [&quot;</span> + namespaceUri + <span class="hljs-string">&quot;]&quot;</span>, err);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取所有已经配置的 Handler 映射，通过<code>getHandlerMappings()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Resource location to search for.</span><br><span class="hljs-comment">* NamespaceHandler 映射配置文件地址</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String handlerMappingsLocation;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Stores the mappings from namespace URI to NamespaceHandler class name / instance.</span><br><span class="hljs-comment">* NamespaceHandler 映射。</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* key：命名空间</span><br><span class="hljs-comment">* value：分成两种情况：</span><br><span class="hljs-comment">* 1）未初始化时，对应的 NamespaceHandler 的类路径；</span><br><span class="hljs-comment">* 2）已初始化，对应的 NamespaceHandler 对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, Object&gt; handlerMappings;<br><br><span class="hljs-keyword">private</span> Map&lt;String, Object&gt; <span class="hljs-title function_">getHandlerMappings</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//使用了延迟加载，双重检查锁</span><br>    Map&lt;String, Object&gt; handlerMappings = <span class="hljs-built_in">this</span>.handlerMappings;<br>    <span class="hljs-keyword">if</span> (handlerMappings == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            handlerMappings = <span class="hljs-built_in">this</span>.handlerMappings;<br>            <span class="hljs-keyword">if</span> (handlerMappings == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                    logger.trace(<span class="hljs-string">&quot;Loading NamespaceHandler mappings from [&quot;</span> + <span class="hljs-built_in">this</span>.handlerMappingsLocation + <span class="hljs-string">&quot;]&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 读取 handlerMappingsLocation</span><br>                    <span class="hljs-type">Properties</span> <span class="hljs-variable">mappings</span> <span class="hljs-operator">=</span><br>                        PropertiesLoaderUtils.loadAllProperties(<span class="hljs-built_in">this</span>.handlerMappingsLocation, <span class="hljs-built_in">this</span>.classLoader);<br>                    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                        logger.trace(<span class="hljs-string">&quot;Loaded NamespaceHandler mappings: &quot;</span> + mappings);<br>                    &#125;<br>                    <span class="hljs-comment">// 初始化到 handlerMappings 中</span><br>                    handlerMappings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(mappings.size());<br>                    CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);<br>                    <span class="hljs-built_in">this</span>.handlerMappings = handlerMappings;<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                        <span class="hljs-string">&quot;Unable to load NamespaceHandler mappings from location [&quot;</span> + <span class="hljs-built_in">this</span>.handlerMappingsLocation + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> handlerMappings;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行完<code>getHandlerMappings()</code>获取了<code>Handler</code>映射后，之后还会执行<code>NamespaceHandler.init()</code>方法，该方法主要是将自定义标签解析器进行注册，调用的就是我们上边实例中的<code>HelloNameSpaceHandler.init()</code>方法，内部其实还是调用了父类<code>NamespaceHandlerSupport</code>的<code>registerBeanDefinitionParser()</code>来注册指定元素的<code>BeanDefinitionParser</code>解析器，其实就是将映射关系放在一个 Map 结构的 parsers 对象中。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloNameSpaceHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NamespaceHandlerSupport</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>registerBeanDefinitionParser(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloDefinitionParser</span>());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NamespaceHandlerSupport</code>的<code>registerBeanDefinitionParser()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BeanDefinitionDecorator&gt; decorators = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* key：元素名，不是命名空间名称</span><br><span class="hljs-comment">* value：对应 BeanDefinitionParser 的解析器</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitionDecorator</span><span class="hljs-params">(String elementName, BeanDefinitionDecorator dec)</span> &#123;<br>    <span class="hljs-built_in">this</span>.decorators.put(elementName, dec);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="parse-方法"><a href="#parse-方法" class="headerlink" title="parse()方法"></a><code>parse()</code>方法</h5><p>执行完<code>this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</code>获取了相应的<code>Handler</code>后，然后调用<code>parse()</code>方法执行自定义标签的解析。返回的<code>NamespaceHandlerHandler</code>是我们自己定义的<code>HelloNameSpaceHandler</code>，我们定义的继承了<code>NamespaceHandlerSupport</code>，故其实调用的是<code>NamespaceHandlerSupport.parse()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title function_">parse</span><span class="hljs-params">(Element element, ParserContext parserContext)</span> &#123;<br>    <span class="hljs-type">BeanDefinitionParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> findParserForElement(element, parserContext);<br>    <span class="hljs-keyword">return</span> (parser != <span class="hljs-literal">null</span> ? parser.parse(element, parserContext) : <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>调用 <code>findParserForElement(Element element, ParserContext parserContext)</code>方法，获取对应的 <code>BeanDefinitionParser</code>实例。实际上，其实就是获取在<code>NamespaceHandlerSupport</code>的 <code>registerBeanDefinitionParser()</code> 方法里面注册的实例对象，注册是在我们执行<code>init()</code>的时候。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//NamespaceHandlerSupport.java</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> BeanDefinitionParser <span class="hljs-title function_">findParserForElement</span><span class="hljs-params">(Element element, ParserContext parserContext)</span> &#123;<br>    <span class="hljs-comment">// 获得元素名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">localName</span> <span class="hljs-operator">=</span> parserContext.getDelegate().getLocalName(element);<br>    <span class="hljs-comment">// 获得 BeanDefinitionParser 对象</span><br>    <span class="hljs-type">BeanDefinitionParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.parsers.get(localName);<br>    <span class="hljs-keyword">if</span> (parser == <span class="hljs-literal">null</span>) &#123;<br>        parserContext.getReaderContext().fatal(<br>            <span class="hljs-string">&quot;Cannot locate BeanDefinitionParser for element [&quot;</span> + localName + <span class="hljs-string">&quot;]&quot;</span>, element);<br>    &#125;<br>    <span class="hljs-keyword">return</span> parser;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>最后执行<code>parse()</code>，得到的<code>BeanDefinitionParser</code>其实就是我们自己定义的<code>HelloDefinitionParser</code>继承了<code>AbstractSingleBeanDefinitionParser</code>，而<code>AbstractSingleBeanDefinitionParser</code>又继承了<code>AbstractBeanDefinitionParser</code>，所以最终执行的是该类的<code>parse()</code>方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//`AbstractBeanDefinitionParser.java`</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> BeanDefinition <span class="hljs-title function_">parse</span><span class="hljs-params">(Element element, ParserContext parserContext)</span> &#123;<br>    <span class="hljs-comment">// &lt;1&gt; 内部解析，返回 AbstractBeanDefinition 对象</span><br>    <span class="hljs-type">AbstractBeanDefinition</span> <span class="hljs-variable">definition</span> <span class="hljs-operator">=</span> parseInternal(element, parserContext);<br>    <span class="hljs-keyword">if</span> (definition != <span class="hljs-literal">null</span> &amp;&amp; !parserContext.isNested()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 解析 id 属性</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> resolveId(element, definition, parserContext);<br>            <span class="hljs-keyword">if</span> (!StringUtils.hasText(id)) &#123;<br>                parserContext.getReaderContext().error(<br>                    <span class="hljs-string">&quot;Id is required for element &#x27;&quot;</span> + parserContext.getDelegate().getLocalName(element)<br>                    + <span class="hljs-string">&quot;&#x27; when used as a top-level tag&quot;</span>, element);<br>            &#125;<br>            <span class="hljs-comment">// 解析 aliases 属性</span><br>            String[] aliases = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span> (shouldParseNameAsAliases()) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> element.getAttribute(NAME_ATTRIBUTE);<br>                <span class="hljs-keyword">if</span> (StringUtils.hasLength(name)) &#123;<br>                    aliases = StringUtils.trimArrayElements(StringUtils.commaDelimitedListToStringArray(name));<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 创建 BeanDefinitionHolder 对象</span><br>            <span class="hljs-type">BeanDefinitionHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionHolder</span>(definition, id, aliases);<br>            <span class="hljs-comment">// 注册 BeanDefinition</span><br>            registerBeanDefinition(holder, parserContext.getRegistry());<br>            <span class="hljs-comment">// 触发事件</span><br>            <span class="hljs-keyword">if</span> (shouldFireEvents()) &#123;<br>                <span class="hljs-type">BeanComponentDefinition</span> <span class="hljs-variable">componentDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComponentDefinition</span>(holder);<br>                postProcessComponentDefinition(componentDefinition);<br>                parserContext.registerComponent(componentDefinition);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> ex.getMessage();<br>            parserContext.getReaderContext().error((msg != <span class="hljs-literal">null</span> ? msg : ex.toString()), element);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> definition;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心在 <code>parseInternal(Element element, ParserContext parserContext)</code>方法。为什么这么说？因为该方法返回的是<code>AbstractBeanDefinition</code>对象。从前面默认标签的解析过程来看，我们就可以判断该方法就是将标签解析为<code>AbstractBeanDefinition</code>，且后续代码都是将 <code>AbstractBeanDefinition</code>转换为 <code>BeanDefinitionHolder</code>对象。所以真正的解析工作都交由<code>parseInternal(Element element, ParserContext parserContext)</code>方法来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractSingleBeanDefinitionParser.java</span><br><span class="hljs-comment">//解析元素为AbstractBeanDefinition对象</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> AbstractBeanDefinition <span class="hljs-title function_">parseInternal</span><span class="hljs-params">(Element element, ParserContext parserContext)</span> &#123;<br>    <span class="hljs-comment">// 创建 BeanDefinitionBuilder 对象</span><br>    <span class="hljs-type">BeanDefinitionBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> BeanDefinitionBuilder.genericBeanDefinition();<br>    <span class="hljs-comment">// 获取父类元素</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">parentName</span> <span class="hljs-operator">=</span> getParentName(element);<br>    <span class="hljs-keyword">if</span> (parentName != <span class="hljs-literal">null</span>) &#123;<br>        builder.getRawBeanDefinition().setParentName(parentName);<br>    &#125;<br>    <span class="hljs-comment">// 获取自定义标签中的 class，这个时候会去调用自定义解析中的 getBeanClass()</span><br>    Class&lt;?&gt; beanClass = getBeanClass(element);<br>    <span class="hljs-keyword">if</span> (beanClass != <span class="hljs-literal">null</span>) &#123;<br>        builder.getRawBeanDefinition().setBeanClass(beanClass);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// beanClass 为 null，意味着子类并没有重写 getBeanClass() 方法，则尝试去判断是否重写了 getBeanClassName()</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">beanClassName</span> <span class="hljs-operator">=</span> getBeanClassName(element);<br>        <span class="hljs-keyword">if</span> (beanClassName != <span class="hljs-literal">null</span>) &#123;<br>            builder.getRawBeanDefinition().setBeanClassName(beanClassName);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 设置 source 属性</span><br>    builder.getRawBeanDefinition().setSource(parserContext.extractSource(element));<br>    <span class="hljs-comment">// 设置 scope 属性</span><br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">containingBd</span> <span class="hljs-operator">=</span> parserContext.getContainingBeanDefinition();<br>    <span class="hljs-keyword">if</span> (containingBd != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Inner bean definition must receive same scope as containing bean.</span><br>        builder.setScope(containingBd.getScope());<br>    &#125;<br>    <span class="hljs-comment">// 设置 lazy-init 属性</span><br>    <span class="hljs-keyword">if</span> (parserContext.isDefaultLazyInit()) &#123;<br>        <span class="hljs-comment">// Default-lazy-init applies to custom bean definitions as well.</span><br>        builder.setLazyInit(<span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-comment">// 调用子类的 doParse() 进行解析</span><br>    doParse(element, parserContext, builder);<br>    <span class="hljs-keyword">return</span> builder.getBeanDefinition();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>自定义标签解析的大致流程：</p><ul><li>首先，会加载 <code>spring.handlers</code> 文件，将其中内容进行一个解析，形成 <code>&lt;namespaceUri, 类路径&gt;</code> 这样的一个映射。</li><li>然后，根据获取的 <code>namespaceUri</code> 就可以得到相应的类路径，对其进行初始化等到相应的 NamespaceHandler 对象。</li><li>之后，调用该 NamespaceHandler 的 <code>parse(...)</code> 方法，在该方法中根据标签的 <code>localName</code> 得到相应的 BeanDefinitionParser 实例对象。</li><li>最后，调用该 BeanDefinitionParser 的 <code>parse(...)</code> 方法。该方法定义在 AbstractBeanDefinitionParser 抽象类中，核心逻辑封装在其 <code>parseInternal(...)</code> 方法中，该方法返回一个 AbstractBeanDefinition 实例对象，其主要是在 AbstractSingleBeanDefinitionParser 中实现。对于自定义的 Parser 类，其需要实现 <code>getBeanClass()</code> 或者 <code>getBeanClassName()</code> 任一方法，和 <code>doParse(...)</code> 方法。</li></ul><p>流程图：</p><p><img src="/images/spring_IOC/%E8%A7%A3%E6%9E%90%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="解析自定义标签流程图"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>词形变化</title>
    <link href="/2022/06/11/%E8%AF%8D%E5%BD%A2/"/>
    <url>/2022/06/11/%E8%AF%8D%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">词形变化</font></div><h4 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h4><p>动词的<strong>基本型</strong>词尾以<strong>「ウ」</strong>段结尾，又称原形、字典形。</p><h5 id="动词分类"><a href="#动词分类" class="headerlink" title="动词分类"></a>动词分类</h5><table><thead><tr><th>一类动词</th><th>二类动词</th><th>三类动词</th></tr></thead><tbody><tr><td>动1</td><td>动2</td><td>动3</td></tr><tr><td>五段动词</td><td>一段动词</td><td>サ变动词、か变动词</td></tr></tbody></table><h6 id="三类动词"><a href="#三类动词" class="headerlink" title="三类动词"></a>三类动词</h6><p>サ变动词：只有一个<strong>「来る」</strong>，假名くる。</p><p>か变动词：<strong>「する」</strong>和<strong>以「する」结尾的具有动作性的名词</strong>。</p><h6 id="二类动词"><a href="#二类动词" class="headerlink" title="二类动词"></a>二类动词</h6><p>以「る」结尾，「る」前的假名在<strong>「い」段</strong>和<strong>「え」段</strong>。</p><p>上一段动词：「る」前的假名在<strong>「い」段</strong>。例：起「お」きる、見「み」る</p><p>下一段动词：「る」前的假名在<strong>「え」段</strong>。例：食「た」べる、寝「ね」る</p><h6 id="一类动词"><a href="#一类动词" class="headerlink" title="一类动词"></a>一类动词</h6><p>以<strong>「ウ」</strong>结尾：う・く・ぐ・す・つ・ぬ・ぶ・む・る。</p><p>以「る」结尾的有二类动词和一类动词，区分方法：</p><ol><li>词尾不为「る」，一定是一类动词。</li><li>词尾为「る」时，（除三类动词外）看「る」前假名在哪段：<ul><li>不在「い・え」段为一类动词。</li><li>在「い・え」段，大部分为二类动词，二三十个特例是一类动词。</li></ul></li></ol><p>以「る」结尾的一类动词：</p><table><thead><tr><th>切「き」る</th><th>入「はい」る</th><th>いる</th><th>知「し」る</th><th>滑「すべ」る</th></tr></thead><tbody><tr><td>帰「かえ」る</td><td></td><td></td><td></td><td></td></tr></tbody></table><h5 id="动词变形"><a href="#动词变形" class="headerlink" title="动词变形"></a>动词变形</h5><p>基本型变<strong>「ます」</strong>形。</p><h6 id="三类动词-1"><a href="#三类动词-1" class="headerlink" title="三类动词"></a>三类动词</h6><p>サ变动词：<strong>「来(く)る」</strong>——&gt;<strong>「来(き)ます」</strong>。</p><p>か变动词：<strong>「する」</strong>——&gt;<strong>「します」</strong>。</p><h6 id="二类动词-1"><a href="#二类动词-1" class="headerlink" title="二类动词"></a>二类动词</h6><p>去掉<strong>「る」</strong>加<strong>「ます」</strong>，例：起「お」きる——&gt;起きます。</p><h6 id="一类动词-1"><a href="#一类动词-1" class="headerlink" title="一类动词"></a>一类动词</h6><p>词尾<strong>「ウ」</strong>段变为<strong>同行的「い」段加「ます」</strong>，例：終「お」わる——&gt;終わります。</p><h6 id="「ます」作用"><a href="#「ます」作用" class="headerlink" title="「ます」作用"></a>「ます」作用</h6><ol><li>表尊敬的助动词。</li><li>与<strong>「です」</strong>构成句子的礼貌体。</li><li>在句中做谓语，只能用在结句。</li></ol><h5 id="动词时态"><a href="#动词时态" class="headerlink" title="动词时态"></a>动词时态</h5><p>动词时态分为非过去式（现在・将来）和过去式。</p><p>动词<strong>「ます」</strong>形去掉<strong>「ます」</strong>剩下的部分就是<strong>动词连用形</strong>。</p><table><thead><tr><th></th><th>肯定</th><th>否定</th></tr></thead><tbody><tr><td>非过去式</td><td>动词<strong>「ます」</strong>形</td><td>动词连用形 +<strong>「ません」</strong></td></tr><tr><td>过去式</td><td>动词连用形 +<strong>「ました」</strong></td><td>动词连用形 +<strong>「ませんでした」</strong></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>新标日</category>
      
      <category>上册</category>
      
      <category>单词</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁种类以及具体实现</title>
    <link href="/2022/06/11/%E9%94%81%E7%A7%8D%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/06/11/%E9%94%81%E7%A7%8D%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">锁种类以及具体实现</font></div><h3 id="乐观锁-VS-悲观锁"><a href="#乐观锁-VS-悲观锁" class="headerlink" title="乐观锁 VS 悲观锁"></a>乐观锁 VS 悲观锁</h3><p><strong>乐观锁</strong>：在Java中是通过使用<strong>无锁</strong>编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p><p><strong>悲观锁</strong>：synchronized关键字和Lock的实现类。</p><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><h3 id="自旋锁-VS-适应性自旋锁"><a href="#自旋锁-VS-适应性自旋锁" class="headerlink" title="自旋锁 VS 适应性自旋锁"></a>自旋锁 VS 适应性自旋锁</h3><p><strong>自旋锁</strong>：实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><p><strong>适应性自旋锁</strong>：自适应意味着自旋的时间（次数）不再固定</p><h3 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h3><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p><p>偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p><h3 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h3><h3 id="可重入锁-VS-非可重入锁"><a href="#可重入锁-VS-非可重入锁" class="headerlink" title="可重入锁 VS 非可重入锁"></a>可重入锁 VS 非可重入锁</h3><p>ReentrantLock内部实现了公平锁和非公平锁（同时也是可重入锁）。</p><p>synchronized也是可重入锁。</p><p>非可重入锁：NonReentrantLock。（加锁的时候直接尝试获取，要么成功要么直接失败；释放锁，直接将<code>status</code>置为0。</p><h3 id="独享锁-VS-共享锁"><a href="#独享锁-VS-共享锁" class="headerlink" title="独享锁 VS 共享锁"></a>独享锁 VS 共享锁</h3><p>独享锁也叫<strong>排他锁</strong>，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。（synchronized和ReentrantLock）</p><p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。（ReentrantReadWriteLock的读锁）</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>JUC</category>
      
      <category>基础原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十一、解析bean标签子元素二</title>
    <link href="/2022/06/11/%E8%A7%A3%E6%9E%90bean%E6%A0%87%E7%AD%BE%E5%AD%90%E5%85%83%E7%B4%A0%E4%BA%8C/"/>
    <url>/2022/06/11/%E8%A7%A3%E6%9E%90bean%E6%A0%87%E7%AD%BE%E5%AD%90%E5%85%83%E7%B4%A0%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">解析bean标签子元素二</font></div><p>其他三个子元素：<code>constructor-arg</code>、<code>property</code>、<code>qualifier</code>。</p><h4 id="constructor-arg子元素"><a href="#constructor-arg子元素" class="headerlink" title="constructor-arg子元素"></a><code>constructor-arg</code>子元素</h4><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br><span class="hljs-keyword">private</span> Integer age;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> String address;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Hello</span><span class="hljs-params">(Integer age, String name, String address)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.address = address;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;今年&quot;</span> + <span class="hljs-built_in">this</span>.age + <span class="hljs-string">&quot;岁，&quot;</span> + <span class="hljs-string">&quot;住在&quot;</span> + <span class="hljs-built_in">this</span>.address);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//spring配置文件</span><br>&lt;bean id=<span class="hljs-string">&quot;hello&quot;</span> class=<span class="hljs-string">&quot;com.jievhaha.Hello&quot;</span>&gt;<br>    &lt;constructor-arg type=<span class="hljs-string">&quot;java.lang.Integer&quot;</span> value=<span class="hljs-string">&quot;27&quot;</span>/&gt;<br>    &lt;constructor-arg name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;jievhaha&quot;</span>/&gt;<br>    &lt;constructor-arg index=<span class="hljs-string">&quot;2&quot;</span> value=<span class="hljs-string">&quot;山西&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h5 id="parseConstructorArgElements-方法"><a href="#parseConstructorArgElements-方法" class="headerlink" title="parseConstructorArgElements()方法"></a><code>parseConstructorArgElements()</code>方法</h5><p><code>BeanDefinitionParserDelegate.parseConstructorArgElements()</code>对<code>constructor-arg</code>子元素进行解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseConstructorArgElements</span><span class="hljs-params">(Element beanEle, BeanDefinition bd)</span> &#123;<br>    <span class="hljs-type">NodeList</span> <span class="hljs-variable">nl</span> <span class="hljs-operator">=</span> beanEle.getChildNodes();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nl.item(i);<br>        <span class="hljs-keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) &#123;<br>            parseConstructorArgElement((Element) node, bd);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历所有的子元素，如果为<code>constructor-arg</code>标签，则执行<code>parseConstructorArgElement()</code>方法，和之前其他三个子元素解析不同的是，当匹配了某个标签后，直接在if段执行逻辑，此处单独提取了一个<code>parseConstructorArgElement()</code>方法。</p><h5 id="parseConstructorArgElement-方法"><a href="#parseConstructorArgElement-方法" class="headerlink" title="parseConstructorArgElement()方法"></a><code>parseConstructorArgElement()</code>方法</h5><p>该方法是真正解析constructor-arg的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseConstructorArgElement</span><span class="hljs-params">(Element ele, BeanDefinition bd)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">indexAttr</span> <span class="hljs-operator">=</span> ele.getAttribute(INDEX_ATTRIBUTE);<span class="hljs-comment">//index属性</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">typeAttr</span> <span class="hljs-operator">=</span> ele.getAttribute(TYPE_ATTRIBUTE);<span class="hljs-comment">//type属性</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">nameAttr</span> <span class="hljs-operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);<span class="hljs-comment">//name属性</span><br>    <span class="hljs-comment">//是否设置了index属性</span><br>    <span class="hljs-comment">// index较type、name的区别：</span><br>    <span class="hljs-comment">// 1.构造ConstructorArgumentEntry对象时，index调用了有参构造函数</span><br>    <span class="hljs-comment">// 2.index最后保存到了indexedArgumentValues集合，另外两个保存到了genericArgumentValues集合中。</span><br>    <span class="hljs-keyword">if</span> (StringUtils.hasLength(indexAttr)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Integer.parseInt(indexAttr);<br>            <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) &#123;<br>                error(<span class="hljs-string">&quot;&#x27;index&#x27; cannot be lower than 0&quot;</span>, ele);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//多上送了index，构造 ConstructorArgumentEntry 对象并将其加入到 ParseState 队列中。</span><br>                    <span class="hljs-built_in">this</span>.parseState.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstructorArgumentEntry</span>(index));<br>                    <span class="hljs-comment">// &lt;2&gt; 解析 ele 对应的属性，返回结果值。</span><br>                    <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> parsePropertyValue(ele, bd, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// &lt;3&gt; 根据解析的属性元素构造一个 ValueHolder 对象</span><br>                    ConstructorArgumentValues.<span class="hljs-type">ValueHolder</span> <span class="hljs-variable">valueHolder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstructorArgumentValues</span>.ValueHolder(value);<br>                    <span class="hljs-comment">//将 type、name 设置到 ValueHolder 中</span><br>                    <span class="hljs-keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;<br>                        valueHolder.setType(typeAttr);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;<br>                        valueHolder.setName(nameAttr);<br>                    &#125;<br>                    valueHolder.setSource(extractSource(ele));<br>                    <span class="hljs-comment">// 不允许重复指定相同参数</span><br>                    <span class="hljs-keyword">if</span> (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) &#123;<br>                        error(<span class="hljs-string">&quot;Ambiguous constructor-arg entries for index &quot;</span> + index, ele);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// &lt;4&gt; 加入到 indexedArgumentValues 中</span><br>                        bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-built_in">this</span>.parseState.pop();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (NumberFormatException ex) &#123;<br>            error(<span class="hljs-string">&quot;Attribute &#x27;index&#x27; of tag &#x27;constructor-arg&#x27; must be an integer&quot;</span>, ele);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.parseState.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstructorArgumentEntry</span>());<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> parsePropertyValue(ele, bd, <span class="hljs-literal">null</span>);<br>            ConstructorArgumentValues.<span class="hljs-type">ValueHolder</span> <span class="hljs-variable">valueHolder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstructorArgumentValues</span>.ValueHolder(value);<br>            <span class="hljs-keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;<br>                valueHolder.setType(typeAttr);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;<br>                valueHolder.setName(nameAttr);<br>            &#125;<br>            valueHolder.setSource(extractSource(ele));<br>            <span class="hljs-comment">//加入到genericArgumentValues集合中</span><br>            bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-built_in">this</span>.parseState.pop();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="parsePropertyValue-方法"><a href="#parsePropertyValue-方法" class="headerlink" title="parsePropertyValue()方法"></a><code>parsePropertyValue()</code>方法</h5><p>解析constructor-arg的过程中，调用了<code>parsePropertyValue()</code>方法，返回结果值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">parsePropertyValue</span><span class="hljs-params">(Element ele, BeanDefinition bd, <span class="hljs-meta">@Nullable</span> String propertyName)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">elementName</span> <span class="hljs-operator">=</span> (propertyName != <span class="hljs-literal">null</span> ?<br>                          <span class="hljs-string">&quot;&lt;property&gt; element for property &#x27;&quot;</span> + propertyName + <span class="hljs-string">&quot;&#x27;&quot;</span> :<br>                          <span class="hljs-string">&quot;&lt;constructor-arg&gt; element&quot;</span>);<br><br>    <span class="hljs-comment">// Should only have one child element: ref, value, list, etc.</span><br>    <span class="hljs-comment">// &lt;1&gt; 查找子节点中，是否有 ref、value、list 等元素</span><br>    <span class="hljs-type">NodeList</span> <span class="hljs-variable">nl</span> <span class="hljs-operator">=</span> ele.getChildNodes();<br>    <span class="hljs-type">Element</span> <span class="hljs-variable">subElement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nl.item(i);<br>        <span class="hljs-comment">// meta 、description 不处理</span><br>        <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;<br>            !nodeNameEquals(node, META_ELEMENT)) &#123;<br>            <span class="hljs-comment">// Child element is what we&#x27;re looking for.</span><br>            <span class="hljs-keyword">if</span> (subElement != <span class="hljs-literal">null</span>) &#123;<br>                error(elementName + <span class="hljs-string">&quot; must not contain more than one sub-element&quot;</span>, ele);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                subElement = (Element) node;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;1&gt; 是否有 ref 属性</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">hasRefAttribute</span> <span class="hljs-operator">=</span> ele.hasAttribute(REF_ATTRIBUTE);<br>    <span class="hljs-comment">// &lt;1&gt; 是否有 value 属性</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">hasValueAttribute</span> <span class="hljs-operator">=</span> ele.hasAttribute(VALUE_ATTRIBUTE);<br>    <span class="hljs-comment">// &lt;1&gt; 多个元素存在，报错，存在冲突。</span><br>    <span class="hljs-keyword">if</span> ((hasRefAttribute &amp;&amp; hasValueAttribute) ||<span class="hljs-comment">// 1. ref 和 value 都存在</span><br>        ((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != <span class="hljs-literal">null</span>)) &#123;<span class="hljs-comment">// 2. ref 和 value 存在其一，并且 subElement 存在</span><br>        error(elementName +<br>              <span class="hljs-string">&quot; is only allowed to contain either &#x27;ref&#x27; attribute OR &#x27;value&#x27; attribute OR sub-element&quot;</span>, ele);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;2&gt; 将 ref 属性值，构造为 RuntimeBeanReference 实例对象</span><br>    <span class="hljs-keyword">if</span> (hasRefAttribute) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">refName</span> <span class="hljs-operator">=</span> ele.getAttribute(REF_ATTRIBUTE);<br>        <span class="hljs-keyword">if</span> (!StringUtils.hasText(refName)) &#123;<br>            error(elementName + <span class="hljs-string">&quot; contains empty &#x27;ref&#x27; attribute&quot;</span>, ele);<br>        &#125;<br>        <span class="hljs-type">RuntimeBeanReference</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeBeanReference</span>(refName);<br>        ref.setSource(extractSource(ele));<br>        <span class="hljs-keyword">return</span> ref;<br>    &#125;<br>    <span class="hljs-comment">// &lt;3&gt; 将 value 属性值，构造为 TypedStringValue 实例对象</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hasValueAttribute) &#123;<br>        <span class="hljs-type">TypedStringValue</span> <span class="hljs-variable">valueHolder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypedStringValue</span>(ele.getAttribute(VALUE_ATTRIBUTE));<br>        valueHolder.setSource(extractSource(ele));<br>        <span class="hljs-keyword">return</span> valueHolder;<br>    &#125;<br>    <span class="hljs-comment">// &lt;4&gt; 解析子元素</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (subElement != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> parsePropertySubElement(subElement, bd);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Neither child element nor &quot;ref&quot; or &quot;value&quot; attribute found.</span><br>        error(elementName + <span class="hljs-string">&quot; must specify a ref or value&quot;</span>, ele);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="parsePropertySubElement-方法"><a href="#parsePropertySubElement-方法" class="headerlink" title="parsePropertySubElement()方法"></a><code>parsePropertySubElement()</code>方法</h5><p>在调用<code>parsePropertyValue()</code>返回结果值的时候，假如解析了子元素，会调用<code>parsePropertySubElement()</code>方法，主要是针对各种子标签进行不同的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">parsePropertySubElement</span><span class="hljs-params">(Element ele, <span class="hljs-meta">@Nullable</span> BeanDefinition bd, <span class="hljs-meta">@Nullable</span> String defaultValueType)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isDefaultNamespace(ele)) &#123;<br>        <span class="hljs-keyword">return</span> parseNestedCustomElement(ele, bd);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeNameEquals(ele, BEAN_ELEMENT)) &#123;<span class="hljs-comment">// bean 标签</span><br>        <span class="hljs-type">BeanDefinitionHolder</span> <span class="hljs-variable">nestedBd</span> <span class="hljs-operator">=</span> parseBeanDefinitionElement(ele, bd);<br>        <span class="hljs-keyword">if</span> (nestedBd != <span class="hljs-literal">null</span>) &#123;<br>            nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nestedBd;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeNameEquals(ele, REF_ELEMENT)) &#123;<span class="hljs-comment">// ref 标签</span><br>        <span class="hljs-comment">// A generic reference to any name of any bean.</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">refName</span> <span class="hljs-operator">=</span> ele.getAttribute(BEAN_REF_ATTRIBUTE);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">toParent</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (!StringUtils.hasLength(refName)) &#123;<br>            <span class="hljs-comment">// A reference to the id of another bean in a parent context.</span><br>            refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);<br>            toParent = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (!StringUtils.hasLength(refName)) &#123;<br>                error(<span class="hljs-string">&quot;&#x27;bean&#x27; or &#x27;parent&#x27; is required for &lt;ref&gt; element&quot;</span>, ele);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!StringUtils.hasText(refName)) &#123;<br>            error(<span class="hljs-string">&quot;&lt;ref&gt; element contains empty target attribute&quot;</span>, ele);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">RuntimeBeanReference</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeBeanReference</span>(refName, toParent);<br>        ref.setSource(extractSource(ele));<br>        <span class="hljs-keyword">return</span> ref;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeNameEquals(ele, IDREF_ELEMENT)) &#123;<span class="hljs-comment">// idref 标签</span><br>        <span class="hljs-keyword">return</span> parseIdRefElement(ele);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeNameEquals(ele, VALUE_ELEMENT)) &#123;<span class="hljs-comment">// value 标签</span><br>        <span class="hljs-keyword">return</span> parseValueElement(ele, defaultValueType);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeNameEquals(ele, NULL_ELEMENT)) &#123;<span class="hljs-comment">// null 标签</span><br>        <span class="hljs-comment">// It&#x27;s a distinguished null value. Let&#x27;s wrap it in a TypedStringValue</span><br>        <span class="hljs-comment">// object in order to preserve the source location.</span><br>        <span class="hljs-type">TypedStringValue</span> <span class="hljs-variable">nullHolder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypedStringValue</span>(<span class="hljs-literal">null</span>);<br>        nullHolder.setSource(extractSource(ele));<br>        <span class="hljs-keyword">return</span> nullHolder;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123;<span class="hljs-comment">// array 标签</span><br>        <span class="hljs-keyword">return</span> parseArrayElement(ele, bd);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeNameEquals(ele, LIST_ELEMENT)) &#123;<span class="hljs-comment">// list 标签</span><br>        <span class="hljs-keyword">return</span> parseListElement(ele, bd);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeNameEquals(ele, SET_ELEMENT)) &#123;<span class="hljs-comment">// set 标签</span><br>        <span class="hljs-keyword">return</span> parseSetElement(ele, bd);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeNameEquals(ele, MAP_ELEMENT)) &#123;<span class="hljs-comment">// map 标签</span><br>        <span class="hljs-keyword">return</span> parseMapElement(ele, bd);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeNameEquals(ele, PROPS_ELEMENT)) &#123;<span class="hljs-comment">// props 标签</span><br>        <span class="hljs-keyword">return</span> parsePropsElement(ele);<span class="hljs-comment">// 未知标签</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        error(<span class="hljs-string">&quot;Unknown property sub-element: [&quot;</span> + ele.getNodeName() + <span class="hljs-string">&quot;]&quot;</span>, ele);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="property子元素"><a href="#property子元素" class="headerlink" title="property子元素"></a><code>property</code>子元素</h4><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//spring配置文件</span><br>&lt;bean id=<span class="hljs-string">&quot;hello&quot;</span> class=<span class="hljs-string">&quot;com.jievhaha.Hello&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;chenssy&quot;</span>/&gt;<br>    &lt;property name=<span class="hljs-string">&quot;age&quot;</span> value=<span class="hljs-string">&quot;18&quot;</span>/&gt;<br>    &lt;property name=<span class="hljs-string">&quot;address&quot;</span> value=<span class="hljs-string">&quot;山西&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h5 id="parsePropertyElement-方法"><a href="#parsePropertyElement-方法" class="headerlink" title="parsePropertyElement()方法"></a><code>parsePropertyElement()</code>方法</h5><p>和上边解析<code>constructor-arg</code>一样，遍历所有子元素，匹配到了<code>property</code>子元素，调用相应的逻辑方法<code>parsePropertyElement</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parsePropertyElement</span><span class="hljs-params">(Element ele, BeanDefinition bd)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">propertyName</span> <span class="hljs-operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);<span class="hljs-comment">// 获取 name 属性</span><br>    <span class="hljs-keyword">if</span> (!StringUtils.hasLength(propertyName)) &#123;<br>        error(<span class="hljs-string">&quot;Tag &#x27;property&#x27; must have a &#x27;name&#x27; attribute&quot;</span>, ele);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">this</span>.parseState.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyEntry</span>(propertyName));<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果存在相同的 name ，报错</span><br>        <span class="hljs-keyword">if</span> (bd.getPropertyValues().contains(propertyName)) &#123;<br>            error(<span class="hljs-string">&quot;Multiple &#x27;property&#x27; definitions for property &#x27;&quot;</span> + propertyName + <span class="hljs-string">&quot;&#x27;&quot;</span>, ele);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 解析属性值，解析constructor-arg子元素的时候，已经分析了该方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> parsePropertyValue(ele, bd, propertyName);<br>        <span class="hljs-comment">// 创建 PropertyValue 对象</span><br>        <span class="hljs-type">PropertyValue</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyValue</span>(propertyName, val);<br>        parseMetaElements(ele, pv);<br>        pv.setSource(extractSource(ele));<br>        <span class="hljs-comment">// 添加到 PropertyValue 集合中</span><br>        bd.getPropertyValues().addPropertyValue(pv);<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-built_in">this</span>.parseState.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="qualifier子元素"><a href="#qualifier子元素" class="headerlink" title="qualifier子元素"></a><code>qualifier</code>子元素</h4><h5 id="parseQualifierElements-方法"><a href="#parseQualifierElements-方法" class="headerlink" title="parseQualifierElements()方法"></a><code>parseQualifierElements()</code>方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseQualifierElements</span><span class="hljs-params">(Element beanEle, AbstractBeanDefinition bd)</span> &#123;<br>    <span class="hljs-type">NodeList</span> <span class="hljs-variable">nl</span> <span class="hljs-operator">=</span> beanEle.getChildNodes();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nl.item(i);<br>        <span class="hljs-keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, QUALIFIER_ELEMENT)) &#123;<br>            parseQualifierElement((Element) node, bd);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="parseQualifierElement-方法"><a href="#parseQualifierElement-方法" class="headerlink" title="parseQualifierElement()方法"></a><code>parseQualifierElement()</code>方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseQualifierElement</span><span class="hljs-params">(Element ele, AbstractBeanDefinition bd)</span> &#123;<br>   <span class="hljs-type">String</span> <span class="hljs-variable">typeName</span> <span class="hljs-operator">=</span> ele.getAttribute(TYPE_ATTRIBUTE);<span class="hljs-comment">// 解析 type 属性</span><br>   <span class="hljs-keyword">if</span> (!StringUtils.hasLength(typeName)) &#123;<span class="hljs-comment">// 必须有 type</span><br>      error(<span class="hljs-string">&quot;Tag &#x27;qualifier&#x27; must have a &#x27;type&#x27; attribute&quot;</span>, ele);<br>      <span class="hljs-keyword">return</span>;<br>   &#125;<br>   <span class="hljs-built_in">this</span>.parseState.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QualifierEntry</span>(typeName));<br>   <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 创建 AutowireCandidateQualifier 对象</span><br>      <span class="hljs-type">AutowireCandidateQualifier</span> <span class="hljs-variable">qualifier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutowireCandidateQualifier</span>(typeName);<br>      qualifier.setSource(extractSource(ele));<br>      <span class="hljs-comment">// 解析 value 属性，并设置到 AutowireCandidateQualifier 中</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> ele.getAttribute(VALUE_ATTRIBUTE);<br>      <span class="hljs-keyword">if</span> (StringUtils.hasLength(value)) &#123;<br>         qualifier.setAttribute(AutowireCandidateQualifier.VALUE_KEY, value);<br>      &#125;<br>      <span class="hljs-comment">// 遍历子节点</span><br>      <span class="hljs-type">NodeList</span> <span class="hljs-variable">nl</span> <span class="hljs-operator">=</span> ele.getChildNodes();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;<br>         <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nl.item(i);<br>         <span class="hljs-keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, QUALIFIER_ATTRIBUTE_ELEMENT)) &#123;<span class="hljs-comment">// attribute 标签</span><br>            <span class="hljs-type">Element</span> <span class="hljs-variable">attributeEle</span> <span class="hljs-operator">=</span> (Element) node;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">attributeName</span> <span class="hljs-operator">=</span> attributeEle.getAttribute(KEY_ATTRIBUTE);<span class="hljs-comment">// attribute 标签的 key 属性</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">attributeValue</span> <span class="hljs-operator">=</span> attributeEle.getAttribute(VALUE_ATTRIBUTE);<span class="hljs-comment">// attribute 标签的 value 属性</span><br>            <span class="hljs-keyword">if</span> (StringUtils.hasLength(attributeName) &amp;&amp; StringUtils.hasLength(attributeValue)) &#123;<br>               <span class="hljs-comment">// 创建 BeanMetadataAttribute 对象</span><br>               <span class="hljs-type">BeanMetadataAttribute</span> <span class="hljs-variable">attribute</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanMetadataAttribute</span>(attributeName, attributeValue);<br>               attribute.setSource(extractSource(attributeEle));<br>               <span class="hljs-comment">// 添加到 attributes 中</span><br>               qualifier.addMetadataAttribute(attribute);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>               error(<span class="hljs-string">&quot;Qualifier &#x27;attribute&#x27; tag must have a &#x27;name&#x27; and &#x27;value&#x27;&quot;</span>, attributeEle);<br>               <span class="hljs-keyword">return</span>;<br>            &#125;<br>         &#125;<br>      &#125;<br>      <span class="hljs-comment">// 添加到 qualifiers 中</span><br>      bd.addQualifier(qualifier);<br>   &#125;<br>   <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-built_in">this</span>.parseState.pop();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>七、解析import标签</title>
    <link href="/2022/06/11/%E8%A7%A3%E6%9E%90import%E6%A0%87%E7%AD%BE/"/>
    <url>/2022/06/11/%E8%A7%A3%E6%9E%90import%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">解析import标签</font></div><p>在注册<code>BeanDefinition</code>中知道解析Bean有两种方式：</p><ul><li>默认解析方式<code>parseDefaultElement()</code></li><li>自定义解析方式<code>parseCustomElement()</code></li></ul><p>默认解析过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ALIAS_ATTRIBUTE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;alias&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">IMPORT_ELEMENT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;import&quot;</span>;<br><span class="hljs-comment">//&quot;bean&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">BEAN_ELEMENT</span> <span class="hljs-operator">=</span> BeanDefinitionParserDelegate.BEAN_ELEMENT;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NESTED_BEANS_ELEMENT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;beans&quot;</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseDefaultElement</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;<br>    <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;<br>        importBeanDefinitionResource(ele);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;<br>        processAliasRegistration(ele);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;<br>        processBeanDefinition(ele, delegate);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;<br>        <span class="hljs-comment">// recurse</span><br>        doRegisterBeanDefinitions(ele);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="import示例"><a href="#import示例" class="headerlink" title="import示例"></a>import示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;beans xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span><br>       xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>       xsi:schemaLocation=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span><br><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;<br><br>&lt;context:property-placeholder location=<span class="hljs-string">&quot;classpath:application.properties&quot;</span>/&gt;<br>    &lt;<span class="hljs-keyword">import</span> resource=<span class="hljs-string">&quot;spring-$&#123;suffix1&#125;.xml&quot;</span>/&gt;<br>    &lt;<span class="hljs-keyword">import</span> resource=<span class="hljs-string">&quot;spring-$&#123;suffix2&#125;.xml&quot;</span>/&gt;<br>&lt;/beans&gt;<br>        <br><span class="hljs-comment">//application.properties内容</span><br>suffix1 = <span class="hljs-type">name1</span><br><span class="hljs-variable">suffix2</span> <span class="hljs-operator">=</span> name2<br></code></pre></td></tr></table></figure><p>一个<code>applicationContext.xml</code>配置文件中可以使用<code>import</code>标签导入其他模块的配置文件。维护成本较低。</p><h4 id="importBeanDefinitionResource-方法"><a href="#importBeanDefinitionResource-方法" class="headerlink" title="importBeanDefinitionResource()方法"></a>importBeanDefinitionResource()方法</h4><p><code>DefaultBeanDefinitionDocumentReader.importBeanDefinitionResource()</code>，如方法注释：解析import标签，并将给定资源中的bean加载到bean工厂中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">importBeanDefinitionResource</span><span class="hljs-params">(Element ele)</span> &#123;<br>    <span class="hljs-comment">// &lt;1&gt; 获取 resource 的属性值</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">location</span> <span class="hljs-operator">=</span> ele.getAttribute(RESOURCE_ATTRIBUTE);<br>    <span class="hljs-comment">// 为空，直接退出</span><br>    <span class="hljs-keyword">if</span> (!StringUtils.hasText(location)) &#123;<br>        getReaderContext().error(<span class="hljs-string">&quot;Resource location must not be empty&quot;</span>, ele);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// &lt;2&gt; 解析系统属性，格式如 ：&quot;$&#123;user.dir&#125;&quot;</span><br>    location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);<br>    <span class="hljs-comment">// 实际 Resource 集合，即 import 的地址，有哪些 Resource 资源</span><br>    Set&lt;Resource&gt; actualResources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(<span class="hljs-number">4</span>);<br>    <span class="hljs-comment">//location是绝对路径还是相对路径</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">absoluteLocation</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (URISyntaxException ex) &#123;<br>        <span class="hljs-comment">//相对位置不能转换为URI除非有一个默认的前缀&quot;classpat*:&quot;</span><br>    &#125;<br>    <span class="hljs-comment">// Absolute or relative?</span><br>    <span class="hljs-keyword">if</span> (absoluteLocation) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 添加配置文件地址的 Resource 到 actualResources 中，并加载相应的 BeanDefinition</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">importCount</span> <span class="hljs-operator">=</span> getReaderContext().getReader().loadBeanDefinitions(location, actualResources);<br>            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                logger.trace(<span class="hljs-string">&quot;Imported &quot;</span> + importCount + <span class="hljs-string">&quot; bean definitions from URL location [&quot;</span> + location + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;<br>            getReaderContext().error(<br>                <span class="hljs-string">&quot;Failed to import bean definitions from URL location [&quot;</span> + location + <span class="hljs-string">&quot;]&quot;</span>, ele, ex);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// No URL -&gt; considering resource location as relative to the current file.</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> importCount;<br>            <span class="hljs-comment">// 创建相对地址的 Resource</span><br>            <span class="hljs-type">Resource</span> <span class="hljs-variable">relativeResource</span> <span class="hljs-operator">=</span> getReaderContext().getResource().createRelative(location);<br>            <span class="hljs-keyword">if</span> (relativeResource.exists()) &#123;<br>                <span class="hljs-comment">// 加载 relativeResource 中的 BeanDefinition</span><br>                importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);<br>                <span class="hljs-comment">// 添加到 actualResources 中</span><br>                actualResources.add(relativeResource);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 获得根路径地址</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">baseLocation</span> <span class="hljs-operator">=</span> getReaderContext().getResource().getURL().toString();<br>                <span class="hljs-comment">// 添加配置文件地址的 Resource 到 actualResources 中，并加载相应的 BeanDefinition</span><br>                <span class="hljs-comment">//和上边绝对路径的添加方式一样，不过多了一步获取绝对路径</span><br>                importCount = getReaderContext().getReader().loadBeanDefinitions(<br>                    StringUtils.applyRelativePath(baseLocation, location), actualResources);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                logger.trace(<span class="hljs-string">&quot;Imported &quot;</span> + importCount + <span class="hljs-string">&quot; bean definitions from relative location [&quot;</span> + location + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>            getReaderContext().error(<span class="hljs-string">&quot;Failed to resolve current resource location&quot;</span>, ele, ex);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;<br>            getReaderContext().error(<br>                <span class="hljs-string">&quot;Failed to import bean definitions from relative location [&quot;</span> + location + <span class="hljs-string">&quot;]&quot;</span>, ele, ex);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// &lt;6&gt; 解析成功后，进行监听器激活处理</span><br>    Resource[] actResArray = actualResources.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>[<span class="hljs-number">0</span>]);<br>    getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="判断路径"><a href="#判断路径" class="headerlink" title="判断路径"></a>判断路径</h5><p>判断<code>location</code>是相对路径还是绝对路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();<br></code></pre></td></tr></table></figure><h6 id="ResourcePatternUtils-isUrl-location"><a href="#ResourcePatternUtils-isUrl-location" class="headerlink" title="ResourcePatternUtils.isUrl(location)"></a>ResourcePatternUtils.isUrl(location)</h6><p>以 <code>classpath*:</code> 或者 <code>classpath:</code> 开头的或者通过<code>resourceLocation</code>创建的<code>java.net.URL</code>为绝对路径。</p><p>方法具体内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ResourcePatternUtils.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isUrl</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String resourceLocation)</span> &#123;<br>    <span class="hljs-keyword">return</span> (resourceLocation != <span class="hljs-literal">null</span> &amp;&amp;<br>    (<br>            <span class="hljs-comment">//&quot;classpath*:&quot;开头，绝对路径</span><br>        resourceLocation.startsWith(ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX)   ||<br>            <span class="hljs-comment">//</span><br>        ResourceUtils.isUrl(resourceLocation)<br>    )<br>    );<br>&#125;<br><br><span class="hljs-comment">//ResourceUtils.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isUrl</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String resourceLocation)</span> &#123;<br>    <span class="hljs-keyword">if</span> (resourceLocation == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//&quot;classpath:&quot;开头，绝对路径</span><br>    <span class="hljs-keyword">if</span> (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//通过`resourceLocation`创建的&quot;java.net.URL&quot;，绝对路径</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(resourceLocation);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (MalformedURLException ex) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//ResourceUtils.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> URI <span class="hljs-title function_">toURI</span><span class="hljs-params">(String location)</span> <span class="hljs-keyword">throws</span> URISyntaxException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(StringUtils.replace(location, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;%20&quot;</span>));<br>&#125;<br><span class="hljs-comment">//URI.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAbsolute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> scheme != <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="处理绝对路径"><a href="#处理绝对路径" class="headerlink" title="处理绝对路径"></a>处理绝对路径</h5><p>如果是绝对路径，执行<code>int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);</code>，该方法定义在<code>AbstractBeanDefinitionReader</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(String location, <span class="hljs-meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    <span class="hljs-comment">// 获得 ResourceLoader 对象</span><br>    <span class="hljs-type">ResourceLoader</span> <span class="hljs-variable">resourceLoader</span> <span class="hljs-operator">=</span> getResourceLoader();<br>    <span class="hljs-keyword">if</span> (resourceLoader == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(<br>            <span class="hljs-string">&quot;Cannot load bean definitions from location [&quot;</span> + location + <span class="hljs-string">&quot;]: no ResourceLoader available&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (resourceLoader <span class="hljs-keyword">instanceof</span> ResourcePatternResolver) &#123;<br>        <span class="hljs-comment">//比如之前的PathMatchingResourcePatternResolver</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获得 Resource 数组，因为 Pattern 模式匹配下，可能有多个 Resource 。</span><br>            Resource[] resources = ((ResourcePatternResolver)resourceLoader).getResources(location);<br>            <span class="hljs-comment">// 加载 BeanDefinition</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> loadBeanDefinitions(resources);<br>            <span class="hljs-comment">// 添加到 actualResources 中</span><br>            <span class="hljs-keyword">if</span> (actualResources != <span class="hljs-literal">null</span>) &#123;<br>                Collections.addAll(actualResources, resources);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                logger.trace(<span class="hljs-string">&quot;Loaded &quot;</span> + count + <span class="hljs-string">&quot; bean definitions from location pattern [&quot;</span> + location + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(<br>                <span class="hljs-string">&quot;Could not resolve bean definition resource pattern [&quot;</span> + location + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Can only load single resources by absolute URL.</span><br>        <span class="hljs-comment">//只能通过绝对URL加载单个资源。</span><br>        <span class="hljs-comment">// 获得 Resource 对象</span><br>        <span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> resourceLoader.getResource(location);<br>        <span class="hljs-comment">// 加载 BeanDefinition</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> loadBeanDefinitions(resource);<br>        <span class="hljs-comment">// 添加到 actualResources 中</span><br>        <span class="hljs-keyword">if</span> (actualResources != <span class="hljs-literal">null</span>) &#123;<br>            actualResources.add(resource);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Loaded &quot;</span> + count + <span class="hljs-string">&quot; bean definitions from location [&quot;</span> + location + <span class="hljs-string">&quot;]&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先，获取 ResourceLoader 对象。</li><li>然后，根据不同的 ResourceLoader 执行不同的逻辑，主要是可能存在多个 Resource 。</li><li>最终，都会回归到 <code>XmlBeanDefinitionReader#loadBeanDefinitions(Resource... resources)</code> 方法，所以这是一个递归的过程。</li><li>另外，获得到的 Resource 的对象或数组，都会添加到 <code>actualResources</code> 中。</li></ul><h5 id="处理相对路径"><a href="#处理相对路径" class="headerlink" title="处理相对路径"></a>处理相对路径</h5><p>如果 <code>location</code> 是相对路径，则会根据相应的 Resource 计算出相应的相对路径的 Resource 对象 ，然后：</p><ul><li>若该 Resource 存在，则调用 <code>XmlBeanDefinitionReader#loadBeanDefinitions()</code> 方法，进行 BeanDefinition 加载。</li><li>否则，构造一个绝对 <code>location</code>( 即 <code>StringUtils.applyRelativePath(baseLocation, location)</code> 处的代码)，并调用 <code>#loadBeanDefinitions(String location, Set actualResources)</code> 方法，<strong>与绝对路径过程一样</strong>。</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>解析<code>import</code>的过程：<strong>获取 source 属性值，得到正确的资源路径，然后调用 <code>XmlBeanDefinitionReader#loadBeanDefinitions(Resource... resources)</code> 方法，进行递归的 BeanDefinition 加载</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十二、解析自定义标签一</title>
    <link href="/2022/06/11/%E8%A7%A3%E6%9E%90%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE/"/>
    <url>/2022/06/11/%E8%A7%A3%E6%9E%90%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">解析自定义标签一</font></div><p>默认标签的解析过程：</p><p>DefaultBeanDefinitionDocumentReader 的 <code>processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate)</code> 方法，负责 <code>bean</code> 标签的解析：</p><ul><li>在解析过程中，首先调用 <code>BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element ele)</code> 方法，完成<strong>默认标签</strong>的解析。</li><li>如果解析成功（返回的 <code>bdHolder != null</code> ），则调用 <code>BeanDefinitionParserDelegate.decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder definitionHolder)</code> 方法，完成<strong>自定义标签</strong>元素的解析。</li></ul><h4 id="decorateBeanDefinitionIfRequired-方法"><a href="#decorateBeanDefinitionIfRequired-方法" class="headerlink" title="decorateBeanDefinitionIfRequired()方法"></a><code>decorateBeanDefinitionIfRequired()</code>方法</h4><p>该方法处理自定义标签的解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title function_">decorateBeanDefinitionIfRequired</span><span class="hljs-params">(Element ele, BeanDefinitionHolder originalDef)</span> &#123;<br>    <span class="hljs-keyword">return</span> decorateBeanDefinitionIfRequired(ele, originalDef, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title function_">decorateBeanDefinitionIfRequired</span><span class="hljs-params">(</span><br><span class="hljs-params">    Element ele, BeanDefinitionHolder originalDef, <span class="hljs-meta">@Nullable</span> BeanDefinition containingBd)</span> &#123;<br><br>    <span class="hljs-type">BeanDefinitionHolder</span> <span class="hljs-variable">finalDefinition</span> <span class="hljs-operator">=</span> originalDef;<br><br>    <span class="hljs-comment">// Decorate based on custom attributes first.</span><br>    <span class="hljs-comment">// &lt;1&gt; 遍历属性，查看是否有适用于装饰的【属性】</span><br>    <span class="hljs-type">NamedNodeMap</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> ele.getAttributes();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; attributes.getLength(); i++) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> attributes.item(i);<br>        finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);<br>    &#125;<br><br>    <span class="hljs-comment">// Decorate based on custom nested elements.</span><br>    <span class="hljs-comment">// &lt;2&gt; 遍历子节点，查看是否有适用于修饰的【子节点】</span><br>    <span class="hljs-type">NodeList</span> <span class="hljs-variable">children</span> <span class="hljs-operator">=</span> ele.getChildNodes();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; children.getLength(); i++) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> children.item(i);<br>        <span class="hljs-keyword">if</span> (node.getNodeType() == Node.ELEMENT_NODE) &#123;<br>            finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> finalDefinition;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&lt;1&gt;</code> 和 <code>&lt;2&gt;</code> 处，都是遍历，前者遍历的是属性( <code>attributes</code> )，后者遍历的是子节点( <code>childNodes</code> )，最终调用的都是 <code>#decorateIfRequired(Node node, BeanDefinitionHolder originalDef, BeanDefinition containingBd)</code> 方法，装饰对应的节点( Node )。</p><h5 id="decorateIfRequired-方法"><a href="#decorateIfRequired-方法" class="headerlink" title="decorateIfRequired()方法"></a><code>decorateIfRequired()</code>方法</h5><p>在<code>decorateBeanDefinitionIfRequired()</code>方法中分别遍历了<code>属性</code>和<code>子节点</code>后，都会执行该方法进行对应节点（Node）的装饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title function_">decorateIfRequired</span><span class="hljs-params">(</span><br><span class="hljs-params">    Node node, BeanDefinitionHolder originalDef, <span class="hljs-meta">@Nullable</span> BeanDefinition containingBd)</span> &#123;<br><br>    <span class="hljs-comment">// &lt;1&gt; 获取自定义标签的命名空间</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">namespaceUri</span> <span class="hljs-operator">=</span> getNamespaceURI(node);<br>    <span class="hljs-comment">// &lt;2&gt; 过滤掉默认命名标签</span><br>    <span class="hljs-keyword">if</span> (namespaceUri != <span class="hljs-literal">null</span> &amp;&amp; !isDefaultNamespace(namespaceUri)) &#123;<br>        <span class="hljs-comment">// &lt;2&gt; 获取相应的处理器</span><br>        <span class="hljs-type">NamespaceHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);<br>        <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//如果处理器存在，进行装饰处理</span><br>            <span class="hljs-type">BeanDefinitionHolder</span> <span class="hljs-variable">decorated</span> <span class="hljs-operator">=</span><br>                handler.decorate(node, originalDef, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParserContext</span>(<span class="hljs-built_in">this</span>.readerContext, <span class="hljs-built_in">this</span>, containingBd));<br>            <span class="hljs-keyword">if</span> (decorated != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> decorated;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namespaceUri.startsWith(<span class="hljs-string">&quot;http://www.springframework.org/schema/&quot;</span>)) &#123;<br>            error(<span class="hljs-string">&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot;</span> + namespaceUri + <span class="hljs-string">&quot;]&quot;</span>, node);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// A custom namespace, not to be handled by Spring - maybe &quot;xml:...&quot;.</span><br>            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                logger.debug(<span class="hljs-string">&quot;No Spring NamespaceHandler found for XML schema namespace [&quot;</span> + namespaceUri + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> originalDef;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十、解析bean标签子元素一</title>
    <link href="/2022/06/11/%E8%A7%A3%E6%9E%90bean%E6%A0%87%E7%AD%BE%E5%AD%90%E5%85%83%E7%B4%A0%E4%B8%80/"/>
    <url>/2022/06/11/%E8%A7%A3%E6%9E%90bean%E6%A0%87%E7%AD%BE%E5%AD%90%E5%85%83%E7%B4%A0%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">解析bean标签子元素一</font></div><p>完成<code>bean</code>标签属性解析后，会进行子元素的解析。</p><p>本篇先看<code>meta</code>、<code>lookup-metod</code>、<code>replace-method</code>三个子元素是如何解析的。</p><h4 id="meta子元素"><a href="#meta子元素" class="headerlink" title="meta子元素"></a><code>meta</code>子元素</h4><p><strong>meta</strong> ：元数据。当需要使用里面的信息时可以通过 key 获取。</p><p>meta 所声明的 key 并不会在 Bean 中体现，只是一个额外的声明，当我们需要使用里面的信息时，通过调用 BeanDefinition 的 <code>getAttribute(String name)</code> 方法来获取。</p><p>通过<code>BeanDefinitionParserDelegate.parseMetaElements()</code>来完成对meta子元素的解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseMetaElements</span><span class="hljs-params">(Element ele, BeanMetadataAttributeAccessor attributeAccessor)</span> &#123;<br>    <span class="hljs-type">NodeList</span> <span class="hljs-variable">nl</span> <span class="hljs-operator">=</span> ele.getChildNodes();<br>    <span class="hljs-comment">// 遍历子节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nl.item(i);<br>        <span class="hljs-comment">//例：// &lt;meta key=&quot;special-data&quot; value=&quot;sprecial stragey&quot; /&gt;</span><br>        <span class="hljs-keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) &#123;<br>            <span class="hljs-type">Element</span> <span class="hljs-variable">metaElement</span> <span class="hljs-operator">=</span> (Element) node;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> metaElement.getAttribute(KEY_ATTRIBUTE);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> metaElement.getAttribute(VALUE_ATTRIBUTE);<br>            <span class="hljs-comment">// 创建 BeanMetadataAttribute 对象</span><br>            <span class="hljs-type">BeanMetadataAttribute</span> <span class="hljs-variable">attribute</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanMetadataAttribute</span>(key, value);<br>            attribute.setSource(extractSource(metaElement));<br>            <span class="hljs-comment">// 添加到 BeanMetadataAttributeAccessor 中</span><br>            attributeAccessor.addMetadataAttribute(attribute);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析过程：获取相应的 key - value 构建<code>BeanMetadataAttribute</code>对象，然后调用 <code>BeanMetadataAttributeAccessor.addMetadataAttribute(BeanMetadataAttribute) </code>方法，添加 <code>BeanMetadataAttribute</code>加入到<code>AbstractBeanDefinition</code>中。</p><p><code>AbstractBeanDefinition</code>继承<code>BeanMetadataAttributeAccessor</code>类。调用parseMetaElements()上送的就是AbstractBeanDefinition。</p><h5 id="addMetadataAttribute-方法"><a href="#addMetadataAttribute-方法" class="headerlink" title="addMetadataAttribute()方法"></a><code>addMetadataAttribute()</code>方法</h5><p>调用 <code>BeanMetadataAttributeAccessor.addMetadataAttribute(BeanMetadataAttribute)</code> 方法，添加 <code>BeanMetadataAttribute</code>加入到<code>AbstractBeanDefinition</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addMetadataAttribute</span><span class="hljs-params">(BeanMetadataAttribute attribute)</span> &#123;<br>    <span class="hljs-built_in">super</span>.setAttribute(attribute.getName(), attribute);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>BeanMetadataAttributeAccessor </code>继承<code>AttributeAccessorSupport</code>类。<code>AttributeAccessorSupport</code>类实现了<code>AttributeAccessor</code>接口，如上篇提到，该接口提供了对属性的获取、设置、删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAttribute</span><span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Object value)</span> &#123;<br>    Assert.notNull(name, <span class="hljs-string">&quot;Name must not be null&quot;</span>);<br>    <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.attributes.put(name, value);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        removeAttribute(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="getAttribute-方法"><a href="#getAttribute-方法" class="headerlink" title="getAttribute()方法"></a><code>getAttribute()</code>方法</h5><p>设置元数据后，则可以通过调用 BeanDefinition 的 <code>.getAttribute(String name)</code> 方法来获取属性。</p><p><code>AbstractBeanDefinition</code>继承<code>BeanMetadataAttributeAccessor</code>类。<code>BeanMetadataAttributeAccessor </code>继承<code>AttributeAccessorSupport</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AttributeAccessorSupport.java</span><br><span class="hljs-comment">/** Map with String keys and Object values. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; attributes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getAttribute</span><span class="hljs-params">(String name)</span> &#123;<br>    Assert.notNull(name, <span class="hljs-string">&quot;Name must not be null&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.attributes.get(name);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="lookup-method子元素"><a href="#lookup-method子元素" class="headerlink" title="lookup-method子元素"></a><code>lookup-method</code>子元素</h4><p>依赖注入－方法注入，使用<lookup-method/>标签。和<replace-method/>类似，一个注入bean，一个替代原有方法。</p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义一个水果类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Fruit</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I got Fruit&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 苹果</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Apple</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I got a fresh apple&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 香蕉</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bananer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Bananer</span> <span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I got a  fresh bananer&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 水果盘，可以拿到水果</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitPlate</span>&#123;<br>    <span class="hljs-comment">// 抽象方法获取新鲜水果</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Fruit <span class="hljs-title function_">getFruit</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//spring配置</span><br>&lt;bean id=<span class="hljs-string">&quot;apple&quot;</span> class=<span class="hljs-string">&quot;com.jievhaha.test.Apple&quot;</span> scope=<span class="hljs-string">&quot;prototype&quot;</span>/&gt;<br>&lt;bean id=<span class="hljs-string">&quot;bananer&quot;</span> class=<span class="hljs-string">&quot;com.jievhaha.test.Bananer &quot;</span> scope=<span class="hljs-string">&quot;prototype&quot;</span>/&gt;<br> <br>&lt;bean id=<span class="hljs-string">&quot;fruitPlate1&quot;</span> class=<span class="hljs-string">&quot;com.jievhaha.test.FruitPlate&quot;</span>&gt;<br>    &lt;lookup-method name=<span class="hljs-string">&quot;getFruit&quot;</span> bean=<span class="hljs-string">&quot;apple&quot;</span>/&gt;<br>&lt;/bean&gt;<br>&lt;bean id=<span class="hljs-string">&quot;fruitPlate2&quot;</span> class=<span class="hljs-string">&quot;com.jievhaha.test.FruitPlate&quot;</span>&gt;<br>    &lt;lookup-method name=<span class="hljs-string">&quot;getFruit&quot;</span> bean=<span class="hljs-string">&quot;bananer&quot;</span>/&gt;<br>&lt;/bean&gt;<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;classpath:resource/applicationContext.xml&quot;</span>);<br><br>    FruitPlate fp1= (FruitPlate)app.getBean(<span class="hljs-string">&quot;fruitPlate1&quot;</span>);<br>    <span class="hljs-type">FruitPlate</span> <span class="hljs-variable">fp2</span> <span class="hljs-operator">=</span> (FruitPlate)app.getBean(<span class="hljs-string">&quot;fruitPlate2&quot;</span>);<br><br>    fp1.getFruit();<span class="hljs-comment">//&quot;I got Fruit&quot;,&quot;I got a fresh apple&quot;</span><br>    fp2.getFruit();<span class="hljs-comment">//&quot;I got Fruit&quot;,&quot;I got a  fresh bananer&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>lookup-method为抽象方法指定返回类型，应用了CGLIB（动态代理）类库。</p><h5 id="parseLookupOverrideSubElements-方法"><a href="#parseLookupOverrideSubElements-方法" class="headerlink" title="parseLookupOverrideSubElements()方法"></a><code>parseLookupOverrideSubElements()</code>方法</h5><p>通过<code>BeanDefinitionParserDelegate.parseLookupOverrideSubElements()</code>来完成对lookup-method子元素的解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseLookupOverrideSubElements</span><span class="hljs-params">(Element beanEle, MethodOverrides overrides)</span> &#123;<br>    <span class="hljs-type">NodeList</span> <span class="hljs-variable">nl</span> <span class="hljs-operator">=</span> beanEle.getChildNodes();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;<br>        <span class="hljs-comment">// 遍历子节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nl.item(i);<br>        <span class="hljs-keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) &#123;<br>            <span class="hljs-type">Element</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> (Element) node;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);<span class="hljs-comment">//name属性，指定了要返回指定类型对象的抽象方法</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">beanRef</span> <span class="hljs-operator">=</span> ele.getAttribute(BEAN_ELEMENT);<span class="hljs-comment">//bean属性，指定了抽象方法要返回的对象的具体类型</span><br>            <span class="hljs-comment">// 创建 LookupOverride 对象</span><br>            <span class="hljs-type">LookupOverride</span> <span class="hljs-variable">override</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LookupOverride</span>(methodName, beanRef);<br>            <span class="hljs-comment">//设置数据源配置文件，对象的确切类型取决于配置文件的配置机制</span><br>            override.setSource(extractSource(ele));<br>            <span class="hljs-comment">// 添加到 MethodOverrides 中</span><br>            overrides.addOverride(override);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析过程和 <code>meta</code> 子元素没有多大区别，同样是解析 methodName、beanRef 构造一个 LookupOverride 对象，然后记录到 AbstractBeanDefinition 中的 <code>methodOverrides</code> 属性中。</p><h4 id="replace-method-方法"><a href="#replace-method-方法" class="headerlink" title="replace-method()方法"></a><code>replace-method()</code>方法</h4><p><strong>replaced-method</strong> ：可以在运行时调用新的方法替换现有的方法，还能动态的更新原有方法的逻辑。</p><p>该标签使用方法和<code>lookup-method</code>标签大同小异，不过替代原有方法的类需要实现<code>org.springframework.beans.factory.support.MethodReplacer</code> 接口，一个注入bean，一个替代原有方法。</p><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Method</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是原始方法&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodReplace</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodReplacer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">reimplement</span><span class="hljs-params">(Object obj, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是替换方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//spring配置文件内容</span><br>&lt;bean id=<span class="hljs-string">&quot;methodReplace&quot;</span> class=<span class="hljs-string">&quot;com.jievhaha.test.MethodReplace&quot;</span>/&gt;<br>&lt;bean id=<span class="hljs-string">&quot;method&quot;</span> class=<span class="hljs-string">&quot;com.jievhaha.test.Method&quot;</span>&gt;<br>    &lt;replaced-method name=<span class="hljs-string">&quot;display&quot;</span> replacer=<span class="hljs-string">&quot;methodReplace&quot;</span>/&gt;<br>&lt;/bean&gt;<br><br><span class="hljs-comment">//测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;classpath:spring.xml&quot;</span>);<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> (Method) context.getBean(<span class="hljs-string">&quot;method&quot;</span>);<br>    method.display();<span class="hljs-comment">//&quot;我是替换方法&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="parseReplacedMethodSubElements-方法"><a href="#parseReplacedMethodSubElements-方法" class="headerlink" title="parseReplacedMethodSubElements()方法"></a><code>parseReplacedMethodSubElements()</code>方法</h5><p>通过 <code>BeanDefinitionParserDelegate.parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides)</code>来解析replace-method标签：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseReplacedMethodSubElements</span><span class="hljs-params">(Element beanEle, MethodOverrides overrides)</span> &#123;<br>    <span class="hljs-type">NodeList</span> <span class="hljs-variable">nl</span> <span class="hljs-operator">=</span> beanEle.getChildNodes();<br>    <span class="hljs-comment">// 遍历子节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nl.item(i);<br>        <span class="hljs-keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) &#123;<br>            <span class="hljs-type">Element</span> <span class="hljs-variable">replacedMethodEle</span> <span class="hljs-operator">=</span> (Element) node;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> replacedMethodEle.getAttribute(NAME_ATTRIBUTE);<span class="hljs-comment">//name属性，替代的方法名</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">callback</span> <span class="hljs-operator">=</span> replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);<span class="hljs-comment">//replacer，用哪个类的方法替代</span><br>            <span class="hljs-comment">// 创建 ReplaceOverride 对象</span><br>            <span class="hljs-type">ReplaceOverride</span> <span class="hljs-variable">replaceOverride</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReplaceOverride</span>(name, callback);<br>            <span class="hljs-comment">// Look for arg-type match elements.</span><br>            List&lt;Element&gt; argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);<span class="hljs-comment">// arg-type 子标签</span><br>            <span class="hljs-keyword">for</span> (Element argTypeEle : argTypeEles) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">match</span> <span class="hljs-operator">=</span> argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);<span class="hljs-comment">// arg-type 子标签的 match 属性</span><br>                match = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));<br>                <span class="hljs-keyword">if</span> (StringUtils.hasText(match)) &#123;<br>                    replaceOverride.addTypeIdentifier(match);<br>                &#125;<br>            &#125;<br>            replaceOverride.setSource(extractSource(replacedMethodEle));<br>            <span class="hljs-comment">// 添加到 MethodOverrides 中</span><br>            overrides.addOverride(replaceOverride);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九、解析bean标签BeanDefinition</title>
    <link href="/2022/06/11/%E8%A7%A3%E6%9E%90bean%E6%A0%87%E7%AD%BEBeanDefinition/"/>
    <url>/2022/06/11/%E8%A7%A3%E6%9E%90bean%E6%A0%87%E7%AD%BEBeanDefinition/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">解析bean标签BeanDefinition</font></div><p>bean标签的所有子元素在BeanDefinition对象中都有与之相对应的属性。</p><h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p>BeanDefinition是一个接口，描述了Bean实例的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AttributeAccessor</span>, BeanMetadataElement &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">SCOPE_SINGLETON</span> <span class="hljs-operator">=</span> ConfigurableBeanFactory.SCOPE_SINGLETON;<br><span class="hljs-type">String</span> <span class="hljs-variable">SCOPE_PROTOTYPE</span> <span class="hljs-operator">=</span> ConfigurableBeanFactory.SCOPE_PROTOTYPE;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">ROLE_APPLICATION</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">ROLE_SUPPORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">ROLE_INFRASTRUCTURE</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setParentName</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String parentName)</span>;<br><span class="hljs-meta">@Nullable</span><br>String <span class="hljs-title function_">getParentName</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanClassName</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String beanClassName)</span>;<br><span class="hljs-meta">@Nullable</span><br>String <span class="hljs-title function_">getBeanClassName</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setScope</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String scope)</span>;<br><span class="hljs-meta">@Nullable</span><br>String <span class="hljs-title function_">getScope</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setLazyInit</span><span class="hljs-params">(<span class="hljs-type">boolean</span> lazyInit)</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isLazyInit</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setDependsOn</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String... dependsOn)</span>;<br><span class="hljs-meta">@Nullable</span><br>String[] getDependsOn();<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setAutowireCandidate</span><span class="hljs-params">(<span class="hljs-type">boolean</span> autowireCandidate)</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isAutowireCandidate</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrimary</span><span class="hljs-params">(<span class="hljs-type">boolean</span> primary)</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrimary</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setFactoryBeanName</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String factoryBeanName)</span>;<br><span class="hljs-meta">@Nullable</span><br>String <span class="hljs-title function_">getFactoryBeanName</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setFactoryMethodName</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String factoryMethodName)</span>;<br><span class="hljs-meta">@Nullable</span><br>String <span class="hljs-title function_">getFactoryMethodName</span><span class="hljs-params">()</span>;<br><br>ConstructorArgumentValues <span class="hljs-title function_">getConstructorArgumentValues</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasConstructorArgumentValues</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> !getConstructorArgumentValues().isEmpty();<br>&#125;<br><br>MutablePropertyValues <span class="hljs-title function_">getPropertyValues</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPropertyValues</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> !getPropertyValues().isEmpty();<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setInitMethodName</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String initMethodName)</span>;<br><span class="hljs-meta">@Nullable</span><br>String <span class="hljs-title function_">getInitMethodName</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setDestroyMethodName</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String destroyMethodName)</span>;<br><span class="hljs-meta">@Nullable</span><br>String <span class="hljs-title function_">getDestroyMethodName</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setRole</span><span class="hljs-params">(<span class="hljs-type">int</span> role)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">getRole</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setDescription</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String description)</span>;<br><span class="hljs-meta">@Nullable</span><br>String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span>;<br><br>ResolvableType <span class="hljs-title function_">getResolvableType</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrototype</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isAbstract</span><span class="hljs-params">()</span>;<br><br><span class="hljs-meta">@Nullable</span><br>String <span class="hljs-title function_">getResourceDescription</span><span class="hljs-params">()</span>;<br>    <br><span class="hljs-meta">@Nullable</span><br>BeanDefinition <span class="hljs-title function_">getOriginatingBeanDefinition</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/spring_IOC/beandefinition%E7%88%B6%E7%B1%BB%E5%AD%90%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="beandefinition父类子类结构图"></p><h5 id="BeanDefinition的父类"><a href="#BeanDefinition的父类" class="headerlink" title="BeanDefinition的父类"></a>BeanDefinition的父类</h5><p>如上可以看出<code>BeanDefinition</code>继承自<code>AttributeAccessor</code>和<code>BeanMetadataElement</code>。</p><h6 id="AttributeAccessor"><a href="#AttributeAccessor" class="headerlink" title="AttributeAccessor"></a>AttributeAccessor</h6><p>该接口定义了与其他对象的元数据进行连接和访问的约定，即对属性的获取、设置、删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AttributeAccessor</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setAttribute</span><span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Object value)</span>;<br><br><span class="hljs-meta">@Nullable</span><br>Object <span class="hljs-title function_">getAttribute</span><span class="hljs-params">(String name)</span>;<br><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">default</span> &lt;T&gt; T <span class="hljs-title function_">computeAttribute</span><span class="hljs-params">(String name, Function&lt;String, T&gt; computeFunction)</span> &#123;<br>Assert.notNull(name, <span class="hljs-string">&quot;Name must not be null&quot;</span>);<br>Assert.notNull(computeFunction, <span class="hljs-string">&quot;Compute function must not be null&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> getAttribute(name);<br><span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>value = computeFunction.apply(name);<br>Assert.state(value != <span class="hljs-literal">null</span>,<br>() -&gt; String.format(<span class="hljs-string">&quot;Compute function must not return null for attribute named &#x27;%s&#x27;&quot;</span>, name));<br>setAttribute(name, value);<br>&#125;<br><span class="hljs-keyword">return</span> (T) value;<br>&#125;<br><br><span class="hljs-meta">@Nullable</span><br>Object <span class="hljs-title function_">removeAttribute</span><span class="hljs-params">(String name)</span>;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">hasAttribute</span><span class="hljs-params">(String name)</span>;<br><br>String[] attributeNames();<br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="BeanMetadataElement"><a href="#BeanMetadataElement" class="headerlink" title="BeanMetadataElement"></a>BeanMetadataElement</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanMetadataElement</span> &#123;<br>    <span class="hljs-comment">//返回此元数据元素的配置源，可能为null</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">default</span> Object <span class="hljs-title function_">getSource</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="BeanDefinition的子类"><a href="#BeanDefinition的子类" class="headerlink" title="BeanDefinition的子类"></a>BeanDefinition的子类</h5><p>三个常用的子类：</p><p><code>package org.springframework.beans.factory.support.RootBeanDefinition</code></p><p><code>package org.springframework.beans.factory.support.ChildBeanDefinition</code></p><p><code>package org.springframework.beans.factory.support.RootBeanDefinition</code></p><p>如果配置文件中定义了父 <code>bean</code> 和 子 <code>bean</code> ，则父 <code>bean</code> 用 RootBeanDefinition 表示，子 <code>bean</code> 用 ChildBeanDefinition 表示，而没有父 <code>bean</code> 的就使用RootBeanDefinition 表示。</p><h4 id="解析bean标签"><a href="#解析bean标签" class="headerlink" title="解析bean标签"></a>解析bean标签</h4><h5 id="createBeanDefinition-方法"><a href="#createBeanDefinition-方法" class="headerlink" title="createBeanDefinition()方法"></a><code>createBeanDefinition()</code>方法</h5><p>在 <code>BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element ele, String beanName, BeanDefinition containingBean)</code> 方法中进行<code>bean</code>标签解析的过程中，内部调用了该方法。</p><p><code>BeanDefinitionParserDelegate.createBeanDefinition()</code>返回<code>AbstractBeanDefinition</code>对象，方法内部调用的<code>BeanDefinitionReaderUtils.createBeanDefinition()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> AbstractBeanDefinition <span class="hljs-title function_">createBeanDefinition</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String className, <span class="hljs-meta">@Nullable</span> String parentName)</span><br>    <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br><br>    <span class="hljs-keyword">return</span> BeanDefinitionReaderUtils.createBeanDefinition(<br>        parentName, className, <span class="hljs-built_in">this</span>.readerContext.getBeanClassLoader());<br>&#125;<br><br><span class="hljs-comment">//该方法主要是，创建 GenericBeanDefinition 对象，并设置 parentName、className、beanClass 属性。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AbstractBeanDefinition <span class="hljs-title function_">createBeanDefinition</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String parentName, <span class="hljs-meta">@Nullable</span> String className, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br><br>    <span class="hljs-comment">// 创建 GenericBeanDefinition 对象</span><br>    <span class="hljs-type">GenericBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericBeanDefinition</span>();<br>    <span class="hljs-comment">// 设置 parentName</span><br>    bd.setParentName(parentName);<br>    <span class="hljs-keyword">if</span> (className != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (classLoader != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果有给定的classLoader，设置 beanClass</span><br>            bd.setBeanClass(ClassUtils.forName(className, classLoader));<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 设置 beanClassName</span><br>            bd.setBeanClassName(className);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bd;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="parseBeanDefinitionAttributes-方法"><a href="#parseBeanDefinitionAttributes-方法" class="headerlink" title="parseBeanDefinitionAttributes()方法"></a><code>parseBeanDefinitionAttributes()</code>方法</h5><p>执行完<code>createBeanDefinition()</code>方法返回<code>AbstractBeanDefinition</code>对象后，进而执行该方法进行bean的属性设置。</p><p><code>BeanDefinitionParserDelegate.parseBeanDefinitionAttributes()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> AbstractBeanDefinition <span class="hljs-title function_">parseBeanDefinitionAttributes</span><span class="hljs-params">(Element ele, String beanName,</span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> BeanDefinition containingBean, AbstractBeanDefinition bd)</span> &#123;<br>    <span class="hljs-comment">// 解析 scope 属性</span><br>    <span class="hljs-keyword">if</span> (ele.hasAttribute(SINGLETON_ATTRIBUTE)) &#123;<br>        error(<span class="hljs-string">&quot;Old 1.x &#x27;singleton&#x27; attribute in use - upgrade to &#x27;scope&#x27; declaration&quot;</span>, ele);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ele.hasAttribute(SCOPE_ATTRIBUTE)) &#123;<br>        bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (containingBean != <span class="hljs-literal">null</span>) &#123;<br>        bd.setScope(containingBean.getScope());<br>    &#125;<br><br>    <span class="hljs-comment">// 解析 abstract 属性</span><br>    <span class="hljs-keyword">if</span> (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) &#123;<br>        bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));<br>    &#125;<br><br>    <span class="hljs-comment">// 解析 lazy-init 属性</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lazyInit</span> <span class="hljs-operator">=</span> ele.getAttribute(LAZY_INIT_ATTRIBUTE);<br>    <span class="hljs-keyword">if</span> (isDefaultValue(lazyInit)) &#123;<br>        lazyInit = <span class="hljs-built_in">this</span>.defaults.getLazyInit();<br>    &#125;<br>    bd.setLazyInit(TRUE_VALUE.equals(lazyInit));<br><br>    <span class="hljs-comment">// 解析 autowire 属性</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">autowire</span> <span class="hljs-operator">=</span> ele.getAttribute(AUTOWIRE_ATTRIBUTE);<br>    bd.setAutowireMode(getAutowireMode(autowire));<br><br>    <span class="hljs-comment">// 解析 depends-on 属性</span><br>    <span class="hljs-keyword">if</span> (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">dependsOn</span> <span class="hljs-operator">=</span> ele.getAttribute(DEPENDS_ON_ATTRIBUTE);<br>        bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));<br>    &#125;<br><br>    <span class="hljs-comment">// 解析 autowire-candidate 属性</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">autowireCandidate</span> <span class="hljs-operator">=</span> ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);<br>    <span class="hljs-keyword">if</span> (isDefaultValue(autowireCandidate)) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">candidatePattern</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.defaults.getAutowireCandidates();<br>        <span class="hljs-keyword">if</span> (candidatePattern != <span class="hljs-literal">null</span>) &#123;<br>            String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);<br>            bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));<br>    &#125;<br><br>    <span class="hljs-comment">// 解析 primary 标签</span><br>    <span class="hljs-keyword">if</span> (ele.hasAttribute(PRIMARY_ATTRIBUTE)) &#123;<br>        bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));<br>    &#125;<br><br>    <span class="hljs-comment">// 解析 init-method 属性</span><br>    <span class="hljs-keyword">if</span> (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">initMethodName</span> <span class="hljs-operator">=</span> ele.getAttribute(INIT_METHOD_ATTRIBUTE);<br>        bd.setInitMethodName(initMethodName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.defaults.getInitMethod() != <span class="hljs-literal">null</span>) &#123;<br>        bd.setInitMethodName(<span class="hljs-built_in">this</span>.defaults.getInitMethod());<br>        bd.setEnforceInitMethod(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 解析 destroy-method 属性</span><br>    <span class="hljs-keyword">if</span> (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">destroyMethodName</span> <span class="hljs-operator">=</span> ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);<br>        bd.setDestroyMethodName(destroyMethodName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.defaults.getDestroyMethod() != <span class="hljs-literal">null</span>) &#123;<br>        bd.setDestroyMethodName(<span class="hljs-built_in">this</span>.defaults.getDestroyMethod());<br>        bd.setEnforceDestroyMethod(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 解析 factory-method 属性</span><br>    <span class="hljs-keyword">if</span> (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) &#123;<br>        bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) &#123;<br>        bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> bd;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BeanDefinition解析的整体流程"><a href="#BeanDefinition解析的整体流程" class="headerlink" title="BeanDefinition解析的整体流程"></a>BeanDefinition解析的整体流程</h4><p>下边四篇进行具体分析。</p><p>解析 BeanDefinition 的<strong>入口在DefaultBeanDefinitionDocumentReader的<code>.parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)</code> 方法</strong>。该方法会根据命令空间来判断标签是<strong>默认标签</strong>还是<strong>自定义标签</strong>，其中：</p><ul><li>默认标签，由 <code>parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate)</code> 方法来实现</li><li>自定义标签，由 BeanDefinitionParserDelegate 的 <code>parseCustomElement(Element ele, @Nullable BeanDefinition containingBd)</code> 方法来实现。</li></ul><p>在默认标签解析中，会根据标签名称的不同进行 <code>import</code>、<code>alias</code>、<code>bean</code>、<code>beans</code> 四大标签进行处理。其中 <code>bean</code> 标签的解析为核心，它由 <code>processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate)</code> 方法实现。</p><p><code>processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate)</code> 方法，开始进入解析核心工作，分为三步：</p><ol><li>解析默认标签的<strong>默认</strong>标签：<code>BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element ele, ...)</code> 方法。该方法会依次解析 <code>bean</code> 标签的属性、各个子元素，解析完成后返回一个 GenericBeanDefinition 实例对象。</li><li>解析默认标签下的<strong>自定义</strong>标签：<code>BeanDefinitionParserDelegate.decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder definitionHolder)</code> 方法。</li><li>注册解析的 BeanDefinition：<code>BeanDefinitionReaderUtils#registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</code> 方法。</li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四、获取验证模型</title>
    <link href="/2022/06/11/%E8%8E%B7%E5%8F%96%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/06/11/%E8%8E%B7%E5%8F%96%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">获取验证模型</font></div><p>接《加载BeanDefinition》文。</p><h4 id="getValidationModeForResource"><a href="#getValidationModeForResource" class="headerlink" title="getValidationModeForResource"></a>getValidationModeForResource</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//禁用验证模式，值为0</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">VALIDATION_NONE</span> <span class="hljs-operator">=</span> XmlValidationModeDetector.VALIDATION_NONE;<br><span class="hljs-comment">//自动获取验证模式，值为1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">VALIDATION_AUTO</span> <span class="hljs-operator">=</span> XmlValidationModeDetector.VALIDATION_AUTO;<br><span class="hljs-comment">//DTD 验证模式，值为2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">VALIDATION_DTD</span> <span class="hljs-operator">=</span> XmlValidationModeDetector.VALIDATION_DTD;<br><span class="hljs-comment">//XSD 验证模式，值为3</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">VALIDATION_XSD</span> <span class="hljs-operator">=</span> XmlValidationModeDetector.VALIDATION_XSD;<br><span class="hljs-comment">//验证模式。默认为自动模式。</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">validationMode</span> <span class="hljs-operator">=</span> VALIDATION_AUTO;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValidationModeForResource</span><span class="hljs-params">(Resource resource)</span> &#123;<br>    <span class="hljs-comment">// &lt;1&gt; 获取指定的验证模式</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">validationModeToUse</span> <span class="hljs-operator">=</span> getValidationMode();<br>    <span class="hljs-comment">// 如果手动指定，则直接返回</span><br>    <span class="hljs-keyword">if</span> (validationModeToUse != VALIDATION_AUTO) &#123;<br>        <span class="hljs-keyword">return</span> validationModeToUse;<br>    &#125;<br>    <span class="hljs-comment">// 自动获取验证模式</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">detectedMode</span> <span class="hljs-operator">=</span> detectValidationMode(resource);<br>    <span class="hljs-keyword">if</span> (detectedMode != VALIDATION_AUTO) &#123;<br>        <span class="hljs-keyword">return</span> detectedMode;<br>    &#125;<br>    <span class="hljs-comment">// 否则，使用 VALIDATION_XSD</span><br>    <span class="hljs-keyword">return</span> VALIDATION_XSD;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>&lt;1&gt;</code> 处，调用 <code>getValidationMode()</code> 方法，获取指定的验证模式( <code>validationMode</code> )。如果有手动指定，则直接返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValidationMode</span><span class="hljs-params">(<span class="hljs-type">int</span> validationMode)</span> &#123;<br>    <span class="hljs-built_in">this</span>.validationMode = validationMode;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValidationMode</span><span class="hljs-params">()</span> <br>    <span class="hljs-comment">//如上段，该值默认为VALIDATION_AUTO</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.validationMode;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>&lt;2&gt;</code> 处，调用 <code>detectValidationMode(Resource resource)</code> 方法，自动获取验证模式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//下段介绍XmlValidationModeDetector</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">XmlValidationModeDetector</span> <span class="hljs-variable">validationModeDetector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlValidationModeDetector</span>();<br><br><span class="hljs-comment">//检测对&#123;@link Resource&#125;标识的XML文件执行哪种验证。如果文件具有&#123;@code DOCTYPE&#125;定义，则使用DTD验证，否则采用XSD验证。在接下来的方法中可以看到。</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">detectValidationMode</span><span class="hljs-params">(Resource resource)</span> &#123;<br>    <span class="hljs-comment">// 不可读，抛出 BeanDefinitionStoreException 异常</span><br>    <span class="hljs-keyword">if</span> (resource.isOpen()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(<br>            <span class="hljs-string">&quot;Passed-in Resource [&quot;</span> + resource + <span class="hljs-string">&quot;] contains an open stream: &quot;</span> +<br>            <span class="hljs-string">&quot;cannot determine validation mode automatically. Either pass in a Resource &quot;</span> +<br>            <span class="hljs-string">&quot;that is able to create fresh streams, or explicitly specify the validationMode &quot;</span> +<br>            <span class="hljs-string">&quot;on your XmlBeanDefinitionReader instance.&quot;</span>);<br>    &#125;<br><br>    InputStream inputStream;<br>    <span class="hljs-keyword">try</span> &#123;<br>        inputStream = resource.getInputStream();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(<br>            <span class="hljs-string">&quot;Unable to determine validation mode for [&quot;</span> + resource + <span class="hljs-string">&quot;]: cannot open InputStream. &quot;</span> +<br>            <span class="hljs-string">&quot;Did you attempt to load directly from a SAX InputSource without specifying the &quot;</span> +<br>            <span class="hljs-string">&quot;validationMode on your XmlBeanDefinitionReader instance?&quot;</span>, ex);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;x&gt; 获取相应的验证模式</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//XmlValidationModeDetector上边已经定义</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.validationModeDetector.detectValidationMode(inputStream);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(<span class="hljs-string">&quot;Unable to determine validation mode for [&quot;</span> +<br>                                               resource + <span class="hljs-string">&quot;]: an error occurred whilst reading from the InputStream.&quot;</span>, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="XmlValidationModeDetector"><a href="#XmlValidationModeDetector" class="headerlink" title="XmlValidationModeDetector"></a>XmlValidationModeDetector</h4><p><code>org.springframework.util.xml.XmlValidationModeDetector</code> ，XML 验证模式探测器。</p><p>主要看上段return this.validationModeDetector.detectValidationMode(inputStream);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">detectValidationMode</span><span class="hljs-params">(InputStream inputStream)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(inputStream))) &#123;<br>        <span class="hljs-comment">// 是否为 DTD 校验模式。默认为，非 DTD 模式，即 XSD 模式</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isDtdValidated</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        String content;<br>        <span class="hljs-comment">// &lt;0&gt; 循环，逐行读取 XML 文件的内容</span><br>        <span class="hljs-keyword">while</span> ((content = reader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>            content = consumeCommentTokens(content);<br>            <span class="hljs-comment">// 如果是注释，或者没内容，跳过</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.inComment || !StringUtils.hasText(content)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// &lt;1&gt; 包含 DOCTYPE 为 DTD 模式</span><br>            <span class="hljs-comment">//如下</span><br>            <span class="hljs-keyword">if</span> (hasDoctype(content)) &#123;<br>                isDtdValidated = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// &lt;2&gt;hasOpeningTag方法会校验，如果这一行有&lt;，并且&lt;后面跟着的是字母，则返回 true 。</span><br>            <span class="hljs-comment">//如下</span><br>            <span class="hljs-keyword">if</span> (hasOpeningTag(content)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);<br>    &#125;<br>    <span class="hljs-comment">//如果发生 CharConversionException 异常，则为 VALIDATION_AUTO 模式。</span><br>    <span class="hljs-keyword">catch</span> (CharConversionException ex) &#123;<br>        <span class="hljs-keyword">return</span> VALIDATION_AUTO;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DOCTYPE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DOCTYPE&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasDoctype</span><span class="hljs-params">(String content)</span> &#123;<br>    <span class="hljs-keyword">return</span> content.contains(DOCTYPE);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasOpeningTag</span><span class="hljs-params">(String content)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.inComment) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">openTagIndex</span> <span class="hljs-operator">=</span> content.indexOf(<span class="hljs-string">&#x27;&lt;&#x27;</span>);<br>    <span class="hljs-keyword">return</span> (openTagIndex &gt; -<span class="hljs-number">1</span> &amp;&amp; (content.length() &gt; openTagIndex + <span class="hljs-number">1</span>) &amp;&amp;<br>            Character.isLetter(content.charAt(openTagIndex + <span class="hljs-number">1</span>)));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十五、装载BeanDefinition总结</title>
    <link href="/2022/06/11/%E8%A3%85%E8%BD%BDBeanDefinition%E6%80%BB%E7%BB%93/"/>
    <url>/2022/06/11/%E8%A3%85%E8%BD%BDBeanDefinition%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">装载BeanDefinition总结</font></div><p>该篇是对前边十几篇的总结。</p><p>IOC容器初始化的过程：<strong>Resource定位</strong>、<strong>BeanDefinition的装载和解析</strong>、<strong>BeanDefinition注册</strong>。</p><p><strong>Resource定位</strong>：一般使用外部资源描述<code>bean</code>对象，所以初始化IOC容器第一步需要定位这个外部资源（统一资源加载策略）。</p><p><strong>BeanDefinition的装载和解析</strong>：装载就是BeanDefinition的载入，通过BeanDefinitionReader读取、解析Resource资源，也就是将用户定义的Bean表示成IOC容器内部的数据结构–BeanDefinition。</p><blockquote><p>注：1.IOC容器内部维护着一个BeanDefinitionMap的数据结构。</p><p>​        2.配置文件中的每一个<bean>都对应着一个BeanDefinition对象。</p></blockquote><p><strong>BeanDefinition注册</strong>：向IOC容器内部维护的BeanDefinitionMap中注册第二步解析好的BeanDefinition对象，该过程通过BeanDefinitionRegistry接口实现。</p><blockquote><p>注：1.该过程并没有完成依赖注入（Bean创建），Bean创建发生在第一次调用<code>getBean()</code>方法，向容器索取             Bean时，因为默认是懒加载。</p><p>​        2.可以修改加载方式，即设置某个Bean的<code>lazyinit=false</code>，那么这个Bean的依赖注入会在IOC容器初始化的时候完成。</p></blockquote><p>在初始阶段，做过一个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//①获取资源</span><br><span class="hljs-type">ClassPathResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;bean.xml&quot;</span>);<br><span class="hljs-comment">//②获取 BeanFactory</span><br><span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultListableBeanFactory</span>();<br><span class="hljs-comment">//③根据新建的 BeanFactory 创建一个 BeanDefinitionReader 对象，该 Reader 对象为资源的解析器</span><br><span class="hljs-type">XmlBeanDefinitionReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanDefinitionReader</span>(factory);<br><span class="hljs-comment">//④装载资源</span><br>reader.loadBeanDefinitions(resource);<br></code></pre></td></tr></table></figure><p><strong>①</strong>：根据 Xml 配置文件创建 Resource 资源对象。ClassPathResource 是 Resource 接口的子类，bean.xml 文件中的内容是我们定义的 Bean 信息。</p><p><strong>②</strong>：创建一个 BeanFactory 。DefaultListableBeanFactory 是 BeanFactory 的一个子类，BeanFactory 作为一个接口，其实它本身是不具有独立使用的功能的，而 DefaultListableBeanFactory 则是真正可以独立使用的 IoC 容器，它是整个 Spring IoC 的始祖。</p><p><strong>③</strong>：创建 XmlBeanDefinitionReader 读取器，用于载入和解析 BeanDefinition 。</p><p><strong>④</strong>：开始 BeanDefinition 的载入和注册进程，完成后的 BeanDefinition 放置在 IoC 容器中。</p><h4 id="Resource定位"><a href="#Resource定位" class="headerlink" title="Resource定位"></a><code>Resource</code>定位</h4><p>Spring为了解决资源定位问题，提供了两个接口：<strong>Resource</strong>、<strong>ResourceLoader</strong>。</p><blockquote><p>Resource：Spring 统一资源的抽象接口。</p><p>ResourceLoader：Spring 资源加载的统一抽象。</p></blockquote><p>Resource 资源的定位需要 Resource 和 ResourceLoader 两个接口互相配合，在上面那段代码中 <code>new ClassPathResource(&quot;bean.xml&quot;)</code> 为我们定义了Resource，那么 ResourceLoader 则是在什么时候初始化的呢？看 XmlBeanDefinitionReader 构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// XmlBeanDefinitionReader.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">XmlBeanDefinitionReader</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> &#123;<br><span class="hljs-built_in">super</span>(registry);<br>&#125;<br><span class="hljs-comment">//第③步执行了XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);</span><br><span class="hljs-comment">//注：DefaultListableBeanFactory是BeanDefinitionRegistry的子类。</span><br></code></pre></td></tr></table></figure><p>直接调用父类 AbstractBeanDefinitionReader 构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractBeanDefinitionReader</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> &#123;<br>    Assert.notNull(registry, <span class="hljs-string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);<br>    <span class="hljs-built_in">this</span>.registry = registry;<br><br>    <span class="hljs-comment">// 如果设置了 ResourceLoader 则用设置的，否则使用 PathMatchingResourcePatternResolver</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.registry <span class="hljs-keyword">instanceof</span> ResourceLoader) &#123;<br>        <span class="hljs-built_in">this</span>.resourceLoader = (ResourceLoader) <span class="hljs-built_in">this</span>.registry;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.resourceLoader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathMatchingResourcePatternResolver</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Inherit Environment if possible</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.registry <span class="hljs-keyword">instanceof</span> EnvironmentCapable) &#123;<br>        <span class="hljs-built_in">this</span>.environment = ((EnvironmentCapable) <span class="hljs-built_in">this</span>.registry).getEnvironment();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.environment = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardEnvironment</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BeanDefinition的装载和解析"><a href="#BeanDefinition的装载和解析" class="headerlink" title="BeanDefinition的装载和解析"></a><code>BeanDefinition</code>的装载和解析</h4><p>第④步<code>reader.loadBeanDefinitions(resource);</code>开始BeanDefinition的解析过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//XmlBeanDefinitionReader.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    <span class="hljs-keyword">return</span> loadBeanDefinitions(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EncodedResource</span>(resource));<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法会将资源 Resource 包装成一个 <code>EncodedResource</code>实例对象，然后调用 <code>loadBeanDefinitions(EncodedResource encodedResource)</code> 方法。而将 Resource 封装成 EncodedResource 主要是为了对 Resource 进行<strong>编码</strong>，保证内容读取的正确性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// XmlBeanDefinitionReader.java</span><br><span class="hljs-comment">// 具体过程查看之前的文章</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(EncodedResource encodedResource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br><span class="hljs-comment">// ... 省略一些代码</span><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 将资源文件转为 InputStream 的 IO 流</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> encodedResource.getResource().getInputStream();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 从 InputStream 中得到 XML 的解析源</span><br><span class="hljs-type">InputSource</span> <span class="hljs-variable">inputSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(inputStream);<br><span class="hljs-keyword">if</span> (encodedResource.getEncoding() != <span class="hljs-literal">null</span>) &#123;<br>inputSource.setEncoding(encodedResource.getEncoding());<br>&#125;<br><span class="hljs-comment">// 核心逻辑部分，执行加载 BeanDefinition</span><br><span class="hljs-keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>inputStream.close();<br>&#125;<br>&#125;<br><span class="hljs-comment">// 省略一些代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从 <code>encodedResource</code> 源中获取 xml 的解析源，然后调用 <code>doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code> 方法，执行具体的解析过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// XmlBeanDefinitionReader.java</span><br><span class="hljs-comment">// 具体过程查看之前的文章</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doLoadBeanDefinitions</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span><br><span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 获取 XML Document 实例</span><br><span class="hljs-type">Document</span> <span class="hljs-variable">doc</span> <span class="hljs-operator">=</span> doLoadDocument(inputSource, resource);<br><span class="hljs-comment">// 根据 Document 实例，注册 BeanDefinition 信息</span><br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> registerBeanDefinitions(doc, resource);<br><span class="hljs-keyword">return</span> count;<br>&#125;<br><span class="hljs-comment">// ... 省略一堆配置</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在该方法中主要做两件事：</p><p>1、调用<code>doLoadDocument(inputSource, resource)</code>根据 xml 解析源获取相应的 Document 对象。</p><p>2、调用 <code>registerBeanDefinitions(Document doc, Resource resource)</code> 方法，开启 BeanDefinition 的解析注册过程。</p><h5 id="获取相应的Document对象"><a href="#获取相应的Document对象" class="headerlink" title="获取相应的Document对象"></a>获取相应的<code>Document</code>对象</h5><p>调用<code>doLoadDocument(inputSource, resource)</code>根据 xml 解析源获取相应的 Document 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Document <span class="hljs-title function_">doLoadDocument</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="hljs-built_in">this</span>.errorHandler,getValidationModeForResource(resource), isNamespaceAware());<br>&#125;<br></code></pre></td></tr></table></figure><p>五个参数：</p><p>1、InputSource：加载 Document 的 Resource 源。</p><p>2、EntityResolver：解析文件的解析器，重点，前边已经分析</p><p>3、ErrorHandler：处理加载 Document 对象的过程的错误。</p><p>4、validationMode：验证模式，重点，前边已经分析，默认自动获取，值为VALIDATION_AUTO，1。</p><p>5、namespaceAware：命名空间支持。如果要提供对 XML 名称空间的支持，则为 <code>true</code> ，默认false。</p><p><code>loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware)</code> 方法，在类 DefaultDocumentLoader 中提供了实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultDocumentLoader.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Document <span class="hljs-title function_">loadDocument</span><span class="hljs-params">(InputSource inputSource, EntityResolver entityResolver,</span><br><span class="hljs-params">ErrorHandler errorHandler, <span class="hljs-type">int</span> validationMode, <span class="hljs-type">boolean</span> namespaceAware)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">// 创建 DocumentBuilderFactory</span><br><span class="hljs-type">DocumentBuilderFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> createDocumentBuilderFactory(validationMode, namespaceAware);<br><span class="hljs-comment">// 创建 DocumentBuilder</span><br><span class="hljs-type">DocumentBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> createDocumentBuilder(factory, entityResolver, errorHandler);<br><span class="hljs-comment">// 解析 XML InputSource 返回 Document 对象</span><br><span class="hljs-keyword">return</span> builder.parse(inputSource);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="解析注册BeanDefinition信息"><a href="#解析注册BeanDefinition信息" class="headerlink" title="解析注册BeanDefinition信息"></a>解析注册<code>BeanDefinition</code>信息</h5><p>根据上个步骤转换的Document实例，解析注册 BeanDefinition 信息，该过程调用<code>registerBeanDefinitions(doc, resource);</code>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// XmlBeanDefinitionReader.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(Document doc, Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br><span class="hljs-comment">// 创建 BeanDefinitionDocumentReader 对象</span><br><span class="hljs-type">BeanDefinitionDocumentReader</span> <span class="hljs-variable">documentReader</span> <span class="hljs-operator">=</span> createBeanDefinitionDocumentReader();<br><span class="hljs-comment">// 获取已注册的 BeanDefinition 数量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">countBefore</span> <span class="hljs-operator">=</span> getRegistry().getBeanDefinitionCount();<br><span class="hljs-comment">// 创建 XmlReaderContext 对象</span><br><span class="hljs-comment">// 注册 BeanDefinition</span><br>documentReader.registerBeanDefinitions(doc, createReaderContext(resource));<br><span class="hljs-comment">// 计算新注册的 BeanDefinition 数量</span><br><span class="hljs-keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、首先，创建 BeanDefinition 的解析器 BeanDefinitionDocumentReader 。<br>2、然后，调用该 BeanDefinitionDocumentReader 的 <code>registerBeanDefinitions(Document doc, XmlReaderContext readerContext) </code>方法，开启解析过程，这里使用的是<strong>委派模式</strong>，具体的实现由子类 DefaultBeanDefinitionDocumentReader 完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultBeanDefinitionDocumentReader.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(Document doc, XmlReaderContext readerContext)</span> &#123;<br>    <span class="hljs-built_in">this</span>.readerContext = readerContext;<br>    <span class="hljs-comment">// 获得 XML Document Root Element</span><br>    <span class="hljs-comment">// 执行注册 BeanDefinition</span><br>    doRegisterBeanDefinitions(doc.getDocumentElement());<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="对Document对象进行解析"><a href="#对Document对象进行解析" class="headerlink" title="对Document对象进行解析"></a>对<code>Document</code>对象进行解析</h6><p>从 Document 对象中获取<strong>根元素 root</strong>，然后调用 &#96;&#96;doRegisterBeanDefinitions(Element root)&#96; 方法，开启真正的解析过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultBeanDefinitionDocumentReader.java</span><br><span class="hljs-comment">//前边文章有分析</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegisterBeanDefinitions</span><span class="hljs-params">(Element root)</span> &#123;<br>    <span class="hljs-comment">// ... 省略部分代码（非核心）</span><br>    <span class="hljs-built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);<br>    <span class="hljs-comment">// 解析前处理</span><br>    preProcessXml(root);<br>    <span class="hljs-comment">// 解析</span><br>    parseBeanDefinitions(root, <span class="hljs-built_in">this</span>.delegate);<br>    <span class="hljs-comment">// 解析后处理</span><br>    postProcessXml(root);<br>&#125;<br></code></pre></td></tr></table></figure><p>注：<code>preProcessXml(Element root)</code>、#po<code>stProcessXml(Element root) </code>为前置、后置增强处理，目前 Spring 中都是空实现。</p><p><code>parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)</code> 是对根元素 root 的解析注册过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultBeanDefinitionDocumentReader.java</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseBeanDefinitions</span><span class="hljs-params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;<br>    <span class="hljs-comment">// 如果根节点使用默认命名空间，执行默认解析</span><br>    <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;<br>        <span class="hljs-comment">// 遍历子节点</span><br>        <span class="hljs-type">NodeList</span> <span class="hljs-variable">nl</span> <span class="hljs-operator">=</span> root.getChildNodes();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nl.item(i);<br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Element) &#123;<br>                <span class="hljs-type">Element</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> (Element) node;<br>                <span class="hljs-comment">// 如果该节点使用默认命名空间，执行默认解析</span><br>                <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;<br>                    parseDefaultElement(ele, delegate);<br>                <span class="hljs-comment">// 如果该节点非默认命名空间，执行自定义解析</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    delegate.parseCustomElement(ele);<br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">// 如果根节点非默认命名空间，执行自定义解析</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        delegate.parseCustomElement(root);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代 root 元素的所有子节点，对其进行判断：</p><p>1、若节点为默认命名空间，则调用 <code>parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate)</code> 方法，开启默认标签的解析注册过程。</p><p>2、否则，调用 <code>BeanDefinitionParserDelegate.parseCustomElement(Element ele)</code> 方法，开启自定义标签的解析注册过程。</p><p>两个过程前边都有介绍。</p><p><strong>对默认标签的解析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultBeanDefinitionDocumentReader.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseDefaultElement</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;<br><span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; <span class="hljs-comment">// import</span><br>importBeanDefinitionResource(ele);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; <span class="hljs-comment">// alias</span><br>processAliasRegistration(ele);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; <span class="hljs-comment">// bean</span><br>processBeanDefinition(ele, delegate);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; <span class="hljs-comment">// beans</span><br><span class="hljs-comment">// recurse</span><br>doRegisterBeanDefinitions(ele);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对四大标签：<code>&lt;import&gt;</code>、<code>&lt;alias&gt;</code>、<code>&lt;bean&gt;</code>、<code>&lt;beans&gt;</code> 进行解析。<strong>其中 <code>&lt;bean&gt;</code> 标签的解析为核心工作，解析为BeanDefinition</strong>。</p><p><strong>对自定义标签的解析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// BeanDefinitionParserDelegate.java</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title function_">parseCustomElement</span><span class="hljs-params">(Element ele)</span> &#123;<br>    <span class="hljs-keyword">return</span> parseCustomElement(ele, <span class="hljs-literal">null</span>);<br>&#125;<br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title function_">parseCustomElement</span><span class="hljs-params">(Element ele, <span class="hljs-meta">@Nullable</span> BeanDefinition containingBd)</span> &#123;<br>    <span class="hljs-comment">// 获取 namespaceUri</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">namespaceUri</span> <span class="hljs-operator">=</span> getNamespaceURI(ele);<br>    <span class="hljs-keyword">if</span> (namespaceUri == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 根据 namespaceUri 获取相应的 Handler</span><br>    <span class="hljs-type">NamespaceHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);<br>    <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>        error(<span class="hljs-string">&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot;</span> + namespaceUri + <span class="hljs-string">&quot;]&quot;</span>, ele);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 调用自定义的 Handler 处理</span><br>    <span class="hljs-keyword">return</span> handler.parse(ele, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParserContext</span>(<span class="hljs-built_in">this</span>.readerContext, <span class="hljs-built_in">this</span>, containingBd));<br>&#125;<br></code></pre></td></tr></table></figure><p>获取节点的 <code>namespaceUri</code>，然后根据该 <code>namespaceUri</code> 获取相对应的 NamespaceHandler，最后调用 NamespaceHandler 的 <code>parse(Element element, ParserContext parserContext)</code> 方法，即完成自定义标签的解析和注入。</p><h6 id="注册BeanDefinition"><a href="#注册BeanDefinition" class="headerlink" title="注册BeanDefinition"></a>注册<code>BeanDefinition</code></h6><p>将 Document 对象里面的 Bean 标签解析成了一个个的 BeanDefinition 后，下一步则是将这些 BeanDefinition 注册到 IoC 容器中。动作的触发是在解析 Bean 标签完成后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultBeanDefinitionDocumentReader.java</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processBeanDefinition</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;<br>    <span class="hljs-comment">// 进行 bean 元素解析。</span><br>    <span class="hljs-comment">// 如果解析成功，则返回 BeanDefinitionHolder 对象。而 BeanDefinitionHolder 为 name 和 alias 的 BeanDefinition 对象</span><br>    <span class="hljs-comment">// 如果解析失败，则返回 null 。</span><br>    <span class="hljs-type">BeanDefinitionHolder</span> <span class="hljs-variable">bdHolder</span> <span class="hljs-operator">=</span> delegate.parseBeanDefinitionElement(ele);<br>    <span class="hljs-keyword">if</span> (bdHolder != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 进行自定义标签处理</span><br>        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 进行 BeanDefinition 的注册</span><br>            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());<br>        &#125; <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;<br>            getReaderContext().error(<span class="hljs-string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +<br>                    bdHolder.getBeanName() + <span class="hljs-string">&quot;&#x27;&quot;</span>, ele, ex);<br>        &#125;<br>        <span class="hljs-comment">// 发出响应事件，通知相关的监听器，已完成该 Bean 标签的解析。</span><br>        <span class="hljs-comment">// Send registration event.</span><br>        getReaderContext().fireComponentRegistered(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComponentDefinition</span>(bdHolder));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 <code>BeanDefinitionReaderUtils.registerBeanDefinition()</code> 方法来注册。其实，这里面也是调用 BeanDefinitionRegistry 的 <code>.registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</code> 方法，来注册 BeanDefinition 。不过，最终的实现是在 DefaultListableBeanFactory 中实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultListableBeanFactory.java</span><br><span class="hljs-comment">// 所谓注册，就是添加到了一个Map集合，key是beanName，value是BeanDefinition对象。</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span><br>        <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    <span class="hljs-comment">// ...省略校验相关的代码</span><br>    <span class="hljs-comment">// 从缓存中获取指定 beanName 的 BeanDefinition</span><br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">existingDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.beanDefinitionMap.get(beanName);<br>    <span class="hljs-comment">// 如果已经存在</span><br>    <span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果存在但是不允许覆盖，抛出异常</span><br>        <span class="hljs-keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;<br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionOverrideException</span>(beanName, beanDefinition, existingDefinition);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-comment">// ...省略 logger 打印日志相关的代码</span><br>        &#125;<br>        <span class="hljs-comment">// 【重点】允许覆盖，直接覆盖原有的 BeanDefinition 到 beanDefinitionMap 中。</span><br>        <span class="hljs-built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<br>    <span class="hljs-comment">// 如果未存在</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// ... 省略非核心的代码</span><br>        <span class="hljs-comment">// 【重点】添加到 BeanDefinition 到 beanDefinitionMap 中。</span><br>        <span class="hljs-built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<br>    &#125;<br>    <span class="hljs-comment">// 重新设置 beanName 对应的缓存</span><br>    <span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-literal">null</span> || containsSingleton(beanName)) &#123;<br>        resetBeanDefinition(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>现在 IoC 容器中已经建立了整个 Bean 的配置信息，这些 Bean 可以被检索、使用、维护，他们是控制反转的基础，是后面注入 Bean 的依赖。</p><p>流程图：</p><p><img src="/images/spring_IOC/IOC%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt="IOC容器初始化流程"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二、spring统一资源加载策略</title>
    <link href="/2022/06/11/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5/"/>
    <url>/2022/06/11/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">spring统一资源加载策略</font></div><blockquote><table><tr><td bgcolor="#6495ED"><font color="#FFF">org.springframework.core.io.Resource 为 Spring 框架所有资源的抽象和访问接口，它继承 org.springframework.core.io.InputStreamSource接口。作为所有资源的统一抽象，Source 定义了一些通用的方法，由子类 AbstractResource 提供统一的默认实现。</font></td></tr></table></blockquote><h4 id="统一资源：Resource"><a href="#统一资源：Resource" class="headerlink" title="统一资源：Resource"></a>统一资源：Resource</h4><p><code>org.springframework.core.io.Resource</code>为Spring所有资源的抽象和访问接口，继承自<code>org.springframework.core.io.InputStreamSource</code>，<code>Resource</code>定义的统一方法由其子类<code>AbstractResource</code>提供默认实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Resource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStreamSource</span> &#123;<br>    <span class="hljs-comment">//资源是否存在</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">exists</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//资源是否可读</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReadable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//资源所代表的句柄是否被一个stream打开了</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOpen</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//是否为 File</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFile</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//返回资源的URL的句柄</span><br>    URL <span class="hljs-title function_">getURL</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br>    <span class="hljs-comment">//返回资源的URI的句柄</span><br>    URI <span class="hljs-title function_">getURI</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br>    <span class="hljs-comment">//返回资源的File的句柄</span><br>    File <span class="hljs-title function_">getFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br>    <span class="hljs-comment">//返回 ReadableByteChannel</span><br>    <span class="hljs-keyword">default</span> ReadableByteChannel <span class="hljs-title function_">readableChannel</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> Channels.newChannel(getInputStream());<br>    &#125;<br>    <span class="hljs-comment">//资源内容的长度</span><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">contentLength</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br>    <span class="hljs-comment">//资源最后的修改时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">lastModified</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br>    <span class="hljs-comment">//根据资源的相对路径创建新资源</span><br>    Resource <span class="hljs-title function_">createRelative</span><span class="hljs-params">(String relativePath)</span> <span class="hljs-keyword">throws</span> IOException;<br>    <span class="hljs-comment">//资源的文件名</span><br>    <span class="hljs-meta">@Nullable</span><br>    String <span class="hljs-title function_">getFilename</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//资源的描述</span><br>    String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/spring_IOC/Resource.png" alt="Resource"></p><ol><li>FileSystemResource：对 <code>java.io.File</code> 类型资源的封装，只要是跟 File 打交道的，基本上与 FileSystemResource 也可以打交道。支持文件和 URL 的形式，实现 WritableResource 接口。</li><li>ByteArrayResource：对字节数组提供的数据的封装。如果通过 InputStream 形式访问该类型的资源，该实现会根据字节数组的数据构造一个相应的 ByteArrayInputStream。</li><li>UrlResource：对 <code>java.net.URL</code>类型资源的封装。内部委派 URL 进行具体的资源操作。</li><li>ClassPathResource：class path 类型资源的实现。使用给定的 ClassLoader 或者给定的 Class 来加载资源。</li><li>InputStreamResource：将给定的 InputStream 作为一种资源的 Resource 的实现类。</li></ol><p><code>AbstractResource </code>为 Resource 接口的默认实现，它实现了 Resource 接口的大部分的公共实现。</p><p>如果想要实现自定义的 Resource，记住不要实现 Resource 接口，而应该继承 AbstractResource 抽象类，然后根据当前的具体资源特性覆盖相应的方法即可。</p><h4 id="统一资源定位：ResourceLoader"><a href="#统一资源定位：ResourceLoader" class="headerlink" title="统一资源定位：ResourceLoader"></a>统一资源定位：ResourceLoader</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p><code>org.springframework.core.io.ResourceLoader</code> 为 Spring 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成，所以我们可以将 ResourceLoader 称作为统一资源定位器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ResourceLoader</span> &#123;<br>    <span class="hljs-comment">//只定义了两个方法</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">CLASSPATH_URL_PREFIX</span> <span class="hljs-operator">=</span> ResourceUtils.CLASSPATH_URL_PREFIX;<span class="hljs-comment">//ResourceUtils.CLASSPATH_URL_PREFIX=&quot;classpath:&quot;</span><br>    Resource <span class="hljs-title function_">getResource</span><span class="hljs-params">(String var1)</span>;<br>    ClassLoader <span class="hljs-title function_">getClassLoader</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getResource</code>根据所提供资源的路径 location 返回 Resource 实例，但是它不确保该 Resource 一定存在，需要调用 <code>Resource.exist()</code>方法判断。该方法的主要实现是在其子类 DefaultResourceLoader 中实现，支持以下模式的资源加载：</p><ol><li>URL位置资源，如”file:C:&#x2F;test.dat”。</li><li>ClassPath位置资源，如”classpath:test.dat”。</li><li>相对路径资源，如”WEB-INF&#x2F;test.dat”，此时返回的Resource实例根据实现不同而不同。</li></ol><p><code>getClassLoader</code> 返回 ClassLoader 实例，对于想要获取 ResourceLoader 使用的 ClassLoader 用户来说，可以直接调用该方法来获取。</p><p><img src="/images/spring_IOC/ResourceLoader.png" alt="ResourceLoader"></p><h5 id="DefaultResourceLoader"><a href="#DefaultResourceLoader" class="headerlink" title="DefaultResourceLoader"></a>DefaultResourceLoader</h5><p><code>org.springframework.core.io.DefaultResourceLoader</code> 是 ResourceLoader 的默认实现。</p><h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 在访问资源时，使用当前线程的，一般 Thread.currentThread().getContextClassLoader()</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultResourceLoader</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultResourceLoader</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> &#123;<br>    <span class="hljs-built_in">this</span>.classLoader = classLoader;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，后续也可以使用<code>setClassLoader</code>进行设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setClassLoader</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> &#123;<br>    <span class="hljs-built_in">this</span>.classLoader = classLoader;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="getResource-方法"><a href="#getResource-方法" class="headerlink" title="getResource()方法"></a>getResource()方法</h6><p>ResourceLoader 中最核心的方法为<code>public Resource getResource(String location)</code>，<code>DefaultResourceLoader</code>提供了具体实现，他的两个子类并未覆盖此方法，所以ResourceLoader的资源加载策略就封装在 DefaultResourceLoader 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Resource <span class="hljs-title function_">getResource</span><span class="hljs-params">(String location)</span> &#123;<br>    Assert.notNull(location, <span class="hljs-string">&quot;Location must not be null&quot;</span>);<br><br>    <span class="hljs-comment">// 首先，通过 ProtocolResolver 来加载资源</span><br>    <span class="hljs-keyword">for</span> (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123;<br>        <span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> protocolResolver.resolve(location, <span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (resource != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> resource;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//以 / 开头，返回 ClassPathContextResource 类型的资源</span><br>    <span class="hljs-keyword">if</span> (location.startsWith(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> getResourceByPath(location);<br>    &#125;<br>    <span class="hljs-comment">//以 classpath: 开头，返回 ClassPathResource 类型的资源</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());<br>    &#125;<br>    <span class="hljs-comment">//根据是否为文件 URL ，是则返回 FileUrlResource 类型的资源，否则返回 UrlResource 类型的资源</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Try to parse the location as a URL...</span><br>            <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(location);<br>            <span class="hljs-keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileUrlResource</span>(url) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlResource</span>(url));<br>        &#125;<br>        <span class="hljs-comment">//格式错误异常</span><br>        <span class="hljs-keyword">catch</span> (MalformedURLException ex) &#123;<br>            <span class="hljs-comment">// 返回 ClassPathContextResource 类型的资源</span><br>            <span class="hljs-comment">// No URL -&gt; resolve as resource path.</span><br>            <span class="hljs-keyword">return</span> getResourceByPath(location);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>首先，通过 ProtocolResolver 来加载资源，成功返回 <strong>Resource</strong> 。</p></li><li><p>否则，若 <code>location</code> 以 <code>&quot;/&quot;</code> 开头，则调用 <code>#getResourceByPath()</code> 方法，构造 <strong>ClassPathContextResource</strong> 类型资源并返回。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">protected Resource get<span class="hljs-constructor">ResourceByPath(String <span class="hljs-params">path</span>)</span> &#123;<br>return <span class="hljs-keyword">new</span> <span class="hljs-constructor">ClassPathContextResource(<span class="hljs-params">path</span>, <span class="hljs-params">getClassLoader</span>()</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>再否则，若 <code>location</code> 以 <code>&quot;classpath:&quot;</code> 开头，则构造 <strong>ClassPathResource</strong> 类型资源并返回。在构造该资源时，通过 <code>#getClassLoader()</code> 获取当前的 ClassLoader。</p></li><li><p>再否则，构造 URL ，尝试通过它进行资源定位，若没有抛出 <strong>MalformedURLException</strong> 异常，则判断是否为 FileURL , 如果是则构造 <strong>FileUrlResource</strong> 类型的资源，否则构造 <strong>UrlResource</strong> 类型的资源。</p></li><li><p>最后，若在加载过程中抛出 MalformedURLException 异常，则委派 <code>#getResourceByPath()</code> 方法，实现资源定位加载。该过程和第二步 <code>location</code> 以 <code>&quot;/&quot;</code> 开头相同。</p></li></ul><p><strong>其子类可以通过重写getResourceByPath(String path)来返回和自身相关的资源类型</strong>。</p><h6 id="ProtocolResolver"><a href="#ProtocolResolver" class="headerlink" title="ProtocolResolver"></a>ProtocolResolver</h6><p><code>org.springframework.core.io.ProtocolResolver</code>（是个函数式接口），用户自定义协议资源解决策略，如上介绍Resource所说：如果想要实现自定义的 Resource，应该继承 AbstractResource 抽象类，但是有了 ProtocolResolver 后，不需要直接继承 DefaultResourceLoader，改为实现 ProtocolResolver 接口也可以实现自定义的 ResourceLoader。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProtocolResolver</span> &#123;<br>    <span class="hljs-comment">//需要用户自定义实现</span><br><span class="hljs-meta">@Nullable</span><br>Resource <span class="hljs-title function_">resolve</span><span class="hljs-params">(String location, ResourceLoader resourceLoader)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>自定义的resolve添加到spring中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在此资源加载器中注册给定的解析器，从而允许处理其他协议，它也可以覆盖任何默认规则。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addProtocolResolver</span><span class="hljs-params">(ProtocolResolver resolver)</span> &#123;<br>    Assert.notNull(resolver, <span class="hljs-string">&quot;ProtocolResolver must not be null&quot;</span>);<br>    <span class="hljs-built_in">this</span>.protocolResolvers.add(resolver);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="FileSystemResourceLoader"><a href="#FileSystemResourceLoader" class="headerlink" title="FileSystemResourceLoader"></a>FileSystemResourceLoader</h5><p><code>org.springframework.core.io.FileSystemResourceLoader</code>重写了<code>getResourceByPath</code>，使之从文件系统加载资源并以 FileSystemResource 类型返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Resource <span class="hljs-title function_">getResourceByPath</span><span class="hljs-params">(String path)</span> &#123;<br>    <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>        path = path.substring(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//创建 FileSystemContextResource 类型的资源，FileSystemContextResource为内部类。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSystemContextResource</span>(path);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="FileSystemContextResource"><a href="#FileSystemContextResource" class="headerlink" title="FileSystemContextResource"></a>FileSystemContextResource</h6><p>为 FileSystemResourceLoader 的内部类，它继承 FileSystemResource 类，实现 ContextResource 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystemContextResource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FileSystemResource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ContextResource</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileSystemContextResource</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-built_in">super</span>(path);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPathWithinContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getPath();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="ClassRelativeResourceLoader"><a href="#ClassRelativeResourceLoader" class="headerlink" title="ClassRelativeResourceLoader"></a>ClassRelativeResourceLoader</h5><p><code>org.springframework.core.io.ClassRelativeResourceLoader</code>是DefaultResourceLoader的另一个子类，和<code>FileSystemResourceLoader</code>一样，都是重新写了getResourceByPath()方法，然后有个内部类<code>ClassRelativeContextResource</code>。</p><p>ClassRelativeResourceLoader扩展的功能是可以根据给定的class所在包或者所在包的子包下加载资源。</p><h5 id="ResourcePatternResolver"><a href="#ResourcePatternResolver" class="headerlink" title="ResourcePatternResolver"></a>ResourcePatternResolver</h5><p>ResourceLoader 的 <code>Resource getResource(String location)</code> 方法，每次只能根据 location 返回<strong>一个</strong> Resource 。当需要加载多个资源时，我们除了多次调用 <code>getResource(String location)</code> 方法外，别无他法。<code>org.springframework.core.io.support.ResourcePatternResolver</code> 是 ResourceLoader 的扩展，它支持根据指定的资源路径匹配模式每次返回<strong>多个</strong> Resource 实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ResourcePatternResolver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceLoader</span> &#123;<br>    <span class="hljs-comment">//注：默认是&quot;classpath:&quot;;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">CLASSPATH_ALL_URL_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;classpath*:&quot;</span>;<br>Resource[] getResources(String locationPattern) <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ResourcePatternResolver</code>在<code>ResourceLoader</code>的基础上增加了<code>getResources</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注：父类是getResource</span><br>Resource[] getResources(String locationPattern) <span class="hljs-keyword">throws</span> IOException;<br></code></pre></td></tr></table></figure><h5 id="PathMatchingResourcePatternResolver"><a href="#PathMatchingResourcePatternResolver" class="headerlink" title="PathMatchingResourcePatternResolver"></a>PathMatchingResourcePatternResolver</h5><p>是<code>ResourcePatternResolver</code>的子类，在父类的基础上额外还支持 Ant 风格的路径匹配模式（类似于 <code>&quot;/*.xml&quot;</code>）。</p><h6 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h6><p>提供了三个构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//内置的 ResourceLoader 资源定位器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ResourceLoader resourceLoader;<br><br><span class="hljs-comment">//Ant 路径匹配器，默认为 AntPathMatcher 对象，用于支持 Ant 类型的路径匹配。</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">PathMatcher</span> <span class="hljs-variable">pathMatcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathMatcher</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">PathMatchingResourcePatternResolver</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.resourceLoader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultResourceLoader</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">PathMatchingResourcePatternResolver</span><span class="hljs-params">(ResourceLoader resourceLoader)</span> &#123;<br>    Assert.notNull(resourceLoader, <span class="hljs-string">&quot;ResourceLoader must not be null&quot;</span>);<br>    <span class="hljs-built_in">this</span>.resourceLoader = resourceLoader;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">PathMatchingResourcePatternResolver</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> &#123;<br>    <span class="hljs-built_in">this</span>.resourceLoader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultResourceLoader</span>(classLoader);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="getResource"><a href="#getResource" class="headerlink" title="getResource"></a>getResource</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Resource <span class="hljs-title function_">getResource</span><span class="hljs-params">(String location)</span> &#123;<br>    <span class="hljs-keyword">return</span> getResourceLoader().getResource(location);<br>&#125;<br><br><span class="hljs-keyword">public</span> ResourceLoader <span class="hljs-title function_">getResourceLoader</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.resourceLoader;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法，直接委托给相应的 ResourceLoader 来实现。如果我们在实例化的 PathMatchingResourcePatternResolver 的时候，如果未指定 ResourceLoader 参数的情况下，那么在加载资源时，其实就是 DefaultResourceLoader 的过程。</p><h6 id="getResources"><a href="#getResources" class="headerlink" title="getResources"></a>getResources</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Resource[] getResources(String locationPattern) <span class="hljs-keyword">throws</span> IOException &#123;<br>    Assert.notNull(locationPattern, <span class="hljs-string">&quot;Location pattern must not be null&quot;</span>);<br>    <span class="hljs-comment">// 以 &quot;classpath*:&quot; 开头</span><br>    <span class="hljs-keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;<br>        <span class="hljs-comment">// 路径包含通配符</span><br>        <span class="hljs-comment">// a class path resource (multiple resources for same name possible)</span><br>        <span class="hljs-keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;<br>            <span class="hljs-comment">// a class path resource pattern</span><br>            <span class="hljs-keyword">return</span> findPathMatchingResources(locationPattern);<br>        &#125;<br>        <span class="hljs-comment">// 路径不包含通配符</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// all class path resources with the given name</span><br>            <span class="hljs-keyword">return</span> findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Generally only look for a pattern after a prefix here,</span><br>        <span class="hljs-comment">// and on Tomcat only after the &quot;*/&quot; separator for its &quot;war:&quot; protocol.</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">prefixEnd</span> <span class="hljs-operator">=</span> (locationPattern.startsWith(<span class="hljs-string">&quot;war:&quot;</span>) ? locationPattern.indexOf(<span class="hljs-string">&quot;*/&quot;</span>) + <span class="hljs-number">1</span> :<br>                         locationPattern.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 路径包含通配符</span><br>        <span class="hljs-keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;<br>            <span class="hljs-comment">// a file pattern</span><br>            <span class="hljs-keyword">return</span> findPathMatchingResources(locationPattern);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// a single resource with the given name</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>[] &#123;getResourceLoader().getResource(locationPattern)&#125;;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>非</strong> <code>&quot;classpath*:&quot;</code> 开头，且路径<strong>不包含</strong>通配符，直接委托给相应的 ResourceLoader 来实现。</li><li>其他情况，调用 <code>#findAllClassPathResources(...)</code>、或 <code>#findPathMatchingResources(...)</code> 方法，返回多个 Resource 。</li></ul><h6 id="findAllClassPathResources"><a href="#findAllClassPathResources" class="headerlink" title="findAllClassPathResources"></a>findAllClassPathResources</h6><p>当 <code>locationPattern</code> 以 <code>&quot;classpath*:&quot;</code> 开头但是不包含通配符，则调用 <code>findAllClassPathResources(...)</code> 方法加载资源。该方法返回 classes 路径下和所有 jar 包中的所有相匹配的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Resource[] findAllClassPathResources(String location) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> location;<br>    <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>        path = path.substring(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 真正执行加载所有 classpath 资源</span><br>    Set&lt;Resource&gt; result = doFindAllClassPathResources(path);<br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>        logger.trace(<span class="hljs-string">&quot;Resolved classpath location [&quot;</span> + location + <span class="hljs-string">&quot;] to resources &quot;</span> + result);<br>    &#125;<br>    <span class="hljs-comment">//转换成 Resource 数组返回</span><br>    <span class="hljs-keyword">return</span> result.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>[<span class="hljs-number">0</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>真正执行加载的是在 <code>doFindAllClassPathResources(...)</code> 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Set&lt;Resource&gt; <span class="hljs-title function_">doFindAllClassPathResources</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    Set&lt;Resource&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(<span class="hljs-number">16</span>);<br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> getClassLoader();<br>    <span class="hljs-comment">// &lt;1&gt; 根据 ClassLoader 加载路径下的所有资源</span><br>    Enumeration&lt;URL&gt; resourceUrls = (cl != <span class="hljs-literal">null</span> ? cl.getResources(path) : ClassLoader.getSystemResources(path));<br>    <span class="hljs-keyword">while</span> (resourceUrls.hasMoreElements()) &#123;<br>        <span class="hljs-comment">//&lt;2&gt; 将 URL 转换成 UrlResource</span><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> resourceUrls.nextElement();<br>        result.add(convertClassLoaderURL(url));<br>    &#125;<br>    <span class="hljs-comment">// &lt;3&gt; 加载路径下得所有 jar 包</span><br>    <span class="hljs-keyword">if</span> (!StringUtils.hasLength(path)) &#123;<br>        <span class="hljs-comment">// The above result is likely to be incomplete, i.e. only containing file system references.</span><br>        <span class="hljs-comment">// We need to have pointers to each of the jar files on the classpath as well...</span><br>        addAllClassLoaderJarRoots(cl, result);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>&lt;1&gt;处根据 ClassLoader 加载路径下的所有资源。在加载资源过程时，如果在构造 PathMatchingResourcePatternResolver 实例的时候如果传入了 ClassLoader，则调用该 ClassLoader 的 <code>getResources()</code> 方法，否则调用 <code>ClassLoader.getSystemResources(path)</code> 方法。另外，<code>ClassLoader.getResources()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Enumeration&lt;URL&gt; <span class="hljs-title function_">getResources</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    Objects.requireNonNull(name);<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enumeration</span>&lt;?&gt;[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>        tmp[<span class="hljs-number">0</span>] = parent.getResources(name);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        tmp[<span class="hljs-number">0</span>] = BootLoader.findResources(name);<br>    &#125;<br>    tmp[<span class="hljs-number">1</span>] = findResources(name);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompoundEnumeration</span>&lt;&gt;(tmp);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果当前父类加载器不为 <code>null</code> ，则通过父类向上迭代获取资源，否则调用<code>BootLoader.findResources(name);</code></p><p><code>&lt;2&gt;</code> 处，遍历 URL 集合，调用 <code>convertClassLoaderURL(URL url)</code> 方法，将 URL 转换成 UrlResource 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Resource <span class="hljs-title function_">convertClassLoaderURL</span><span class="hljs-params">(URL url)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlResource</span>(url);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&lt;3&gt;</code> 处，若 <code>path</code> 为空（<code>“”</code>）时，则调用 <code>addAllClassLoaderJarRoots(...)</code>方法。该方法主要是加载路径下得所有 jar 包。</p><p>由上可以看出，<code>#findAllClassPathResources(...)</code> 方法，其实就是利用 ClassLoader 来加载指定路径下的资源，不论它是在 class 路径下还是在 jar 包中。如果我们传入的路径为空或者 <code>/</code>，则会调用 <code>addAllClassLoaderJarRoots(...)</code> 方法，加载所有的 jar 包。</p><h6 id="findPathMatchingResources"><a href="#findPathMatchingResources" class="headerlink" title="findPathMatchingResources"></a>findPathMatchingResources</h6><p>当 <code>locationPattern</code> 中包含了<strong>通配符</strong>，则调用该方法进行资源加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Resource[] findPathMatchingResources(String locationPattern) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 确定根路径、子路径</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">rootDirPath</span> <span class="hljs-operator">=</span> determineRootDir(locationPattern);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">subPattern</span> <span class="hljs-operator">=</span> locationPattern.substring(rootDirPath.length());<br>    <span class="hljs-comment">// 获取根据路径下的资源</span><br>    Resource[] rootDirResources = getResources(rootDirPath);<br>    <span class="hljs-comment">// 遍历，迭代</span><br>    Set&lt;Resource&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(<span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">for</span> (Resource rootDirResource : rootDirResources) &#123;<br>        rootDirResource = resolveRootDirResource(rootDirResource);<br>        <span class="hljs-type">URL</span> <span class="hljs-variable">rootDirUrl</span> <span class="hljs-operator">=</span> rootDirResource.getURL();<br>        <span class="hljs-comment">// bundle 资源类型</span><br>        <span class="hljs-keyword">if</span> (equinoxResolveMethod != <span class="hljs-literal">null</span> &amp;&amp; rootDirUrl.getProtocol().startsWith(<span class="hljs-string">&quot;bundle&quot;</span>)) &#123;<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">resolvedUrl</span> <span class="hljs-operator">=</span> (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, <span class="hljs-literal">null</span>, rootDirUrl);<br>            <span class="hljs-keyword">if</span> (resolvedUrl != <span class="hljs-literal">null</span>) &#123;<br>                rootDirUrl = resolvedUrl;<br>            &#125;<br>            rootDirResource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlResource</span>(rootDirUrl);<br>        &#125;<br>        <span class="hljs-comment">// vfs 资源类型</span><br>        <span class="hljs-keyword">if</span> (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123;<br>            result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher()));<br>        &#125;<br>        <span class="hljs-comment">// jar 资源类型</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) &#123;<br>            result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern));<br>        &#125;<br>        <span class="hljs-comment">// 其它资源类型</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>        logger.trace(<span class="hljs-string">&quot;Resolved location pattern [&quot;</span> + locationPattern + <span class="hljs-string">&quot;] to resources &quot;</span> + result);<br>    &#125;<br>    <span class="hljs-comment">// 转换成 Resource 数组返回</span><br>    <span class="hljs-keyword">return</span> result.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>[<span class="hljs-number">0</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>确定目录，获取该目录下得所有资源。</li><li>在所获得的所有资源后，进行迭代匹配获取我们想要的资源。</li></ol><p>在这个方法里面，我们要关注两个方法，一个是 <code>#determineRootDir(String location)</code> 方法，一个是 <code>doFindPathMatchingXXXResources(...)</code> 等方法。</p><p><code>determineRootDir(String location)</code> 方法，主要是用于确定根路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> String <span class="hljs-title function_">determineRootDir</span><span class="hljs-params">(String location)</span> &#123;<br>    <span class="hljs-comment">// 找到冒号的后一位</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">prefixEnd</span> <span class="hljs-operator">=</span> location.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 根目录结束位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">rootDirEnd</span> <span class="hljs-operator">=</span> location.length();<br>    <span class="hljs-comment">// 在从冒号开始到最后的字符串中，循环判断是否包含通配符，如果包含，则截断最后一个由”/”分割的部分。</span><br>    <span class="hljs-comment">// 例如：在我们路径中，就是最后的ap?-context.xml这一段。再循环判断剩下的部分，直到剩下的路径中都不包含通配符。</span><br>    <span class="hljs-keyword">while</span> (rootDirEnd &gt; prefixEnd &amp;&amp; getPathMatcher().isPattern(location.substring(prefixEnd, rootDirEnd))) &#123;<br>        rootDirEnd = location.lastIndexOf(<span class="hljs-string">&#x27;/&#x27;</span>, rootDirEnd - <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果查找完成后，rootDirEnd = 0 了，则将之前赋值的 prefixEnd 的值赋给 rootDirEnd ，也就是冒号的后一位</span><br>    <span class="hljs-keyword">if</span> (rootDirEnd == <span class="hljs-number">0</span>) &#123;<br>        rootDirEnd = prefixEnd;<br>    &#125;<br>    <span class="hljs-comment">// 截取根目录</span><br>    <span class="hljs-keyword">return</span> location.substring(<span class="hljs-number">0</span>, rootDirEnd);<br>&#125;<br></code></pre></td></tr></table></figure><p>例：</p><table><thead><tr><th>原路径</th><th>确定根路径</th></tr></thead><tbody><tr><td>classpath*:test&#x2F;cc*&#x2F;spring-*.xml</td><td>classpath*:test&#x2F;</td></tr><tr><td>classpath*:test&#x2F;aa&#x2F;spring-*.xml</td><td>classpath*:test&#x2F;aa&#x2F;</td></tr></tbody></table><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Spring资源加载过程如下：</p><ul><li>Spring 提供了 Resource 和 ResourceLoader 来统一抽象整个资源及其定位。使得资源与资源的定位有了一个更加清晰的界限，并且提供了合适的 Default 类，使得自定义实现更加方便和清晰。</li><li>AbstractResource 为 Resource 的默认抽象实现，它对 Resource 接口做了一个统一的实现，子类继承该类后只需要覆盖相应的方法即可，同时对于自定义的 Resource 我们也是继承该类。</li><li>DefaultResourceLoader 同样也是 ResourceLoader 的默认实现，在自定 ResourceLoader 的时候我们除了可以继承该类外还可以实现 ProtocolResolver 接口来实现自定资源加载协议。</li><li>DefaultResourceLoader 每次只能返回单一的资源，所以 Spring 针对这个提供了另外一个接口 ResourcePatternResolver ，该接口提供了根据指定的 locationPattern 返回多个资源的策略。其子类 PathMatchingResourcePatternResolver 是一个集大成者的 ResourceLoader ，因为它即实现了 <code>Resource getResource(String location)</code> 方法，也实现了 <code>Resource[] getResources(String locationPattern)</code> 方法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五、获取Document对象</title>
    <link href="/2022/06/11/%E8%8E%B7%E5%8F%96Document%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/06/11/%E8%8E%B7%E5%8F%96Document%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">获取Document对象</font></div><p>在 <code>XmlBeanDefinitionReader#doLoadDocument(InputSource inputSource, Resource resource)</code> 方法，中做了两件事情：</p><ul><li>调用 <code>#getValidationModeForResource(Resource resource)</code> 方法，获取指定资源（xml）的<strong>验证模式</strong>。</li><li>调用 <code>DocumentLoader#loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware)</code> 方法，获取 XML Document 实例。</li></ul><h4 id="DocumentLoader"><a href="#DocumentLoader" class="headerlink" title="DocumentLoader"></a>DocumentLoader</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DocumentLoader</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> inputSource 要加载的文档来源</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> entityResolver 解析文件的解析器</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> errorHandler 处理加载Document对象过程中发生的错误</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> validationMode 验证模式</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> namespaceAware 如果要提供对 XML 名称空间的支持，则需要值为 true 。</span><br><span class="hljs-comment"> */</span><br>Document <span class="hljs-title function_">loadDocument</span><span class="hljs-params">(</span><br><span class="hljs-params">InputSource inputSource, EntityResolver entityResolver,</span><br><span class="hljs-params">ErrorHandler errorHandler, <span class="hljs-type">int</span> validationMode, <span class="hljs-type">boolean</span> namespaceAware)</span><br><span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="DefaultDocumentLoader"><a href="#DefaultDocumentLoader" class="headerlink" title="DefaultDocumentLoader"></a>DefaultDocumentLoader</h5><p>该类是DocumentLoader的默认实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Document <span class="hljs-title function_">loadDocument</span><span class="hljs-params">(InputSource inputSource, EntityResolver entityResolver,</span><br><span class="hljs-params"> ErrorHandler errorHandler, <span class="hljs-type">int</span> validationMode, <span class="hljs-type">boolean</span> namespaceAware)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// &lt;1&gt; 创建 DocumentBuilderFactory</span><br>    <span class="hljs-type">DocumentBuilderFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> createDocumentBuilderFactory(validationMode, namespaceAware);<br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>        logger.trace(<span class="hljs-string">&quot;Using JAXP provider [&quot;</span> + factory.getClass().getName() + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// &lt;2&gt; 创建 DocumentBuilder</span><br>    <span class="hljs-type">DocumentBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> createDocumentBuilder(factory, entityResolver, errorHandler);<br>    <span class="hljs-comment">// &lt;3&gt; 解析 XML InputSource 返回 Document 对象</span><br>    <span class="hljs-keyword">return</span> builder.parse(inputSource);<br>&#125;<br></code></pre></td></tr></table></figure><p>第一步：调用<code>createDocumentBuilderFactory()</code>创建<code>DocumentBuilderFactory</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SCHEMA_LANGUAGE_ATTRIBUTE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://java.sun.com/xml/jaxp/properties/schemaLanguage&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">XSD_SCHEMA_LANGUAGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>;<br><br><span class="hljs-keyword">protected</span> DocumentBuilderFactory <span class="hljs-title function_">createDocumentBuilderFactory</span><span class="hljs-params">(<span class="hljs-type">int</span> validationMode, <span class="hljs-type">boolean</span> namespaceAware)</span> <span class="hljs-keyword">throws</span> ParserConfigurationException &#123;<br>    <span class="hljs-type">DocumentBuilderFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> DocumentBuilderFactory.newInstance();<br>    <span class="hljs-comment">// 设置命名空间支持</span><br>    factory.setNamespaceAware(namespaceAware);<br>    <span class="hljs-keyword">if</span> (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123;<br>        <span class="hljs-comment">// 开启校验</span><br>        factory.setValidating(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// XSD 模式下，设置 factory 的属性</span><br>        <span class="hljs-keyword">if</span> (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123;<br>            <span class="hljs-comment">// XSD 模式下，强制设置命名空间支持</span><br>            factory.setNamespaceAware(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 设置 SCHEMA_LANGUAGE_ATTRIBUTE</span><br>                factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (IllegalArgumentException ex) &#123;<br>                <span class="hljs-type">ParserConfigurationException</span> <span class="hljs-variable">pcex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParserConfigurationException</span>(<br>                    <span class="hljs-string">&quot;Unable to validate using XSD: Your JAXP provider [&quot;</span> + factory +<br>                    <span class="hljs-string">&quot;] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? &quot;</span> +<br>                    <span class="hljs-string">&quot;Upgrade to Apache Xerces (or Java 1.5) for full XSD support.&quot;</span>);<br>                pcex.initCause(ex);<br>                <span class="hljs-keyword">throw</span> pcex;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> factory;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步：调用<code>createDocumentBuilder()</code>创建<code>DocumentBuilder</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> DocumentBuilder <span class="hljs-title function_">createDocumentBuilder</span><span class="hljs-params">(DocumentBuilderFactory factory,<span class="hljs-meta">@Nullable</span> EntityResolver entityResolver, <span class="hljs-meta">@Nullable</span> ErrorHandler errorHandler)</span><span class="hljs-keyword">throws</span> ParserConfigurationException &#123;<br>    <span class="hljs-comment">// 创建 DocumentBuilder 对象</span><br>    <span class="hljs-type">DocumentBuilder</span> <span class="hljs-variable">docBuilder</span> <span class="hljs-operator">=</span> factory.newDocumentBuilder();<br>    <span class="hljs-keyword">if</span> (entityResolver != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// &lt;x&gt; 设置 EntityResolver 属性</span><br>        docBuilder.setEntityResolver(entityResolver);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (errorHandler != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 设置 ErrorHandler 属性</span><br>        docBuilder.setErrorHandler(errorHandler);<br>    &#125;<br>    <span class="hljs-keyword">return</span> docBuilder;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置 DocumentBuilder 的 <strong>EntityResolver</strong> 属性。详解在<em><strong>EntityResolver</strong></em>段。</p><p>第三步：调用<code>DocumentBuilder#parse(InputSource)</code> 方法，解析 InputSource ，返回 Document 对象。</p><h4 id="EntityResolver"><a href="#EntityResolver" class="headerlink" title="EntityResolver"></a>EntityResolver</h4><p>在<code>XmlBeanDefinitionReader.doLoadDocument()</code>中通过 <code>DocumentLoader.loadDocument()</code> 方法来获取 Document 对象时，有一个方法参数 <code>entityResolver</code> 。该参数是通过 <code>XmlBeanDefinitionReader.getEntityResolver()</code> 方法来获取的。<strong>该类在于如何获取验证文件，从而验证用户写的 XML 是否通过验证。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> EntityResolver <span class="hljs-title function_">getEntityResolver</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.entityResolver == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Determine default EntityResolver to use.</span><br>        <span class="hljs-type">ResourceLoader</span> <span class="hljs-variable">resourceLoader</span> <span class="hljs-operator">=</span> getResourceLoader();<br>        <span class="hljs-keyword">if</span> (resourceLoader != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//如果 ResourceLoader不为null，则根据指定的ResourceLoader创建一个ResourceEntityResolver对象。</span><br>            <span class="hljs-built_in">this</span>.entityResolver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceEntityResolver</span>(resourceLoader);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果 ResourceLoader为null，则创建一个DelegatingEntityResolver对象。该Resolver委托给默认的BeansDtdResolver和PluggableSchemaResolver。</span><br>            <span class="hljs-built_in">this</span>.entityResolver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatingEntityResolver</span>(getBeanClassLoader());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.entityResolver;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="EntityResoler子类"><a href="#EntityResoler子类" class="headerlink" title="EntityResoler子类"></a>EntityResoler子类</h5><p>上边获取EntityResolver的方法共涉及到４个EntityResolver的子类。</p><h6 id="ResourceEntityResolver"><a href="#ResourceEntityResolver" class="headerlink" title="ResourceEntityResolver"></a>ResourceEntityResolver</h6><p><code>EntityResolverorg.springframework.beans.factory.xml.ResourceEntityResolver</code>继承自<code>DelegatingEntityResolver</code>，通过 ResourceLoader 来解析实体的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ResourceLoader resourceLoader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourceEntityResolver</span><span class="hljs-params">(ResourceLoader resourceLoader)</span> &#123;<br>    <span class="hljs-built_in">super</span>(resourceLoader.getClassLoader());<span class="hljs-comment">//下边紧接就是父类的构造器</span><br>    <span class="hljs-built_in">this</span>.resourceLoader = resourceLoader;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="DelegatingEntityResolver"><a href="#DelegatingEntityResolver" class="headerlink" title="DelegatingEntityResolver"></a>DelegatingEntityResolver</h6><p><code>org.springframework.beans.factory.xml.DelegatingEntityResolver</code>实现了<code>EntityResolver</code>接口，分别代理了<code>BeansDtdResolver</code>和<code>PluggableSchemaResolver</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DTD_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.dtd&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">XSD_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.xsd&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EntityResolver dtdResolver;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EntityResolver schemaResolver;<br><br><span class="hljs-comment">// 默认</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DelegatingEntityResolver</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> &#123;<br>    <span class="hljs-built_in">this</span>.dtdResolver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeansDtdResolver</span>();<br>    <span class="hljs-built_in">this</span>.schemaResolver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PluggableSchemaResolver</span>(classLoader);<br>&#125;<br><br><span class="hljs-comment">// 自定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DelegatingEntityResolver</span><span class="hljs-params">(EntityResolver dtdResolver, EntityResolver schemaResolver)</span> &#123;<br>    Assert.notNull(dtdResolver, <span class="hljs-string">&quot;&#x27;dtdResolver&#x27; is required&quot;</span>);<br>    Assert.notNull(schemaResolver, <span class="hljs-string">&quot;&#x27;schemaResolver&#x27; is required&quot;</span>);<br>    <span class="hljs-built_in">this</span>.dtdResolver = dtdResolver;<br>    <span class="hljs-built_in">this</span>.schemaResolver = schemaResolver;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="BeansDtdResolver"><a href="#BeansDtdResolver" class="headerlink" title="BeansDtdResolver"></a>BeansDtdResolver</h6><p><code>org.springframework.beans.factory.xml.BeansDtdResolver</code>实现了<code>EntityResolver</code>接口，Spring-Bean.dtd解码器，用来从<strong>classpath</strong>或者<strong>jar文件</strong>中加载 dtd ，源码注释有。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//&quot;/org/springframework/beans/factory/xml/spring-beans.dtd&quot;</span><br><span class="hljs-comment">//&quot;https://www.springframework.org/dtd/spring-beans-2.0.dtd&quot;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DTD_EXTENSION</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.dtd&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DTD_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring-beans&quot;</span>;<br></code></pre></td></tr></table></figure><h6 id="PluggableSchemaResolver"><a href="#PluggableSchemaResolver" class="headerlink" title="PluggableSchemaResolver"></a>PluggableSchemaResolver</h6><p><code>org.springframework.beans.factory.xml.PluggableSchemaResolver</code>实现了<code>EntityResolver</code>接口，读取 classpath 下的所有 <code>META-INF/spring.schemas</code> 成一个 namespaceURI 与 Schema 文件地址的 map 。</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>EntityResolver 的作用是项目本身就可以提供一个如何寻找 DTD 声明的方法，即由程序来实现寻找 DTD 声明的过程。比如我们将 DTD 文件放到项目中某处，在实现时直接将此文档读取并返回给 SAX 即可。这样就避免了通过网络来寻找相应的声明。－－《Spring 源码深度解析》</p><p><code>org.xml.sax.EntityResolver</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> *@param 被引用的外部实体的公共标识符，如果没有提供，则返回 null 。.</span><br><span class="hljs-comment"> *@param 被引用的外部实体的系统标识符。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> InputSource <span class="hljs-title function_">resolveEntity</span> <span class="hljs-params">(String publicId,String systemId)</span><span class="hljs-keyword">throws</span> SAXException, IOException;<br></code></pre></td></tr></table></figure><p>这两个参数的实际内容和具体的验证模式的如下：</p><ul><li><p>XSD验证模式：</p><ul><li>publicId ：null</li><li>systemId：<a href="http://www.springframework.org/schema/beans/spring-beans.xsd">http://www.springframework.org/schema/beans/spring-beans.xsd</a></li></ul></li><li><p>DTD验证模式：</p><ul><li>publicId：-&#x2F;&#x2F;SPRING&#x2F;&#x2F;DTD BEAN 2.0&#x2F;&#x2F;EN</li><li>systemId：<a href="http://www.springframework.org/dtd/spring-beans.dtd">http://www.springframework.org/dtd/spring-beans.dtd</a></li></ul></li></ul><h5 id="ResourceEntityResolver-1"><a href="#ResourceEntityResolver-1" class="headerlink" title="ResourceEntityResolver"></a>ResourceEntityResolver</h5><p>ResourceEntityResolver的解析过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> InputSource <span class="hljs-title function_">resolveEntity</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String publicId, <span class="hljs-meta">@Nullable</span> String systemId)</span><br>    <span class="hljs-keyword">throws</span> SAXException, IOException &#123;<br>    <span class="hljs-comment">// 调用父类的方法，进行解析</span><br>    <span class="hljs-type">InputSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.resolveEntity(publicId, systemId);<br>    <span class="hljs-comment">// 解析失败，resourceLoader 进行解析</span><br>    <span class="hljs-keyword">if</span> (source == <span class="hljs-literal">null</span> &amp;&amp; systemId != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 获得 resourcePath ，即 Resource 资源地址</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">resourcePath</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">decodedSystemId</span> <span class="hljs-operator">=</span> URLDecoder.decode(systemId, <span class="hljs-string">&quot;UTF-8&quot;</span>);<span class="hljs-comment">// 使用 UTF-8 ，解码 systemId</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">givenUrl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(decodedSystemId).toString();<span class="hljs-comment">// 转换成 URL 字符串</span><br>            <span class="hljs-comment">// 解析文件资源的相对路径（相对于系统根路径）</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">systemRootUrl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;&quot;</span>).toURI().toURL().toString();<br>            <span class="hljs-comment">// Try relative to resource base if currently in system root.</span><br>            <span class="hljs-keyword">if</span> (givenUrl.startsWith(systemRootUrl)) &#123;<br>                resourcePath = givenUrl.substring(systemRootUrl.length());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            <span class="hljs-comment">// Typically a MalformedURLException or AccessControlException.</span><br>            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                logger.debug(<span class="hljs-string">&quot;Could not resolve XML entity [&quot;</span> + systemId + <span class="hljs-string">&quot;] against system root URL&quot;</span>, ex);<br>            &#125;<br>            <span class="hljs-comment">// No URL (or no resolvable URL) -&gt; try relative to resource base.</span><br>            resourcePath = systemId;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resourcePath != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                logger.trace(<span class="hljs-string">&quot;Trying to locate XML entity [&quot;</span> + systemId + <span class="hljs-string">&quot;] as resource [&quot;</span> + resourcePath + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 获得 Resource 资源</span><br>            <span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.resourceLoader.getResource(resourcePath);<br>            <span class="hljs-comment">// 创建 InputSource 对象</span><br>            source = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(resource.getInputStream());<br>            <span class="hljs-comment">// 设置 publicId 和 systemId 属性</span><br>            source.setPublicId(publicId);<br>            source.setSystemId(systemId);<br>            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                logger.debug(<span class="hljs-string">&quot;Found XML entity [&quot;</span> + systemId + <span class="hljs-string">&quot;]: &quot;</span> + resource);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (systemId.endsWith(DTD_SUFFIX) || systemId.endsWith(XSD_SUFFIX)) &#123;<br>            <span class="hljs-comment">//通过https进行外部dtdxsd查找</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> systemId;<br>            <span class="hljs-keyword">if</span> (url.startsWith(<span class="hljs-string">&quot;http:&quot;</span>)) &#123;<br>                url = <span class="hljs-string">&quot;https:&quot;</span> + url.substring(<span class="hljs-number">5</span>);<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                source = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url).openStream());<br>                source.setPublicId(publicId);<br>                source.setSystemId(systemId);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>                <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;Could not resolve XML entity [&quot;</span> + systemId + <span class="hljs-string">&quot;] through URL [&quot;</span> + url + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>                &#125;<br>                <span class="hljs-comment">//退回到解析器的默认行为</span><br>                source = <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> source;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先，调用<strong>父类</strong>的方法，进行解析。</li><li>如果失败，使用 <code>resourceLoader</code> ，尝试读取 <code>systemId</code> 对应的 Resource 资源。</li></ul><h5 id="DelegatingEntityResolver-1"><a href="#DelegatingEntityResolver-1" class="headerlink" title="DelegatingEntityResolver"></a>DelegatingEntityResolver</h5><p><code>DelegatingEntityResolver</code>的解析过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> InputSource <span class="hljs-title function_">resolveEntity</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String publicId, <span class="hljs-meta">@Nullable</span> String systemId)</span><br>    <span class="hljs-keyword">throws</span> SAXException, IOException &#123;<br>    <span class="hljs-keyword">if</span> (systemId != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// DTD 模式，使用BeansDtdResolver进行解析</span><br>        <span class="hljs-keyword">if</span> (systemId.endsWith(DTD_SUFFIX)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dtdResolver.resolveEntity(publicId, systemId);<br>        &#125;<br>        <span class="hljs-comment">// XSD 模式，使用PluggableSchemaResolver进行解析</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (systemId.endsWith(XSD_SUFFIX)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.schemaResolver.resolveEntity(publicId, systemId);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="BeansDtdResolver-1"><a href="#BeansDtdResolver-1" class="headerlink" title="BeansDtdResolver"></a>BeansDtdResolver</h5><p><code>BeansDtdResolver</code>的解析过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> InputSource <span class="hljs-title function_">resolveEntity</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String publicId, <span class="hljs-meta">@Nullable</span> String systemId)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>        logger.trace(<span class="hljs-string">&quot;Trying to resolve XML entity with public ID [&quot;</span> + publicId +<br>                     <span class="hljs-string">&quot;] and system ID [&quot;</span> + systemId + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 以 .dtd 结尾</span><br>    <span class="hljs-keyword">if</span> (systemId != <span class="hljs-literal">null</span> &amp;&amp; systemId.endsWith(DTD_EXTENSION)) &#123;<br>        <span class="hljs-comment">// 获取最后一个 / 的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastPathSeparator</span> <span class="hljs-operator">=</span> systemId.lastIndexOf(<span class="hljs-string">&#x27;/&#x27;</span>);<br>        <span class="hljs-comment">// 获取 spring-beans 的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">dtdNameStart</span> <span class="hljs-operator">=</span> systemId.indexOf(DTD_NAME, lastPathSeparator);<br>        <span class="hljs-keyword">if</span> (dtdNameStart != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">dtdFile</span> <span class="hljs-operator">=</span> DTD_NAME + DTD_EXTENSION;<br>            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                logger.trace(<span class="hljs-string">&quot;Trying to locate [&quot;</span> + dtdFile + <span class="hljs-string">&quot;] in Spring jar on classpath&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 创建 ClassPathResource 对象</span><br>                <span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(dtdFile, getClass());<br>                <span class="hljs-comment">// 创建 InputSource 对象，并设置 publicId、systemId 属性</span><br>                <span class="hljs-type">InputSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(resource.getInputStream());<br>                source.setPublicId(publicId);<br>                source.setSystemId(systemId);<br>                <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                    logger.trace(<span class="hljs-string">&quot;Found beans DTD [&quot;</span> + systemId + <span class="hljs-string">&quot;] in classpath: &quot;</span> + dtdFile);<br>                &#125;<br>                <span class="hljs-keyword">return</span> source;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (FileNotFoundException ex) &#123;<br>                <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;Could not resolve beans DTD [&quot;</span> + systemId + <span class="hljs-string">&quot;]: not found in classpath&quot;</span>, ex);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 使用默认行为，从网络上下载</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="PluggableSchemaResolver-1"><a href="#PluggableSchemaResolver-1" class="headerlink" title="PluggableSchemaResolver"></a>PluggableSchemaResolver</h5><p><code>PluggableSchemaResolver</code>解析过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> InputSource <span class="hljs-title function_">resolveEntity</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String publicId, <span class="hljs-meta">@Nullable</span> String systemId)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>        logger.trace(<span class="hljs-string">&quot;Trying to resolve XML entity with public id [&quot;</span> + publicId +<br>                     <span class="hljs-string">&quot;] and system id [&quot;</span> + systemId + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (systemId != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 获得 Resource 所在位置</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">resourceLocation</span> <span class="hljs-operator">=</span> getSchemaMappings().get(systemId);<br>        <span class="hljs-keyword">if</span> (resourceLocation == <span class="hljs-literal">null</span> &amp;&amp; systemId.startsWith(<span class="hljs-string">&quot;https:&quot;</span>)) &#123;<br>            <span class="hljs-comment">// Retrieve canonical http schema mapping even for https declaration</span><br>            resourceLocation = getSchemaMappings().get(<span class="hljs-string">&quot;http:&quot;</span> + systemId.substring(<span class="hljs-number">6</span>));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resourceLocation != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(resourceLocation, <span class="hljs-built_in">this</span>.classLoader);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 创建 InputSource 对象，并设置 publicId、systemId 属性</span><br>                <span class="hljs-type">InputSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(resource.getInputStream());<br>                source.setPublicId(publicId);<br>                source.setSystemId(systemId);<br>                <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                    logger.trace(<span class="hljs-string">&quot;Found XML schema [&quot;</span> + systemId + <span class="hljs-string">&quot;] in classpath: &quot;</span> + resourceLocation);<br>                &#125;<br>                <span class="hljs-keyword">return</span> source;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (FileNotFoundException ex) &#123;<br>                <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;Could not find XML schema [&quot;</span> + systemId + <span class="hljs-string">&quot;]: &quot;</span> + resource, ex);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getSchemaMappings()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;String, String&gt; <span class="hljs-title function_">getSchemaMappings</span><span class="hljs-params">()</span> &#123;<br>    Map&lt;String, String&gt; schemaMappings = <span class="hljs-built_in">this</span>.schemaMappings;<br>    <span class="hljs-comment">// 双重检查锁，实现 schemaMappings 单例</span><br>    <span class="hljs-keyword">if</span> (schemaMappings == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            schemaMappings = <span class="hljs-built_in">this</span>.schemaMappings;<br>            <span class="hljs-keyword">if</span> (schemaMappings == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                    logger.trace(<span class="hljs-string">&quot;Loading schema mappings from [&quot;</span> + <span class="hljs-built_in">this</span>.schemaMappingsLocation + <span class="hljs-string">&quot;]&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 以 Properties 的方式，读取 schemaMappingsLocation</span><br>                    <span class="hljs-type">Properties</span> <span class="hljs-variable">mappings</span> <span class="hljs-operator">=</span><br>                        PropertiesLoaderUtils.loadAllProperties(<span class="hljs-built_in">this</span>.schemaMappingsLocation, <span class="hljs-built_in">this</span>.classLoader);<br>                    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                        logger.trace(<span class="hljs-string">&quot;Loaded schema mappings: &quot;</span> + mappings);<br>                    &#125;<br>                    <span class="hljs-comment">// 将 mappings 初始化到 schemaMappings 中</span><br>                    schemaMappings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(mappings.size());<br>                    CollectionUtils.mergePropertiesIntoMap(mappings, schemaMappings);<br>                    <span class="hljs-built_in">this</span>.schemaMappings = schemaMappings;<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                        <span class="hljs-string">&quot;Unable to load schema mappings from location [&quot;</span> + <span class="hljs-built_in">this</span>.schemaMappingsLocation + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> schemaMappings;<br>&#125;<br></code></pre></td></tr></table></figure><p>例：部分映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;http://www.springframework.org/schema/context/spring-context-3.2.xsd&quot;</span>-&gt;<span class="hljs-string">&quot;org/springframework/context/config/spring-context.xsd&quot;</span><br><span class="hljs-string">&quot;http://www.springframework.org/schema/cache/spring-cache-4.3.xsd&quot;</span>-&gt;<span class="hljs-string">&quot;org/springframework/cache/config/spring-cache.xsd&quot;</span><br></code></pre></td></tr></table></figure><h5 id="自定义EntityResolver"><a href="#自定义EntityResolver" class="headerlink" title="自定义EntityResolver"></a>自定义EntityResolver</h5><p>如果 SAX 应用程序需要实现自定义处理外部实体，则必须实现EntityResolver接口，并使用 <code>#setEntityResolver(EntityResolver entityResolver)</code> 方法，向 SAX 驱动器注册一个 EntityResolver 实例。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>六、注册BeanDefinitions</title>
    <link href="/2022/06/11/%E6%B3%A8%E5%86%8CBeanDefinitions/"/>
    <url>/2022/06/11/%E6%B3%A8%E5%86%8CBeanDefinitions/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">注册BeanDefinitions</font></div><p>通过<code>XmlBeanDefinitionReader.doLoadDocument()</code>获取了<code>XML Documents</code>对象后，会使用该Document对象和Resource资源对象通过<code>XmlBeanDefinitionReader.registerBeanDefinitions()</code>开始注册<code>BeanDefinitions</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(Document doc, Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    <span class="hljs-comment">// &lt;1&gt; 创建 BeanDefinitionDocumentReader 对象</span><br>    <span class="hljs-type">BeanDefinitionDocumentReader</span> <span class="hljs-variable">documentReader</span> <span class="hljs-operator">=</span> createBeanDefinitionDocumentReader();<br>    <span class="hljs-comment">// &lt;2&gt; 获取已注册的 BeanDefinition 数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">countBefore</span> <span class="hljs-operator">=</span> getRegistry().getBeanDefinitionCount();<br>    <span class="hljs-comment">// &lt;3&gt; 创建 XmlReaderContext 对象，参数createReaderContext(resource)</span><br>    <span class="hljs-comment">// &lt;4&gt; 注册 BeanDefinition</span><br>    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));<br>    <span class="hljs-comment">// 计算新注册的 BeanDefinition 数量</span><br>    <span class="hljs-keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="createBeanDefinitionDocumentReader-方法"><a href="#createBeanDefinitionDocumentReader-方法" class="headerlink" title="createBeanDefinitionDocumentReader()方法"></a><code>createBeanDefinitionDocumentReader()</code>方法</h4><p><code>createBeanDefinitionDocumentReader()</code>实例化<code>BeanDefinitionDocumentReader</code>对象，用来从XML文件中读取bean定义，默认实例化指定的<code>documentReaderClass</code>，即<code>DefaultBeanDefinitionDocumentReader.class</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanDefinitionDocumentReader</span>&gt; documentReaderClass =<br>DefaultBeanDefinitionDocumentReader.class;<br><span class="hljs-keyword">protected</span> BeanDefinitionDocumentReader <span class="hljs-title function_">createBeanDefinitionDocumentReader</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> BeanUtils.instantiateClass(<span class="hljs-built_in">this</span>.documentReaderClass);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="registerBeanDefinitions-方法"><a href="#registerBeanDefinitions-方法" class="headerlink" title="registerBeanDefinitions()方法"></a><code>registerBeanDefinitions()</code>方法</h4><p><code>BeanDefinitionDocumentReader.registerBeanDefinitions(Document doc, XmlReaderContext readerContext)</code> 方法，注册 BeanDefinition ，在接口 BeanDefinitionDocumentReader 中定义。</p><p>机翻方法注释：<strong>从给定的DOM文档中读取bean定义，并在给定的阅读器上下文中向注册表注册它们。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanDefinitionDocumentReader</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(Document doc, XmlReaderContext readerContext)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="DefaultBeanDefinitionDocumentReader"><a href="#DefaultBeanDefinitionDocumentReader" class="headerlink" title="DefaultBeanDefinitionDocumentReader"></a>DefaultBeanDefinitionDocumentReader</h5><p>该类是<code>BeanDefinitionDocumentReader</code>的实现类，且是唯一一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(Document doc, XmlReaderContext readerContext)</span> &#123;<br>    <span class="hljs-built_in">this</span>.readerContext = readerContext;<br><span class="hljs-comment">//获取XML Document Root Element并执行注册</span><br>    doRegisterBeanDefinitions(doc.getDocumentElement());<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegisterBeanDefinitions</span><span class="hljs-params">(Element root)</span> &#123;<br>    <span class="hljs-comment">// 保存原有的 BeanDefinitionParserDelegate 对象</span><br>    <span class="hljs-type">BeanDefinitionParserDelegate</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.delegate;<br>    <span class="hljs-comment">// &lt;1&gt; 创建 BeanDefinitionParserDelegate 对象，并进行设置到 delegate</span><br>    <span class="hljs-built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);<br>    <span class="hljs-comment">// &lt;2&gt; 给定的ＵＲＬ是否包含默认命名空间检查 &lt;beans /&gt; 根标签的命名空间是否为空，或者是 http://www.springframework.org/schema/beans</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;<br>        <span class="hljs-comment">// &lt;2.1&gt; 处理 profile 属性。&lt;bean profile=&quot;&quot;&gt;&lt;/bean&gt;，比如之前区分Test,Dev...等环境需要定义好几个application-xxx.xml文件，现在使用profile即可。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">profileSpec</span> <span class="hljs-operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);<br>        <span class="hljs-keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;<br>            <span class="hljs-comment">// &lt;2.2&gt; 使用分隔符切分，可能有多个 profile 。</span><br>            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(<br>                profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);<br>            <span class="hljs-comment">// &lt;2.3&gt; 如果所有 profile 都无效，则不进行注册</span><br>            <span class="hljs-keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;<br>                <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +<br>                                 <span class="hljs-string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// &lt;3&gt; 解析前处理，目前是个空方法，需要子类去实现。</span><br>    preProcessXml(root);<br>    <span class="hljs-comment">// &lt;4&gt; 解析</span><br>    parseBeanDefinitions(root, <span class="hljs-built_in">this</span>.delegate);<br>    <span class="hljs-comment">// &lt;5&gt; 解析后处理，目前是个空方法，需要子类去实现。</span><br>    postProcessXml(root);<br>    <span class="hljs-comment">// 设置 delegate 为开头保存的　BeanDefinitionParserDelegate 对象</span><br>    <span class="hljs-built_in">this</span>.delegate = parent;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="createDelegate-方法"><a href="#createDelegate-方法" class="headerlink" title="createDelegate()方法"></a><code>createDelegate()</code>方法</h6><p><code>BeanDefinitionParserDelegate</code>负责解析<code>BeanDifinition</code>对象，定义了解析XML Element的各种方法，如下获取<code>BeanDefinitionParserDelegate</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">createDelegateprotected BeanDefinitionParserDelegate <span class="hljs-title function_">createDelegate</span><span class="hljs-params">(</span><br><span class="hljs-params">    XmlReaderContext readerContext, Element root, <span class="hljs-meta">@Nullable</span> BeanDefinitionParserDelegate parentDelegate)</span> &#123;<br>    <span class="hljs-comment">// 创建 BeanDefinitionParserDelegate 对象</span><br>    <span class="hljs-type">BeanDefinitionParserDelegate</span> <span class="hljs-variable">delegate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionParserDelegate</span>(readerContext);<br>    <span class="hljs-comment">// 初始化默认</span><br>    delegate.initDefaults(root, parentDelegate);<br>    <span class="hljs-keyword">return</span> delegate;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="parseBeanDefinitions-方法"><a href="#parseBeanDefinitions-方法" class="headerlink" title="parseBeanDefinitions()方法"></a><code>parseBeanDefinitions()</code>方法</h6><p>对给定的<code>Element</code>进行解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseBeanDefinitions</span><span class="hljs-params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;<br>    <span class="hljs-comment">// &lt;1&gt; 根节点是否使用默认命名空间，</span><br>    <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;<br>        <span class="hljs-comment">// 遍历子节点</span><br>        <span class="hljs-type">NodeList</span> <span class="hljs-variable">nl</span> <span class="hljs-operator">=</span> root.getChildNodes();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nl.item(i);<br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Element) &#123;<br>                <span class="hljs-type">Element</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> (Element) node;<br>                <span class="hljs-comment">//该节点是否使用默认命名空间，执行默认解析。</span><br>                <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;<br>                    parseDefaultElement(ele, delegate);<br>                &#125;<br>                <span class="hljs-comment">//如果不是默认命名空间，执行自定义解析。</span><br>                <span class="hljs-keyword">else</span> &#123;<br>                    delegate.parseCustomElement(ele);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//&lt;2&gt;如果不是默认命名空间，执行自定义解析。</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        delegate.parseCustomElement(root);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Spring有两种Bean声明方式：<ol><li>配置文件式声明，例：<code>&lt;bean id=&quot;lizi&quot; class=&quot;com.jievhaha.lizi&quot;/&gt;</code>，使用&lt;1&gt;处解析</li><li>自定义注解方式：<code>&lt;tx:anntation-driven&gt;</code>，执行&lt;2&gt;处解析</li></ol></li></ul><p>子节点或者根节点使用默认命名空间，执行默认解析，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseDefaultElement</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;<br>    <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;<br>        importBeanDefinitionResource(ele);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;<br>        processAliasRegistration(ele);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;<br>        processBeanDefinition(ele, delegate);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;<br>        <span class="hljs-comment">// recurse</span><br>        doRegisterBeanDefinitions(ele);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="createReaderContext-方法"><a href="#createReaderContext-方法" class="headerlink" title="createReaderContext()方法"></a><code>createReaderContext()</code>方法</h4><p>文章开头，注册BeanDefinition对象时需要上送<code>XmlReaderContext</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">ProblemReporter</span> <span class="hljs-variable">problemReporter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FailFastProblemReporter</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-type">ReaderEventListener</span> <span class="hljs-variable">eventListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyReaderEventListener</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-type">SourceExtractor</span> <span class="hljs-variable">sourceExtractor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullSourceExtractor</span>();<br><br><span class="hljs-keyword">public</span> XmlReaderContext <span class="hljs-title function_">createReaderContext</span><span class="hljs-params">(Resource resource)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlReaderContext</span>(resource, <span class="hljs-built_in">this</span>.problemReporter, <span class="hljs-built_in">this</span>.eventListener,<br>                                <span class="hljs-built_in">this</span>.sourceExtractor, <span class="hljs-built_in">this</span>, getNamespaceHandlerResolver());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><code>XmlBeanDefinitionReader.doLoadBeanDefinitions</code>解析过程时序图：</p><p><img src="/images/spring_IOC/%E6%B3%A8%E5%86%8CBeanDefinition%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg" alt="注册BeanDefinition时序图"></p><p>红框是解析过程。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理财投资扫盲</title>
    <link href="/2022/06/11/%E7%90%86%E8%B4%A2%E6%8A%95%E8%B5%84%E6%89%AB%E7%9B%B2/"/>
    <url>/2022/06/11/%E7%90%86%E8%B4%A2%E6%8A%95%E8%B5%84%E6%89%AB%E7%9B%B2/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">理财投资扫盲</font></div><h4 id="基金类型"><a href="#基金类型" class="headerlink" title="基金类型"></a>基金类型</h4><h5 id="债券型基金"><a href="#债券型基金" class="headerlink" title="债券型基金"></a>债券型基金</h5><p>债券型基金是指<strong>80%以上</strong>的资产投资于债券的基金。</p><p>债券主要分为政府债券，金融债券，企业债以及可转债，风险依次增大。</p><p>债券型基金，波动率小，稳健，适合防守，稳固后方。</p><p>混合型基金，风格可变，可攻可受，适合当中场，掌握中军。</p><p>股票型、指数型、QDII型，风格激进，适合当前锋，冲锋陷阵。</p><p>1） 货币型基金：主要投资银行货币间市场，风险极低。</p><p>2） 债权型基金：主要投资债权，里面有个分支叫偏债基金可以投资不超过20%的股票。风险偏低</p><p>3） 混合型基金：混合型基金同时投资于股票、债券和货币市场等工具，但投资比例灵活，几乎没有限制。风险和预期收益相对适中。</p><p>4） 股票型基金：80%以上的资产要投资于股票，风险较大</p><p>5） 指数型基金：全部投资股票，也可以理解为一种特殊的股票型基金。</p><p>工具：<strong>天天基金网</strong>，可查看基金的<strong>资产配置</strong>（股票、债券、现金），<strong>投资风格</strong>，都在最下边，基金经理介绍上边。</p><h5 id="股票分类"><a href="#股票分类" class="headerlink" title="股票分类"></a>股票分类</h5><p>１.<strong>根据公司市值的大小，可以把股票分成大盘股&#x2F;小盘股。</strong></p><p>大盘股风险低，收益也较低，小盘股风险高，收益也较高。</p><p>例：总市值小于200亿定义为小盘股，200-500亿为中盘股，500亿以上是大盘股。</p><p>大盘股的典型代表就是熟知的贵州茅台，总市值2万多亿。</p><p>小盘股大多都在深交所上市，比较典型的有曙光股份，北纬科技等。</p><p>２.<strong>根据成长性，可以把股票分为价值股和成长股</strong>。</p><p>价值股一般属于传统行业，市值较高，赢收<strong>稳定</strong>，比如说可口可乐，五粮液；</p><p>成长股一般是新兴行业，比如人工智能，互联网，同时具备较大的发展<strong>潜力</strong>。</p><h5 id="业绩表现"><a href="#业绩表现" class="headerlink" title="业绩表现"></a>业绩表现</h5><p>主要投资大盘股的基金会跟沪深300指数做对比，主要投资债券的基金会跟中债综合指数做对比。</p><p>基金一段时期的最大跌幅叫做最大回撤，这个数字越低说明该选手的防守能力越强。</p><h4 id="如何选择基金"><a href="#如何选择基金" class="headerlink" title="如何选择基金"></a>如何选择基金</h4><p><strong>１．选择基金类型</strong></p><p><strong>２．查询过往业绩</strong></p><p>​a、 在同类基金里，选出最近6个月业绩前30名的基金；</p><p>​b、 在同类基金里，选出最近1年业绩前30名的基金。</p><p>​c、 在同类基金里，选出最近3年业绩前30名的基金。</p><p>​c、 在同类基金里，选出最近5年业绩前30名的基金。</p><p>​e、 在同类基金里，选出成立以来业绩前30名的基金。</p><p><strong>３．选择基金公司</strong></p><p>​前十名基金公司：1）天弘、2）易方达、3）博时、4）南方、5）华夏、6）汇添富、7）广发、8）工银瑞信、9）嘉实、10）鹏华。</p><p>​也有很多小而美的基金公司，例：富国擅长量化投资，交银施罗德擅长投科技领域、成长企业，兴全擅长价值投资等。</p><p><strong>４．选择基金经理</strong></p><p>​现任基金经理至少要管理这支基金三年以上，</p><p><strong>５．选择投资风格</strong></p><p>​大盘股和小盘股、价值股和成长股。</p><p><strong>６．选择三大细节</strong></p><p>​a、成立时间，最好是选成立5年以上。要观察基金穿越一个牛熊周期的表现。</p><p>​b、管理规模，30以内太小，100亿以上太大。</p><p>​c、回撤率，回撤率的意思是从高点买入，在到达最低点时，下跌了多少。最大回撤不要超过30%。在基金净值走势图里，可以查到回撤率。</p><h5 id="如何选择保守型基金"><a href="#如何选择保守型基金" class="headerlink" title="如何选择保守型基金"></a>如何选择保守型基金</h5><p>1.<strong>选择收益率高的货币基金</strong></p><p>货币型基金<strong>近乎于无风险投资</strong>，因此<strong>收益率的高低</strong>是衡量货币基金的核心。</p><p>２.<strong>选择基金规模中等的基金</strong></p><p>在经济学中有一个叫做“<strong>规模经济</strong>”的概念。意思是说生产的产品越多，平摊到每一个产品的费用就越低。但随着<strong>基金份额过大</strong>，就有可能出现<strong>“规模不经济</strong>”效应。当规模过大时，无形中拉高了成本。</p><p>选择的货币基金份额最好保持在<strong>200亿-1000亿</strong>之间，这样基金经理既有筹码去获得更高的利率，也不至于投资风格太过保守。</p><h5 id="如何选择债券型基金"><a href="#如何选择债券型基金" class="headerlink" title="如何选择债券型基金"></a>如何选择债券型基金</h5><p>1.<strong>债券持仓</strong>：政府债券，金融债券，企业债券，风险和收益依次增大。</p><p>2.<strong>杠杆比例</strong>：有个概念，加杠杆，杠杆比例越高，风险和收益也越高。</p><p>3.<strong>收益率</strong></p><p>4.<strong>回撤率</strong>：回撤率过高的债基已经失去了防守型资产的特性，不建议选择，不要挑选最大回撤<strong>超过10%以上</strong>的债基。</p><h4 id="保守型基金投资时机"><a href="#保守型基金投资时机" class="headerlink" title="保守型基金投资时机"></a>保守型基金投资时机</h4><p>1.<strong>宏观经济数据</strong>：无论是货币型基金还是债券型基金，主要收益都和市场利率相关，当利率上升时，货币型和债券型基金的收益会下降。</p><p>2.<strong>股市表现</strong></p><h4 id="定投"><a href="#定投" class="headerlink" title="定投"></a>定投</h4><h5 id="定投原理"><a href="#定投原理" class="headerlink" title="定投原理"></a>定投原理</h5><p><strong>假如每期投入1000元</strong>，</p><p><strong>买入时</strong>，每期定投金额&#x2F;该期定投价格 &#x3D; 该期定投份额，</p><p>每期定投份额累加即为<strong>总份额</strong>，</p><p>1000 * 投入期数 &#x2F; 总份额 &#x3D; 平均成本，</p><p><strong>卖出时</strong>，(该期定投价格 - 平均成本) * 总份额 &#x3D; 收益。</p><h5 id="定投思想"><a href="#定投思想" class="headerlink" title="定投思想"></a>定投思想</h5><p>被动型投资和主动型投资。</p><h6 id="指数基金"><a href="#指数基金" class="headerlink" title="指数基金"></a>指数基金</h6><p>被动投资，简单理解就是投资特定的指数基金，跟着市场走。指数基金就是以特定指数的成分股（沪深300，标普500）为投资标的，投资此类指数基金，就能<strong>复制该指数的表现</strong>。</p><p>Ａ股指数介绍</p><p><strong>1.上证50指数</strong>：从<strong>上海证券交易所</strong>的股票里挑选50支市值最大，流动性好的股票，组成一个组合。例：贵州茅台，伊利股份。<em><strong>注：道琼指数类似上证50。</strong></em></p><p><strong>2.沪深300指数</strong>：沪深300指数更加全面一些，相比于上证50，加入了深交所的股票，从<strong>深交所</strong>和<strong>上交所</strong>挑选出市值最大，流动性最好的300支股票。</p><p><strong>3.中证500指数</strong>：将沪深300的公司排除，在剩下的公司当中选择总市值前500的指数组成。例：光线传媒，森马服饰。</p><p><strong>4.创业板指数</strong>：由创业板中最优秀的100家企业组成。创业板是以中小型企业为主，因此主要是成长型企业，容易暴涨暴跌。<em><strong>注：纳斯达克类似于创业板和科创板。</strong></em></p><p><strong>5.科创50指数</strong>：由科创板中市值最大的50支股票组成。不稳定性较高。</p><h6 id="指数增强型基金"><a href="#指数增强型基金" class="headerlink" title="指数增强型基金"></a>指数增强型基金</h6><p>基金经理可以通过自己的判断（<strong>主观选股</strong>）或者计算机的计算结果（<strong>量化选股</strong>）来调整指数中各个成分股的比例。</p><p>例：中证500指数包含了500个中型公司，增强型的基金经理可以通过他的判断，多买一些优等公司，少买甚至不买劣等公司。他可能只买了300家公司。</p><h6 id="主动型基金"><a href="#主动型基金" class="headerlink" title="主动型基金"></a>主动型基金</h6><p>完全跟指数没关系，基金经理完全根据自己的判断择时选股，投资主动型基金就等于投资基金经理。</p><p><strong>资产配置，股票持仓，投资风格以及业绩表现</strong>是需要关注的重点。</p><h5 id="如何定投"><a href="#如何定投" class="headerlink" title="如何定投"></a>如何定投</h5><p>1.股市长期走势是向上</p><p>2.长期坚持，中国股市，一个牛熊市周期大概在5-7年。</p><p>3.最基本的要点是要选择<strong>波动率大</strong>的基金（摊薄成本，涨幅）。</p><p><strong>债权投资，货币投资</strong>（固收类投资）为主的基金<strong>波动率比较小</strong>，<strong>股票型，偏股混合型基金适用于定投；债券型，货币型基金不适合定投</strong>。</p><p>1）<strong>不要选择被动型指数基金</strong>！ </p><p>2）<strong>不要选择债券型基金</strong>，要选择波动率大的基金。</p><p>3）选择<strong>主动管理型基金来搭配指数增强型基金</strong>。</p><h4 id="基金组合"><a href="#基金组合" class="headerlink" title="基金组合"></a>基金组合</h4><h5 id="防守、中场、进攻如何选择"><a href="#防守、中场、进攻如何选择" class="headerlink" title="防守、中场、进攻如何选择"></a>防守、中场、进攻如何选择</h5><p><strong>１、防守型基金</strong></p><p>主要选债权型基金，偏债和纯债都是可以的。</p><p><strong>２、中场型基金</strong></p><p>主要是一些价值型投资的混合&amp;股票基金。</p><p>这些基金主要投资一些大盘股、价值股。比如：茅台、中国平安、格力电器这样的公司。另外大盘的一些指数基金，也适合做中场。例：沪深300，上证50指数。</p><p><strong>３、进攻型基金</strong></p><p>创业板指数、科创50指数、中证500指数，就适合做进攻，科技、5G、医疗、新能源这些产业的基金，都适合做进攻型基金。</p><h5 id="如何搭配"><a href="#如何搭配" class="headerlink" title="如何搭配"></a>如何搭配</h5><p>根据个人能力和市场情况：</p><p>防守：中场：进攻</p><p><strong>保守型投资者</strong>：5：3：2，5年下来，平均年化回报，可能在0%-10%之间</p><p><strong>稳健型投资者</strong>：3：4：3，5年下来，平均年化回报，可能在-5%-15%之间，可能会亏损。</p><p><strong>进取型投资者</strong>：2：4：4，5年下来，平均年化回报，可能在-10%-20%之间。</p><h4 id="打新基金"><a href="#打新基金" class="headerlink" title="打新基金"></a>打新基金</h4><p><strong>注意：</strong>具体还是没明白是什么…</p><p>对于全职打新基金还是要注意<strong>资金规模，建议不要超过10亿元，5亿元以下最好</strong>。</p><h4 id="宽基和窄基"><a href="#宽基和窄基" class="headerlink" title="宽基和窄基"></a>宽基和窄基</h4><p>宽基：</p><p>1）含10个或更多个股票； </p><p>2）单个成份股权重不超过30％；</p><p>3）权重最大的5个股票累计权重不超过指数的60％；</p><p>4）成份股平均日交易额超过5000万美元；</p><p>5）包含行业种类要多，要至少有两个一级行业以上，要至少有三个二级行业以上。</p><p>例：汇添富消费行业混合(000083)</p><p>窄基：</p><p>一般持有某种特定行业的基金。</p><p>例：工银前沿医疗，全部持在医疗行业。招商中证白酒指数，全部持在白酒这个二级行业。</p><p>长期效益来看，宽基完胜，短期效益可能会有几只窄基表现比较好，特别是一年以内。</p><h4 id="实战方面看一个基金"><a href="#实战方面看一个基金" class="headerlink" title="实战方面看一个基金"></a>实战方面看一个基金</h4><p>以下以**兴全合润混合(163406)**为例。</p><h5 id="基金公司"><a href="#基金公司" class="headerlink" title="基金公司"></a>基金公司</h5><p>资金规模</p><p><img src="/images/licai/rumen/%E8%B5%84%E9%87%91%E8%A7%84%E6%A8%A1.png" alt="资金规模"></p><p>资金规模变动</p><p><img src="/images/licai/rumen/%E8%B5%84%E9%87%91%E8%A7%84%E6%A8%A1%E5%8F%98%E5%8A%A8.png" alt="资金规模变动"></p><h5 id="大致看基金信息"><a href="#大致看基金信息" class="headerlink" title="大致看基金信息"></a>大致看基金信息</h5><p><img src="/images/licai/rumen/%E8%B5%84%E9%87%91%E5%A4%A7%E8%87%B4%E4%BF%A1%E6%81%AF.png" alt="资金大致信息"></p><ol><li><p>名称看不出基金投资的行业。</p></li><li><p>成立时间，成立各期间的收益率。</p></li><li><p>资金管理规模：超过100亿，规模大，比较信赖，但是灵活度不够高，之前选择基金有说明。</p></li><li><p>基金类型：该基金混合型，配置灵活，中高风险，收益也适中。具体都是股票、债券、现金等的什么组合，可查看资产配置。</p><p><img src="/images/licai/rumen/%E8%B5%84%E4%BA%A7%E9%85%8D%E7%BD%AE.png" alt="资产配置"></p><p><img src="/images/licai/rumen/%E8%B5%84%E4%BA%A7%E9%85%8D%E7%BD%AE%E6%98%8E%E7%BB%86.png" alt="资产配置明细"></p></li><li><p>看持仓，该基金投资行业比较分散，但都是龙头企业，宽基。</p><p><img src="/images/licai/rumen/%E6%8C%81%E4%BB%93%E6%AF%94.png" alt="持仓比"></p></li><li><p>近几个月，仅今年收益。</p></li></ol><h5 id="基金过往表现"><a href="#基金过往表现" class="headerlink" title="基金过往表现"></a>基金过往表现</h5><p>天天基金网产品信息查看涨幅更多信息。</p><p><img src="/images/licai/rumen/%E8%BF%87%E5%BE%80%E4%B8%9A%E7%BB%A9.png" alt="过往业绩"></p><p>还有重点，查看<strong>最大回撤率</strong>。超过30%有些偏高，之前也有介绍。具体还没有找到地方查看，比如30%回撤率，假如买在了最高点，这个基金最大会让你亏损30%。</p><h5 id="基金经理"><a href="#基金经理" class="headerlink" title="基金经理"></a>基金经理</h5><p>最近一任经理最好超过3年，还要查看任职回报。</p><p><img src="/images/licai/rumen/%E5%9F%BA%E9%87%91%E7%BB%8F%E7%90%86%E4%BF%A1%E6%81%AF.png" alt="基金经理信息"></p><p>还有该经理的投资风格。风格之前也有说明，该基金比较稳重。</p><p><img src="/images/licai/rumen/%E6%8A%95%E8%B5%84%E9%A3%8E%E6%A0%BC.png" alt="投资风格"></p>]]></content>
    
    
    <categories>
      
      <category>理财</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一单元语法</title>
    <link href="/2022/06/11/%E6%96%B0%E6%A0%87%E6%97%A5%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/06/11/%E6%96%B0%E6%A0%87%E6%97%A5%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">第一单元语法</font></div><h4 id="はです【肯定的判断句】"><a href="#はです【肯定的判断句】" class="headerlink" title="はです【肯定的判断句】"></a><del>は</del>です【肯定的判断句】</h4><ul><li>【是】おたしは李です。我是小李。</li><li>【在】李さんはトイレです。小李在厕所。</li></ul><p><strong>注</strong>：说自己的时候不需要加「さん」。</p><hr><h4 id="はではありません【否定的判断句】"><a href="#はではありません【否定的判断句】" class="headerlink" title="はではありません【否定的判断句】"></a><del>は</del>ではありません【否定的判断句】</h4><p>森さんは課長ではありません（或者じゃありません）。</p><p>課長「かちょう」</p><hr><h4 id="はですか【疑问句】"><a href="#はですか【疑问句】" class="headerlink" title="はですか【疑问句】"></a><del>は</del>ですか【疑问句】</h4><p>疑问句后边加个<strong>「か」</strong>，读升调。</p><ul><li><p>李さんは中国人ですか。</p><p>・・・はい、「李さんは」中国人です。括号里可省略。</p><p>・・・はい、そうです。</p></li><li><p>李さんは日本人ですか。</p><p>・・・いいえ、「李さんは」日本人ではありません。</p><p>・・・いいえ、ちがいます。「中国人です。」最后纠正可有可无。</p></li></ul><hr><h4 id="の【所属】"><a href="#の【所属】" class="headerlink" title="の【所属】"></a><del>の</del>【所属】</h4><p>基本上翻译过来都是“的”的意思。</p><p>これはわたしのかぎ「钥匙」です。</p><p>あれは家族「かぞく」の写真「しゃしん」です。</p><hr><h4 id="こ-x2F-そ-x2F-あ-x2F-ど"><a href="#こ-x2F-そ-x2F-あ-x2F-ど" class="headerlink" title="こ&#x2F;そ&#x2F;あ&#x2F;ど"></a>こ&#x2F;そ&#x2F;あ&#x2F;ど</h4><table><thead><tr><th align="center"></th><th align="center">こ</th><th align="center">そ</th><th align="center">あ</th><th align="center">ど</th></tr></thead><tbody><tr><td align="center">物</td><td align="center">これ</td><td align="center">それ</td><td align="center">あれ</td><td align="center">どれ</td></tr><tr><td align="center">连体词</td><td align="center">この</td><td align="center">その</td><td align="center">あの</td><td align="center">どの</td></tr><tr><td align="center">场所</td><td align="center">ここ</td><td align="center">そこ</td><td align="center">あそこ</td><td align="center">どこ</td></tr><tr><td align="center">场所（郑重）方向</td><td align="center">こちら</td><td align="center">そちら</td><td align="center">あちら</td><td align="center">どちら</td></tr></tbody></table><p>注：连体词不能单独使用，后需要接名词。基本上都是「こ」「そ」相对。</p><ul><li><p>【方向】こちらへどうぞ。</p></li><li><p>【地点】ここ・そこ・あそこは学校「がっこう」です。</p><p>・・・郑重说法：こちら・そちら・あちらは学校「がっこう」です。</p></li><li><p>【敬称】そちらは田中「たなか」さんです。</p></li></ul><hr><h4 id="も【也】"><a href="#も【也】" class="headerlink" title="も【也】"></a><del>も</del>【也】</h4><p>わたしは中国人です。あなたも中国人ですか。</p><p>わたしは＝＝私は</p><hr><h4 id="はですか、ですか。【选择疑问句】"><a href="#はですか、ですか。【选择疑问句】" class="headerlink" title="はですか、ですか。【选择疑问句】"></a><del>は</del>ですか、ですか。【选择疑问句】</h4><p>今日「きょう」は水曜日ですか、木曜日ですか。</p><p>・・・「今日は」木曜日です。</p><hr><h4 id="にがあります-x2F-います【存在句】"><a href="#にがあります-x2F-います【存在句】" class="headerlink" title="にがあります&#x2F;います【存在句】"></a><del>に</del>があります&#x2F;います【存在句】</h4><p>表示存在，在<del>有</del>。</p><p><strong>「に」</strong>格助词，表示存在的场所，<strong>「が」</strong>主格助词，表示存在的事物、人、动物，做主语。</p><ul><li>【无生命】部屋に机があります。</li><li>【有生命】部屋に猫がいます。</li></ul><hr><h4 id="はにあります-x2F-います【所在句】"><a href="#はにあります-x2F-います【所在句】" class="headerlink" title="はにあります&#x2F;います【所在句】"></a><del>は</del>にあります&#x2F;います【所在句】</h4><ul><li>【无生命】いすは部屋にあります。</li><li>【有生命】子供は公園にいます。</li></ul><hr><h4 id="疑问句"><a href="#疑问句" class="headerlink" title="疑问句"></a>疑问句</h4><ul><li><p>不含疑问词的疑问句。</p><p>本はいすの上にありますか。</p><p>・・・はい、あります。</p><p>・・・いいえ、ありません。</p></li><li><p>含疑问词的疑问句</p><p>【何】对什么东西进行提问。</p><p>テレビの上に何がありますか。</p><p>【だれ】对人进行提问。</p><p>会議室にだれがいますか。</p><p>【どこ】对地点进行提问。</p><p>スミスさんの家はどこにありますか。</p></li></ul><h4 id="と【并列】"><a href="#と【并列】" class="headerlink" title="と【并列】"></a><del>と</del>【并列】</h4><p>時計と眼鏡。</p><h4 id="疑问词-も-否定【全面否定句】"><a href="#疑问词-も-否定【全面否定句】" class="headerlink" title="疑问词 +  も + 否定【全面否定句】"></a>疑问词 +  も + 否定【全面否定句】</h4><p>教室にだれもいません。</p><p>冷蔵庫に何もありません。 </p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>新标日</category>
      
      <category>上册</category>
      
      <category>语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十四、BeanDefinition对象的注册</title>
    <link href="/2022/06/11/%E6%B3%A8%E5%86%8CBeanDefinition/"/>
    <url>/2022/06/11/%E6%B3%A8%E5%86%8CBeanDefinition/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">BeanDefinition对象的注册</font></div><p>在完成<code>BeanDifinition</code>对象的所有解析工作后，然后会执行<code>BeanDefinitionReaderUtils.registerBeanDefinition()</code>进行<code>BeanDefinition</code>对象的注册。</p><h4 id="BeanDefinitionReaderUtils-registerBeanDefinition-方法"><a href="#BeanDefinitionReaderUtils-registerBeanDefinition-方法" class="headerlink" title="BeanDefinitionReaderUtils.registerBeanDefinition()方法"></a><code>BeanDefinitionReaderUtils.registerBeanDefinition()</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinition</span><span class="hljs-params">(</span><br><span class="hljs-params">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br>    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br><br>    <span class="hljs-comment">// Register bean definition under primary name.</span><br>    <span class="hljs-comment">// 注册beandefinition到对应的beanName</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> definitionHolder.getBeanName();<br>    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());<br><br>    <span class="hljs-comment">// Register aliases for bean name, if any.</span><br>    <span class="hljs-comment">// 注册beanname的别名</span><br>    String[] aliases = definitionHolder.getAliases();<br>    <span class="hljs-keyword">if</span> (aliases != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (String alias : aliases) &#123;<br>            registry.registerAlias(beanName, alias);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="registerBeanDefinition-方法"><a href="#registerBeanDefinition-方法" class="headerlink" title="registerBeanDefinition()方法"></a><code>registerBeanDefinition()</code>方法</h5><p>注册beandefinition到对应的beanName是通过<code>BeanDefinitionRegistry.registerBeanDefinition()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//---------------------------------------------------------------------</span><br><span class="hljs-comment">// Implementation of BeanDefinitionRegistry interface</span><br><span class="hljs-comment">//---------------------------------------------------------------------</span><br><span class="hljs-comment">// DefaultListableBeanFactory.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span><br>    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br><br>    <span class="hljs-comment">// 校验 beanName 与 beanDefinition 非空</span><br>    Assert.hasText(beanName, <span class="hljs-string">&quot;Bean name must not be empty&quot;</span>);<br>    Assert.notNull(beanDefinition, <span class="hljs-string">&quot;BeanDefinition must not be null&quot;</span>);<br><br>    <span class="hljs-comment">// &lt;1&gt; 校验 BeanDefinition 。</span><br>    <span class="hljs-comment">// 这是注册前的最后一次校验了，主要是对属性 methodOverrides 进行校验。</span><br>    <span class="hljs-keyword">if</span> (beanDefinition <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ((AbstractBeanDefinition) beanDefinition).validate();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(beanDefinition.getResourceDescription(), beanName,<br>                                                   <span class="hljs-string">&quot;Validation of bean definition failed&quot;</span>, ex);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;2&gt; 从缓存中获取指定 beanName 的 BeanDefinition</span><br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">existingDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.beanDefinitionMap.get(beanName);<br>    <span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 如果存在</span><br>        <span class="hljs-comment">// 如果存在但是不允许覆盖，抛出异常</span><br>        <span class="hljs-keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionOverrideException</span>(beanName, beanDefinition, existingDefinition);<br>        &#125;<br>        <span class="hljs-comment">// 覆盖 beanDefinition 大于 被覆盖的 beanDefinition 的 ROLE ，打印 info 日志</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;<br>            <span class="hljs-comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span><br>            <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>                logger.info(<span class="hljs-string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +<br>                            <span class="hljs-string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +<br>                            existingDefinition + <span class="hljs-string">&quot;] with [&quot;</span> + beanDefinition + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 覆盖 beanDefinition 与 被覆盖的 beanDefinition 不相同，打印 debug 日志</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                logger.debug(<span class="hljs-string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +<br>                             <span class="hljs-string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +<br>                             <span class="hljs-string">&quot;] with [&quot;</span> + beanDefinition + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 其它，打印 debug 日志</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                logger.trace(<span class="hljs-string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +<br>                             <span class="hljs-string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +<br>                             <span class="hljs-string">&quot;] with [&quot;</span> + beanDefinition + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 允许覆盖，直接覆盖原有的 BeanDefinition 到 beanDefinitionMap 中。</span><br>        <span class="hljs-built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 如果不存在</span><br>        <span class="hljs-comment">// 检测创建 Bean 阶段是否已经开启，如果开启了则需要对 beanDefinitionMap 进行并发控制</span><br>        <span class="hljs-keyword">if</span> (hasBeanCreationStarted()) &#123;<br>            <span class="hljs-comment">// beanDefinitionMap 为全局变量，避免并发情况</span><br>            <span class="hljs-comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.beanDefinitionMap) &#123;<br>                <span class="hljs-comment">// 添加到 BeanDefinition 到 beanDefinitionMap 中。</span><br>                <span class="hljs-built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<br>                <span class="hljs-comment">// 添加 beanName 到 beanDefinitionNames 中</span><br>                List&lt;String&gt; updatedDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>.beanDefinitionNames.size() + <span class="hljs-number">1</span>);<br>                updatedDefinitions.addAll(<span class="hljs-built_in">this</span>.beanDefinitionNames);<br>                updatedDefinitions.add(beanName);<br>                <span class="hljs-built_in">this</span>.beanDefinitionNames = updatedDefinitions;<br>                <span class="hljs-comment">// 从 manualSingletonNames 移除 beanName</span><br>                removeManualSingletonName(beanName);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Still in startup registration phase</span><br>            <span class="hljs-comment">// 添加到 BeanDefinition 到 beanDefinitionMap 中。</span><br>            <span class="hljs-built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<br>            <span class="hljs-comment">// 添加 beanName 到 beanDefinitionNames 中</span><br>            <span class="hljs-built_in">this</span>.beanDefinitionNames.add(beanName);<br>            <span class="hljs-comment">// 从 manualSingletonNames 移除 beanName</span><br>            removeManualSingletonName(beanName);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.frozenBeanDefinitionNames = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;5&gt; 重新设置 beanName 对应的缓存</span><br>    <span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-literal">null</span> || containsSingleton(beanName)) &#123;<br>        resetBeanDefinition(beanName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isConfigurationFrozen()) &#123;<br>        clearByTypeCache();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>过程：</p><ul><li><code>&lt;1&gt;</code> 对 BeanDefinition 进行校验，该校验也是注册过程中的最后一次校验了，主要是对 AbstractBeanDefinition 的 <code>methodOverrides</code> 属性进行校验。</li><li><code>&lt;2&gt;</code> 根据 <code>beanName</code> 从缓存中获取 BeanDefinition 对象。</li><li><code>&lt;3&gt;</code> 如果缓存中存在，则根据 <code>allowBeanDefinitionOverriding</code> 标志来判断是否允许覆盖。如果允许则直接覆盖。否则，抛出 BeanDefinitionStoreException 异常。</li><li><code>&lt;4&gt;</code> 若缓存中没有指定 <code>beanName</code> 的 BeanDefinition，则判断当前阶段是否已经开始了 Bean 的创建阶段？如果是，则需要对 beanDefinitionMap 进行加锁控制并发问题，否则直接设置即可。</li><li><code>&lt;5&gt;</code> 若缓存中存在该 <code>beanName</code> 或者单例 bean 集合中存在该 <code>beanName</code> ，则调用 <code>#resetBeanDefinition(String beanName)</code> 方法，重置 BeanDefinition 缓存。</li></ul><h5 id="registerAlias-方法"><a href="#registerAlias-方法" class="headerlink" title="registerAlias()方法"></a><code>registerAlias()</code>方法</h5><p>注册beanname的别名通过<code>BeanDefinitionRegistry.registerAlias()</code>方法进行注册的，实际执行的是<code>SimpleAliasRegistry.registerAlias()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerAlias</span><span class="hljs-params">(String name, String alias)</span> &#123;<br>    <span class="hljs-comment">// 校验 name 、 alias</span><br>    Assert.hasText(name, <span class="hljs-string">&quot;&#x27;name&#x27; must not be empty&quot;</span>);<br>    Assert.hasText(alias, <span class="hljs-string">&quot;&#x27;alias&#x27; must not be empty&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.aliasMap) &#123;<br>        <span class="hljs-comment">// name == alias 则去掉alias</span><br>        <span class="hljs-keyword">if</span> (alias.equals(name)) &#123;<br>            <span class="hljs-built_in">this</span>.aliasMap.remove(alias);<br>            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                logger.debug(<span class="hljs-string">&quot;Alias definition &#x27;&quot;</span> + alias + <span class="hljs-string">&quot;&#x27; ignored since it points to same name&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 获取 alias 已注册的 beanName</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">registeredName</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.aliasMap.get(alias);<br>            <span class="hljs-keyword">if</span> (registeredName != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 相同，则 return ，无需重复注册</span><br>                <span class="hljs-keyword">if</span> (registeredName.equals(name)) &#123;<br>                    <span class="hljs-comment">// An existing alias - no need to re-register</span><br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-comment">// 不允许覆盖，则抛出 IllegalStateException 异常</span><br>                <span class="hljs-keyword">if</span> (!allowAliasOverriding()) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Cannot define alias &#x27;&quot;</span> + alias + <span class="hljs-string">&quot;&#x27; for name &#x27;&quot;</span> +<br>                                                    name + <span class="hljs-string">&quot;&#x27;: It is already registered for name &#x27;&quot;</span> + registeredName + <span class="hljs-string">&quot;&#x27;.&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;Overriding alias &#x27;&quot;</span> + alias + <span class="hljs-string">&quot;&#x27; definition for registered name &#x27;&quot;</span> +<br>                                 registeredName + <span class="hljs-string">&quot;&#x27; with new target name &#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 校验，是否存在循环指向</span><br>            checkForAliasCircle(name, alias);<br>            <span class="hljs-built_in">this</span>.aliasMap.put(alias, name);<br>            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                logger.trace(<span class="hljs-string">&quot;Alias definition &#x27;&quot;</span> + alias + <span class="hljs-string">&quot;&#x27; registered for name &#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行循环检测：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForAliasCircle</span><span class="hljs-params">(String name, String alias)</span> &#123;<br><span class="hljs-keyword">if</span> (hasAlias(alias, name)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Cannot register alias &#x27;&quot;</span> + alias +<br><span class="hljs-string">&quot;&#x27; for name &#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;: Circular reference - &#x27;&quot;</span> +<br>name + <span class="hljs-string">&quot;&#x27; is a direct or indirect alias for &#x27;&quot;</span> + alias + <span class="hljs-string">&quot;&#x27; already&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasAlias</span><span class="hljs-params">(String name, String alias)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">registeredName</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.aliasMap.get(alias);<br>    <span class="hljs-keyword">return</span> ObjectUtils.nullSafeEquals(registeredName, name) || (registeredName != <span class="hljs-literal">null</span><br>                                                                &amp;&amp; hasAlias(name, registeredName));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一单元对话</title>
    <link href="/2022/06/11/%E6%96%B0%E6%A0%87%E6%97%A5%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E5%AF%B9%E8%AF%9D/"/>
    <url>/2022/06/11/%E6%96%B0%E6%A0%87%E6%97%A5%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E5%AF%B9%E8%AF%9D/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">第一单元对话</font></div><h4 id="这是什么呢"><a href="#这是什么呢" class="headerlink" title="这是什么呢"></a>这是什么呢</h4><p><strong>问</strong>：これは何ですか。</p><p><strong>答</strong>：それは貯金箱でしよ。</p><p><strong>知识点</strong>：</p><ul><li><p>貯<strong>「ちょ」</strong>金<strong>「きん」</strong>箱<strong>「ばこ」</strong>：储蓄罐</p></li><li><p>よ：类似与”哟“，那是储蓄罐哟…</p></li></ul><h4 id="询问价钱"><a href="#询问价钱" class="headerlink" title="询问价钱"></a>询问价钱</h4><p><strong>问</strong>：これはおいくらですか。</p><p><strong>答</strong>：こちらは3,000円・こちらは5,000円です。</p><p><strong>知识点</strong>：</p><ul><li>円<strong>「えん」</strong>，同”圆“的意思。</li><li>いくら多少钱，注意同いくつ多少岁区分。</li></ul><h4 id="询问东西在哪"><a href="#询问东西在哪" class="headerlink" title="询问东西在哪"></a>询问东西在哪</h4><p><strong>问</strong>：絵はがきはどこにありますか。</p><p><strong>答</strong>：あちらです。レジの横です。</p><p><strong>知识点</strong>：</p><ul><li><p>用到了<strong>「…は…にありますか」</strong><del>在</del>的句型。</p></li><li><p>絵はがき：明信片。</p></li><li><p>レジ：收银台。</p></li><li><p>横<strong>「よこ」</strong>：旁边。</p></li></ul><h4 id="选好要买的东西，付钱"><a href="#选好要买的东西，付钱" class="headerlink" title="选好要买的东西，付钱"></a>选好要买的东西，付钱</h4><p><strong>问</strong>：これをください。</p><p><strong>答</strong>：ありがとうございます。850円です。</p><p><strong>知识点</strong>：</p><ul><li>これをください。请给我这个，购买东西向售货员要某个东西时的句型。</li></ul><h4 id="别人介绍朋友给你，如何寒暄"><a href="#别人介绍朋友给你，如何寒暄" class="headerlink" title="别人介绍朋友给你，如何寒暄"></a>别人介绍朋友给你，如何寒暄</h4><p><strong>A</strong>：こちらはわたしの友人の王です。</p><p><strong>王</strong>：王です。どうぞよろしくお願いします。</p><p><strong>铃木</strong>：鈴木です。はじめまして。どうぞお願いします。</p><p><strong>知识点</strong>：</p><ul><li><p>…の…の…同位语</p></li><li><p>友人<strong>「よこ」</strong>：朋友。</p></li><li><p>王<strong>「おう」</strong>、願<strong>「ねが」</strong>、鈴木<strong>「すずき」</strong></p></li></ul><h4 id="询问对方的兴趣爱好"><a href="#询问对方的兴趣爱好" class="headerlink" title="询问对方的兴趣爱好"></a>询问对方的兴趣爱好</h4><p><strong>问</strong>：ご趣味は何ですか。</p><p><strong>答</strong>：趣味はテニスです。</p><p><strong>知识点</strong>：</p><ul><li>趣<strong>「しゅ」</strong>味<strong>「み」</strong>：爱好。</li><li>テニス：网球。</li><li>読<strong>「どく」</strong>書<strong>「しょ」</strong>：读书。</li><li>野<strong>「や」</strong>球<strong>「きゅう」</strong>：棒球</li></ul><h4 id="询问对方职业"><a href="#询问对方职业" class="headerlink" title="询问对方职业"></a>询问对方职业</h4><p><strong>问</strong>：失礼ですが・お仕事は何ですか。</p><p><strong>答</strong>：中国語の教師です。</p><p><strong>知识点</strong>：</p><ul><li>失<strong>「しつ」</strong>礼<strong>「れい」</strong></li><li>仕<strong>「し」</strong>事<strong>「ごと」</strong>：职业</li><li>中国語<strong>「ちゅうごくご」</strong>             教<strong>「きょう」</strong>師<strong>「し」</strong></li></ul><h4 id="被问及出生地"><a href="#被问及出生地" class="headerlink" title="被问及出生地"></a>被问及出生地</h4><p><strong>问</strong>：ご出身はどちらですか。</p><p><strong>答</strong>：大連です。</p><p><strong>知识点</strong>：</p><ul><li><p>出身<strong>「しゅっしん」</strong>：职业</p></li><li><p>大<strong>「だい」</strong>連<strong>「れん」</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>新标日</category>
      
      <category>上册</category>
      
      <category>对话</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>志村せんせい</title>
    <link href="/2022/06/11/%E5%BF%97%E6%9D%91%E3%81%9B%E3%82%93%E3%81%9B%E3%81%84/"/>
    <url>/2022/06/11/%E5%BF%97%E6%9D%91%E3%81%9B%E3%82%93%E3%81%9B%E3%81%84/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">日常语句积累</font></div><h4 id="mini形容词"><a href="#mini形容词" class="headerlink" title="mini形容词"></a>mini形容词</h4><hr><h5 id="忙しい：忙碌的"><a href="#忙しい：忙碌的" class="headerlink" title="忙しい：忙碌的"></a>忙しい：忙碌的</h5><blockquote><p>忙しくて、目が回りそう…</p><p>忙到晕头转向。</p></blockquote><p>汉字假名：</p><ul><li>忙：いそが        目：め</li></ul><p>知识点：</p><ul><li>接续句子的时候使用<strong>「くて」</strong>来连接。</li><li><strong>「回りそう」</strong>：快要…、差一点…。</li></ul><hr><h5 id="危ない：危险"><a href="#危ない：危险" class="headerlink" title="危ない：危险"></a>危ない：危险</h5><blockquote><p>危ないからコンセントに触らないで！</p><p>不要碰插座，因为很危险。</p></blockquote><p>汉字假名：</p><ul><li>危：あぶ　　触：さわ</li></ul><p>知识点：</p><ul><li><strong>「から」</strong>：因为。</li><li><strong>「コンセント」</strong>：插座。</li><li><strong>「触る」</strong>：碰。</li><li><strong>「ない形（否定形）」</strong>就是<strong>「触らないで」</strong>。</li><li><strong>「ない形（否定形）」</strong>后面加个<strong>「で」</strong>就是<strong>「请不要…」</strong>的意思。</li><li>要想更礼貌，末尾增加<strong>「ください」</strong>。</li></ul><hr><h5 id="美味しい：美味的"><a href="#美味しい：美味的" class="headerlink" title="美味しい：美味的"></a>美味しい：美味的</h5><blockquote><p>やっぱりチーズケーキが一番美味しい。</p><p>果然还是起司蛋糕最好吃。</p></blockquote><p>汉字假名：</p><ul><li>一番：いちばん　　美味：おい</li></ul><p>知识点：</p><ul><li><strong>「やっぱり」</strong>：果然还是…</li><li><strong>「一番」</strong>是一个副词，放在形容词前面，是<strong>「最」</strong>的意思。</li></ul><hr><h5 id="上手：擅长的"><a href="#上手：擅长的" class="headerlink" title="上手：擅长的"></a>上手：擅长的</h5><blockquote><p>歌がすごく上手ですね。</p><p>真的很会唱歌耶。</p></blockquote><p>汉字假名：</p><ul><li>歌：うた　　上手：じょうず</li></ul><p>知识点：</p><ul><li><p><strong>「歌が」</strong>：<strong>「唱歌，歌」</strong>的意思。</p></li><li><p><strong>「すごく」</strong>是一个副词，可以用来修饰形容词，是<strong>「非常，很…」</strong>的意思，类似的还有：<strong>「とても」</strong>，<strong>「すごい」</strong>。</p></li></ul><hr><h5 id="白い：白色的"><a href="#白い：白色的" class="headerlink" title="白い：白色的"></a>白い：白色的</h5><blockquote><p>黒い牛からも白い牛乳が出るのかな？</p><p>黑色的牛也可以挤出白色的牛奶吗？</p></blockquote><p>汉字假名：</p><ul><li>黒：くろ　　牛：うし　　白：しろ　　牛乳：きゅうにゅう　　出：で</li></ul><p>知识点：</p><ul><li><strong>「から」</strong>是<strong>「从…」</strong>的意思。</li><li><strong>「も」</strong>是一个助词，<strong>「也」</strong>的意思。</li><li><strong>「かな」</strong>是<strong>「想象或猜测」</strong>的语气，<strong>「な」</strong>就是自言自语的语气。</li></ul><hr><h5 id="広い：宽广的"><a href="#広い：宽广的" class="headerlink" title="広い：宽广的"></a>広い：宽广的</h5><blockquote><p>新しい部屋は広いんだ。</p><p>新房间好宽敞。</p></blockquote><p>汉字假名：</p><ul><li>新：あたら　　広：ひろ</li></ul><p>知识点：</p><ul><li><strong>「い」</strong>形容词后可以直接跟名词。</li><li>句末接<strong>「です」</strong>也可以，<strong>「んだ」</strong>是一种口语的说法，对别人说明或者解释的语气。</li></ul><hr><h5 id="不味い：难吃的"><a href="#不味い：难吃的" class="headerlink" title="不味い：难吃的"></a>不味い：难吃的</h5><blockquote><p>うわ、これ不味い。口语化</p><p>うわ、これは不味いです。比较正式</p><p>哇，这个好难吃啊。</p></blockquote><p>汉字假名：</p><ul><li>不味：まず</li></ul><p>知识点：</p><ul><li>很惊讶，吓到的时候，可以使用<strong>「うわ」</strong>。</li><li>感觉「不味い」太直接，可以委婉说法<strong>「口に合わない」</strong>。</li><li>「口に合わない」假名<strong>「くちにあわない」</strong>，不合口味，不喜欢这个味道。</li><li>稍微委婉可以说「美味しくない」假名<strong>「おいしくない」</strong>，不好吃。</li></ul><hr><h5 id="安い：便宜的"><a href="#安い：便宜的" class="headerlink" title="安い：便宜的"></a>安い：便宜的</h5><blockquote><p>このバッグ、安いけど可愛いね。</p><p>这个包包虽然有点便宜，但很可爱。</p></blockquote><p>汉字假名：</p><ul><li>安：やす　可愛：かわい</li></ul><p>知识点：</p><ul><li><strong>「けど」</strong>在两个形容词之间，是个逆接接续词，是<strong>「但」</strong>的意思。和<strong>「ですが」</strong>一样，不过前者偏向口语化，多用于平辈之间。</li></ul><h4 id="其他用语"><a href="#其他用语" class="headerlink" title="其他用语"></a>其他用语</h4><hr><h5 id="表达感谢"><a href="#表达感谢" class="headerlink" title="表达感谢"></a>表达感谢</h5><blockquote><p>ありがとうございます。正在进行时…例：别人正在帮你提行李。</p><p>ありがとうございました。过去式…例：别人帮你把行李放到了该放的地方。</p><p>本当にありがとうございます。更多的感谢—-本当に：真</p><p>「ありがとうね」、「どうもね」轻微的感谢</p></blockquote><hr><h5 id="总之…"><a href="#总之…" class="headerlink" title="总之…"></a>总之…</h5><blockquote><p>兎に角可愛い。</p><p>总之，非常可爱。</p></blockquote><p>汉字假名：</p><ul><li>兎に角：とにかく　　可愛：かわい</li></ul><p>知识点：</p><ul><li><strong>「兎に角」</strong>是<strong>「总之，无论如何」</strong>的意思。</li><li><strong>「兎に角」</strong>可以类似汉语随意组合，例：寂「さび」しい、美味しい、煩「うるさ」い</li></ul>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>课外</category>
      
      <category>日本老师</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象创建过程</title>
    <link href="/2022/06/11/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"/>
    <url>/2022/06/11/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">对象创建过程</font></div><p>碰到关键字<kbd>new</kbd>指令时，Java对象创建过程便开始,过程如下：</p><h5 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a><font style="color:rgb(69, 182, 247)">类加载检查</font></h5><ul><li><p>检查该<kbd>new</kbd>指令的参数是否能在常量池中定位到一个类的符号引用。</p></li><li><p>检查该类符号引用代表的类是否已被加载、解析和初始化过。</p></li></ul><h5 id="为对象分配内存（存在线程安全，需要重新做了解）"><a href="#为对象分配内存（存在线程安全，需要重新做了解）" class="headerlink" title="为对象分配内存（存在线程安全，需要重新做了解）"></a><font style="color:rgb(69, 182, 247)">为对象分配内存（存在线程安全，需要重新做了解）</font></h5><ul><li><p>虚拟机将为对象分配内存，即把一块确定大小的内存从堆中划分出来。（对象所需内存大小在类加载完成后便可以完全确定）</p><blockquote><p>内存分配方式</p></blockquote><p>a. 指针碰撞：java堆内存绝对规整，采用指针碰撞，分配形式，已使用内存在一边，未使用内存放一边，中间放一个作为分界点的指示器。</p><p><img src="/images/jichu/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E.png" alt="内存分配指针碰撞"></p><p>b. 空闲列表：java对内存不规整，采用空闲列表。分配形式，虚拟机维护着一个记录可用内存块的列表，在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表记录。</p><p><em><strong>分配方式取决于java堆内存是否规整，而堆内存是否规整取决于所采用的垃圾回收器是否带有压缩整理功能。</strong></em></p></li></ul><h5 id="将内存空间初始化为零值"><a href="#将内存空间初始化为零值" class="headerlink" title="将内存空间初始化为零值"></a><font style="color:rgb(69, 182, 247)">将内存空间初始化为零值</font></h5><ul><li>内存分配完成后，虚拟机需要将分配到的内存空间初始化为零（成员变量默认值，不包括对象头）</li></ul><h5 id="对对象进行必要的设置"><a href="#对对象进行必要的设置" class="headerlink" title="对对象进行必要的设置"></a><font style="color:rgb(69, 182, 247)">对对象进行必要的设置</font></h5><ul><li>设置这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的hash码、对象的GC分代年龄等信息，这些信息存放在对象头中。</li></ul><p>以上虚拟机角度对象初始化完毕，从开发角度，创建才刚开始，要进行我们的一系列初始化过程。</p><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>Java对象是如何存储在内存中的：对象头区、实例数据区、对齐填充区。</p><p><img src="/images/jichu/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.png" alt="对象内存分布"></p><h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a><font style="color:rgb(69, 182, 247)">对象头</font></h5><ul><li><p>对象自身运行时数据：hash码、GC分代年龄、锁状态标志、线程持有的锁等。</p></li><li><p>对象类型指针：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</p><p><em><strong>注意：</strong></em>如果对象是数组，对象头还会有一块用于记录数组长度的数据（从数组元数据无法确定数组的大小）。</p></li></ul><h5 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a><font style="color:rgb(69, 182, 247)">实例数据</font></h5><ul><li>存储对象真正有效的信息，即代码中定义的字段内容。</li></ul><h5 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a><font style="color:rgb(69, 182, 247)">对齐填充</font></h5><ul><li><p>存储的是占位符</p><p>因为对象的大小必须是8字节的整数倍，并且因为HotSpot VM的要求对象起始地址必须是8字节的整数倍，且对象头部分正好是8字节的倍数，因此，当对象实例数据部分没有对齐时（即对象的大小不是8字节的整数倍），就需要通过对齐填充来补全。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宕机重启服务器docker中redis无法启动</title>
    <link href="/2022/06/11/%E5%AE%95%E6%9C%BA%E9%87%8D%E5%90%AF%E6%9C%8D%E5%8A%A1%E5%99%A8docker%E4%B8%ADredis%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/"/>
    <url>/2022/06/11/%E5%AE%95%E6%9C%BA%E9%87%8D%E5%90%AF%E6%9C%8D%E5%8A%A1%E5%99%A8docker%E4%B8%ADredis%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">宕机重启服务器docker中redis启动失败</font></div><p>突然宕机重启服务器docker中redis启动失败。<br>启动如下警告：<br><img src="/images/redis/%E6%9C%8D%E5%8A%A1%E5%AE%95%E6%9C%BAredis%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5.png" alt="redis启动失败"><br>导致redis启动不了的主要是最后一行。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Bad <span class="hljs-built_in">file</span> <span class="hljs-built_in">format</span> reading <span class="hljs-keyword">the</span> append only <span class="hljs-built_in">file</span>: make <span class="hljs-keyword">a</span> backup <span class="hljs-keyword">of</span> your AOF <span class="hljs-built_in">file</span>, <span class="hljs-keyword">then</span> use ./redis-check-aof <span class="hljs-comment">--fix</span><br></code></pre></td></tr></table></figure><p>即：读取仅追加文件的错误文件格式：备份AOF文件，然后使用.&#x2F;redis-check-a of–fix<filename>–&gt;有一个AOF的备份文件（未改名称就是appendonly.aof），通过这个.&#x2F;redis-check-a of–fix<filename>还原。</p><h5 id="1、查找aof文件"><a href="#1、查找aof文件" class="headerlink" title="1、查找aof文件"></a>1、查找aof文件</h5><p>使用如下命令查看自定义映射目录：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker inspect redis</span><br></code></pre></td></tr></table></figure><p>可以得到如下内容，主要查看映射目录（红框）：<br><img src="/images/redis/data%E6%95%B0%E6%8D%AE%E6%98%A0%E5%B0%84%E7%9B%AE%E5%BD%95.png" alt="redis目录映射信息"><br>如果未做映射目录或者未找到.aof文件，使用如下命令查找：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> find / -name <span class="hljs-regexp">*.aof</span><br></code></pre></td></tr></table></figure><h5 id="2、查找redis-check-aof工具"><a href="#2、查找redis-check-aof工具" class="headerlink" title="2、查找redis-check-aof工具"></a>2、查找redis-check-aof工具</h5><p>好了，备份文件已找到，同理即可找到redis恢复工具(redis-check-aof）。:<br><img src="/images/redis/redis-check-aof.png" alt="redis-check-aof"><br>虽然查到两个，但是根据<kbd>docker inspect redis</kbd>查看到ID码：<br><img src="/images/redis/redis-check-aof-id.png" alt="redis-check-aof"></p><h5 id="3、修复文件"><a href="#3、修复文件" class="headerlink" title="3、修复文件"></a>3、修复文件</h5><p>执行命令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/redis-check-aof --fix /</span>etc<span class="hljs-regexp">/local/</span>docker<span class="hljs-regexp">/redis/</span>data/appendonly.aof<br></code></pre></td></tr></table></figure><p>出现<kbd>Continue? [y/N]:</kbd>提醒是否继续，输入<kbd>Y</kbd>即可，执行完成重启redis。<br>（注：因当时测试环境碰到该问题正要解决，同事直接把aof文件给删除重启了，所以没来的及亲自测试，但是该找到的都找到了，就差执行命令）。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十六、开启Bean加载</title>
    <link href="/2022/06/11/%E5%BC%80%E5%90%AFBean%E5%8A%A0%E8%BD%BD/"/>
    <url>/2022/06/11/%E5%BC%80%E5%90%AFBean%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">开启Bean加载</font></div><p>Spring IOC容器的作用：它会以某种方式加载 Configuration Metadata，将其解析注册到容器内部，然后回根据这些信息绑定整个系统的对象，最终组装成一个可用的基于轻量级容器的应用系统。具体流程分为两个阶段：</p><p><strong>1、容器初始化阶段</strong></p><ul><li>首先，通过某种方式加载 Configuration Metadata (主要是依据 Resource、ResourceLoader 两个体系) 。</li><li>然后，容器会对加载的 Configuration MetaData 进行解析，并将解析的信息组装成 BeanDefinition 。</li><li>最后，将 BeanDefinition 保存注册到相应的 BeanDefinitionRegistry 中。</li><li>至此，Spring IoC 的初始化工作完成。</li></ul><p><strong>2、加载Bean阶段</strong></p><ul><li>经过容器初始化阶段后，应用程序中定义的 bean 信息已经全部加载到系统中了，当我们显示或者隐式地调用 <code>BeanFactory.getBean(...)</code> 方法时，则会触发加载 Bean 阶段。</li><li>在这阶段，容器会首先检查所请求的对象是否已经初始化完成了，如果没有，则会根据注册的 Bean 信息实例化请求的对象，并为其注册依赖，然后将其返回给请求方。</li></ul><h4 id="getBean-方法"><a href="#getBean-方法" class="headerlink" title="getBean()方法"></a><code>getBean()</code>方法</h4><p>当我们显示或者隐式地调用 <code>BeanFactory.getBean(...)</code> 方法时，则会触发加载 Bean 阶段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">return</span> doGetBean(name, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>内部调用 <code>doGetBean(String name, final Class requiredType, Object[] args, boolean typeCheckOnly)</code> 方法。</p><h4 id="doGetBean-方法"><a href="#doGetBean-方法" class="headerlink" title="doGetBean()方法"></a><code>doGetBean()</code>方法</h4><p><code>getBean()</code>内部调用的是该方法，主要步骤总结在下方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> name 要获取 Bean 的名字</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> requiredType 要获取 bean 的类型</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> args 创建 Bean 时传递的参数。这个参数仅限于创建 Bean 时使用。</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> typeCheckOnly 是否为类型检</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> an instance of the bean</span><br><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> BeansException if the bean could not be created</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; T <span class="hljs-title function_">doGetBean</span><span class="hljs-params">(</span><br><span class="hljs-params">    String name, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="hljs-meta">@Nullable</span> Object[] args, <span class="hljs-type">boolean</span> typeCheckOnly)</span><br>    <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">* 通过 name 获取 beanName。这里不使用 name 直接作为 beanName 有两点原因：</span><br><span class="hljs-comment">* 1. name 可能会以 &amp; 字符开头，表明调用者想获取 FactoryBean 本身，而非 FactoryBean</span><br><span class="hljs-comment">* 实现类所创建的 bean。在 BeanFactory 中，FactoryBean 的实现类和其他的 bean 存储</span><br><span class="hljs-comment">* 方式是一致的，即 &lt;beanName, bean&gt;，beanName 中是没有 &amp; 这个字符的。所以我们需要</span><br><span class="hljs-comment">* 将 name 的首字符 &amp; 移除，这样才能从缓存里取到 FactoryBean 实例。</span><br><span class="hljs-comment">* 2. 若 name 是一个别名，则应将别名转换为具体的实例名，也就是 beanName。</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-comment">// ①获取beanName</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> transformedBeanName(name);<br>    Object beanInstance;<br><br>    <span class="hljs-comment">// ②从缓存中或者实例工厂中获取 Bean 对象</span><br>    <span class="hljs-comment">// Eagerly check singleton cache for manually registered singletons.</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">* 如果容器中包含对应的bean则直接返回</span><br><span class="hljs-comment">* 如果 sharedInstance = null，则说明缓存里没有对应的实例，表明这个实例还没创建。</span><br><span class="hljs-comment">* BeanFactory 并不会在一开始就将所有的单例 bean 实例化好，而是在调用 getBean 获取</span><br><span class="hljs-comment">* bean 时再实例化，也就是懒加载。</span><br><span class="hljs-comment">* getBean 方法有很多重载，比如 getBean(String name, Object... args)，我们在首次获取</span><br><span class="hljs-comment">* 某个 bean 时，可以传入用于初始化 bean 的参数数组（args），BeanFactory 会根据这些参数</span><br><span class="hljs-comment">* 去匹配合适的构造方法构造 bean 实例。当然，如果单例 bean 早已创建好，这里的 args 就没有</span><br><span class="hljs-comment">* 用了，BeanFactory 不会多次实例化单例 bean。</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-literal">null</span> &amp;&amp; args == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<span class="hljs-comment">//日志</span><br>            <span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;<br>                logger.trace(<span class="hljs-string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                logger.trace(<span class="hljs-string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">* 如果 sharedInstance 是普通的单例 bean，下面的方法会直接返回。但如果</span><br><span class="hljs-comment">* sharedInstance 是 FactoryBean 类型的，则需调用 getObject 工厂方法获取真正的</span><br><span class="hljs-comment">* bean 实例。如果用户想获取 FactoryBean 本身，这里也不会做特别的处理，直接返回</span><br><span class="hljs-comment">* 即可。毕竟 FactoryBean 的实现类本身也是一种 bean，只不过具有一点特殊的功能而已。</span><br><span class="hljs-comment">*/</span><br>        beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">* 如果上面的条件不满足，则表明 sharedInstance 可能为空，此时 beanName 对应的 bean</span><br><span class="hljs-comment">* 实例可能还未创建。这里还存在另一种可能，如果当前容器有父容器，beanName 对应的 bean 实例</span><br><span class="hljs-comment">* 可能是在父容器中被创建了，所以在创建���例前，需要先去父容器里检查一下。</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Fail if we&#x27;re already creating this bean instance:</span><br>        <span class="hljs-comment">// We&#x27;re assumably within a circular reference.</span><br>        <span class="hljs-comment">// 检查bean是否正在创建， BeanFactory 不缓存 Prototype 类型的 bean，无法处理该类型 bean 的循环依赖问题</span><br>        <span class="hljs-comment">// ③因为 Spring 只解决单例模式下得循环依赖，在原型模式下如果存在循环依赖则会抛出异常。</span><br>        <span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName);<br>        &#125;<br><br>        <span class="hljs-comment">// Check if bean definition exists in this factory.</span><br>        <span class="hljs-comment">// ④如果 sharedInstance = null，则到父容器中查找 bean 实例</span><br>        <span class="hljs-type">BeanFactory</span> <span class="hljs-variable">parentBeanFactory</span> <span class="hljs-operator">=</span> getParentBeanFactory();<br>        <span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;<br>            <span class="hljs-comment">// Not found -&gt; check parent.</span><br>            <span class="hljs-comment">// 获取 name 对应的 beanName，如果 name 是以 &amp; 字符开头，则返回 &amp; + beanName</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">nameToLookup</span> <span class="hljs-operator">=</span> originalBeanName(name);<br>            <span class="hljs-keyword">if</span> (parentBeanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory) &#123;<br>                <span class="hljs-keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(<br>                    nameToLookup, requiredType, args, typeCheckOnly);<br>            &#125;<br>            <span class="hljs-comment">// 根据 args 是否为空，以决定调用父容器哪个方法获取 bean</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// Delegation to parent with explicit args.</span><br>                <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// No args -&gt; delegate to standard getBean method.</span><br>                <span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//⑤标记当前bean正在创建中，alreadyCreated中</span><br>        <span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;<br>            markBeanAsCreated(beanName);<br>        &#125;<br><br>        <span class="hljs-type">StartupStep</span> <span class="hljs-variable">beanCreation</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.beans.instantiate&quot;</span>)<br>            .tag(<span class="hljs-string">&quot;beanName&quot;</span>, name);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span>) &#123;<br>                beanCreation.tag(<span class="hljs-string">&quot;beanType&quot;</span>, requiredType::toString);<br>            &#125;<br>            <span class="hljs-comment">// ⑥从容器中获取 beanName 相应的 GenericBeanDefinition 对象，并将其转换为 RootBeanDefinition 对象</span><br>            <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br>            <span class="hljs-comment">//检查是否为抽象类</span><br>            checkMergedBeanDefinition(mbd, beanName, args);<br><br>            <span class="hljs-comment">// Guarantee initialization of beans that the current bean depends on.</span><br>            <span class="hljs-comment">// ⑦处理所依赖的 bean，先创建需要在当前bean创建之前必须创建的bean，通过@DependsOn(&quot;eventListener&quot;)注解设置该信息， 检查是否有 dependsOn 依赖，如果有则先初始化所依赖的 bean</span><br>            String[] dependsOn = mbd.getDependsOn();<br>            <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">* 检测是否存在 depends-on 循环依赖，若存在则抛异常。比如 A 依赖 B，</span><br><span class="hljs-comment">* B 又依赖 A，他们的配置如下：</span><br><span class="hljs-comment">*   &lt;bean id=&quot;beanA&quot; class=&quot;BeanA&quot; depends-on=&quot;beanB&quot;&gt;</span><br><span class="hljs-comment">*   &lt;bean id=&quot;beanB&quot; class=&quot;BeanB&quot; depends-on=&quot;beanA&quot;&gt;</span><br><span class="hljs-comment">* beanA 要求 beanB 在其之前被创建，但 beanB 又要求 beanA 先于它</span><br><span class="hljs-comment">* 创建。这个时候形成了循环，对于 depends-on 循环，Spring 会直接</span><br><span class="hljs-comment">* 抛出异常</span><br><span class="hljs-comment">*/</span><br>                    <span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<span class="hljs-string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-comment">// 缓存依赖调用，注册依赖记录</span><br>                    registerDependentBean(dep, beanName);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 加载 depends-on 依赖</span><br>                        getBean(dep);<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<span class="hljs-string">&quot;&#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// Create bean instance.</span><br>            <span class="hljs-comment">// ⑧创建 bean 实例</span><br>            <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<span class="hljs-comment">// 单例模式</span><br>                <span class="hljs-comment">/*jiu</span><br><span class="hljs-comment">* 这里并没有直接调用 createBean 方法创建 bean 实例，而是通过</span><br><span class="hljs-comment">* getSingleton(String, ObjectFactory) 方法获取 bean 实例。</span><br><span class="hljs-comment">* getSingleton(String, ObjectFactory) 方法会在内部调用</span><br><span class="hljs-comment">* ObjectFactory 的 getObject() 方法创建 bean，并会在创建完成后，</span><br><span class="hljs-comment">* 将 bean 放入缓存中。</span><br><span class="hljs-comment">*/</span><br>                sharedInstance = getSingleton(beanName, () -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 创建 bean 实例</span><br>                        <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>                        <span class="hljs-comment">// 显式从单例缓存中删除 Bean 实例</span><br>                        <span class="hljs-comment">// 因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它。</span><br>                        destroySingleton(beanName);<br>                        <span class="hljs-keyword">throw</span> ex;<br>                    &#125;<br>                &#125;);<br>                <span class="hljs-comment">// 如果 bean 是 FactoryBean 类型，则调用工厂方法获取真正的 bean 实例。否则直接返回 bean 实例</span><br>                beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<span class="hljs-comment">// 原型模式</span><br>                <span class="hljs-comment">// It&#x27;s a prototype -&gt; create a new instance.</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">prototypeInstance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    beforePrototypeCreation(beanName);<br>                    prototypeInstance = createBean(beanName, mbd, args);<br>                &#125;jiu<br>                <span class="hljs-keyword">finally</span> &#123;<br>                    afterPrototypeCreation(beanName);<br>                &#125;<br>                beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 从指定的 scope 下创建 bean</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">scopeName</span> <span class="hljs-operator">=</span> mbd.getScope();<br>                <span class="hljs-keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No scope name defined for bean ´&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                &#125;<br>                <span class="hljs-type">Scope</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.scopes.get(scopeName);<br>                <span class="hljs-keyword">if</span> (scope == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                &#125;jiu<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">Object</span> <span class="hljs-variable">scopedInstance</span> <span class="hljs-operator">=</span> scope.get(beanName, () -&gt; &#123;<br>                        beforePrototypeCreation(beanName);<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>                        &#125;<br>                        <span class="hljs-keyword">finally</span> &#123;<br>                            afterPrototypeCreation(beanName);<br>                        &#125;<br>                    &#125;);<br>                    beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScopeNotActiveException</span>(beanName, scopeName, ex);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>            beanCreation.tag(<span class="hljs-string">&quot;exception&quot;</span>, ex.getClass().toString());<br>            beanCreation.tag(<span class="hljs-string">&quot;message&quot;</span>, String.valueOf(ex.getMessage()));<br>            cleanupAfterBeanCreationFailure(beanName);<br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            beanCreation.end();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);<br>&#125;<br>jiu<br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>&lt;T&gt; T <span class="hljs-title function_">adaptBeanInstance</span><span class="hljs-params">(String name, Object bean, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; requiredType)</span> &#123;<br>    <span class="hljs-comment">// Check if required type matches the type of the actual bean instance.</span><br>    <span class="hljs-comment">// ⑨检查需要的类型是否符合 bean 的实际类型，如果需要进行类型转换，则在此处进行转换。</span><br>    <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">convertedBean</span> <span class="hljs-operator">=</span> getTypeConverter().convertIfNecessary(bean, requiredType);<br>            <span class="hljs-keyword">if</span> (convertedBean == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());<br>            &#125;<br>            <span class="hljs-keyword">return</span> (T) convertedBean;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (TypeMismatchException ex) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                logger.trace(<span class="hljs-string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27; to required type &#x27;&quot;</span> +<br>                             ClassUtils.getQualifiedName(requiredType) + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (T) bean;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>doGetBean()</code>的流程：</strong></p><p>①、获取beanName</p><p>②、从缓存中或者实例工厂中获取 Bean 对象</p><p>③、原型模式依赖检查</p><p>④、从父类容器加载bean</p><p>⑤、标记当前bean为正在创建或者创建中</p><p>⑥、获取BeanDefinition</p><p>⑦、依赖bean处理</p><p>⑧、不同作用域的bean实例化</p><p>⑨、类型转换</p><h5 id="获取beanName"><a href="#获取beanName" class="headerlink" title="获取beanName"></a>获取beanName</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> transformedBeanName(name);<br></code></pre></td></tr></table></figure><p>该<code>name</code>，不一定是<code>beanName</code>，可能是<code>aliasName</code>，也有可能是<code>FactoryBean</code>。所以需要执行该方法对<code>name</code>进行转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> String <span class="hljs-title function_">transformedBeanName</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">return</span> canonicalName(BeanFactoryUtils.transformedBeanName(name));<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="BeanFactoryUtils-transformedBeanName-name"><a href="#BeanFactoryUtils-transformedBeanName-name" class="headerlink" title="BeanFactoryUtils.transformedBeanName(name)"></a><code>BeanFactoryUtils.transformedBeanName(name)</code></h6><p>先调用<code>BeanFactoryUtils.transformedBeanName(name)</code>方法，去除<code>FactoryBean</code>的修饰符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// BeanFactoryUtils.java</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 缓存 &#123;<span class="hljs-doctag">@link</span> #transformedBeanName(String)&#125; 已经转换好的结果。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; transformedBeanNameCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 去除 FactoryBean 的修饰符 &amp;</span><br><span class="hljs-comment"> * 如果 name 以 “&amp;” 为前缀，那么会去掉该 &quot;&amp;&quot; 。</span><br><span class="hljs-comment"> * 例如，name = &quot;&amp;studentService&quot; ，则会是 name = &quot;studentService&quot;。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">transformedBeanName</span><span class="hljs-params">(String name)</span> &#123;<br>    Assert.notNull(name, <span class="hljs-string">&quot;&#x27;name&#x27; must not be null&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) &#123;<span class="hljs-comment">//FACTORY_BEAN_PREFIX=&amp;</span><br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-comment">// computeIfAbsent 方法，分成两种情况：</span><br>    <span class="hljs-comment">//      1. 未存在，则进行计算执行，并将结果添加到缓存、</span><br>    <span class="hljs-comment">//      2. 已存在，则直接返回，无需计算。</span><br>    <span class="hljs-keyword">return</span> transformedBeanNameCache.computeIfAbsent(name, beanName -&gt; &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());<br>        &#125; <span class="hljs-keyword">while</span> (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));<br>        <span class="hljs-keyword">return</span> beanName;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>tip：假设配置了一个 FactoryBean 的名字为 <code>&quot;abc&quot;</code> ，那么获取 FactoryBean 创建的 Bean 时，使用 <code>&quot;abc&quot;</code> ，如果获取 FactoryBean 本身，使用 <code>&quot;$abc&quot;</code> 。</p></blockquote><p><code>transformedBeanNameCache</code> 集合的存在，是为了缓存转换后的结果。下次再获取相同的 <code>name</code> 时，直接返回缓存中的结果即可。</p><h6 id="canonicalName"><a href="#canonicalName" class="headerlink" title="canonicalName(...)"></a><code>canonicalName(...)</code></h6><p>其次执行<code>canonicalName(String name)</code>：<code>AbstractBeanFactory</code>继承了<code>FactoryBeanRegistrySupport</code>，<code>FactoryBeanRegistrySupport</code>继承了<code>DefaultSingletonBeanRegistry</code>，<code>DefaultSingletonBeanRegistry</code>继承了<code>SimpleAliasRegistry</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//SimpleAliasRegistry.java</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">canonicalName</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">canonicalName</span> <span class="hljs-operator">=</span> name;<br>    <span class="hljs-comment">// Handle aliasing...</span><br>    String resolvedName;<br>    <span class="hljs-comment">// 循环，从 aliasMap 中，获取到最终的 beanName</span><br>    <span class="hljs-comment">// 例如，别名 A 指向名称为 B 的 bean 则返回 B，若 别名 A 指向别名 B，别名 B 指向名称为 C 的 bean，则返回 C。</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        resolvedName = <span class="hljs-built_in">this</span>.aliasMap.get(canonicalName);<br>        <span class="hljs-keyword">if</span> (resolvedName != <span class="hljs-literal">null</span>) &#123;<br>            canonicalName = resolvedName;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (resolvedName != <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">return</span> canonicalName;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="从缓存中或者实例工厂中获取-Bean-对象"><a href="#从缓存中或者实例工厂中获取-Bean-对象" class="headerlink" title="从缓存中或者实例工厂中获取 Bean 对象"></a>从缓存中或者实例工厂中获取 Bean 对象</h5><p>相应代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 如果容器中包含对应的bean则直接返回</span><br><span class="hljs-comment">* 如果 sharedInstance = null，则说明缓存里没有对应的实例，表明这个实例还没创建。</span><br><span class="hljs-comment">* BeanFactory 并不会在一开始就将所有的单例 bean 实例化好，而是在调用 getBean 获取</span><br><span class="hljs-comment">* bean 时再实例化，也就是懒加载。</span><br><span class="hljs-comment">* getBean 方法有很多重载，比如 getBean(String name, Object... args)，我们在首次获取</span><br><span class="hljs-comment">* 某个 bean 时，可以传入用于初始化 bean 的参数数组（args），BeanFactory 会根据这些参数</span><br><span class="hljs-comment">* 去匹配合适的构造方法构造 bean 实例。当然，如果单例 bean 早已创建好，这里的 args 就没有</span><br><span class="hljs-comment">* 用了，BeanFactory 不会多次实例化单例 bean。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-literal">null</span> &amp;&amp; args == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<span class="hljs-comment">//日志</span><br>        <span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            logger.trace(<span class="hljs-string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 如果 sharedInstance 是普通的单例 bean，下面的方法会直接返回。但如果</span><br><span class="hljs-comment">* sharedInstance 是 FactoryBean 类型的，则需调用 getObject 工厂方法获取真正的</span><br><span class="hljs-comment">* bean 实例。如果用户想获取 FactoryBean 本身，这里也不会做特别的处理，直接返回</span><br><span class="hljs-comment">* 即可。毕竟 FactoryBean 的实现类本身也是一种 bean，只不过具有一点特殊的功能而已。</span><br><span class="hljs-comment">*/</span><br>    beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>单例模式的 Bean 在整个过程中只会被创建一次。第一次创建后会将该 Bean 加载到缓存中。后面，在获取 Bean 就会直接从单例缓存中获取。</p><p>如果从缓存中得到了 Bean 对象，则需要调用 <code>getObjectForBeanInstance(Object beanInstance, String name, String beanName, RootBeanDefinition mbd)</code> 方法，对 Bean 进行实例化处理。因为，缓存中记录的是最原始的 Bean 状态，我们得到的不一定是我们<strong>最终</strong>想要的 Bean 。</p><h5 id="原型模式依赖检查"><a href="#原型模式依赖检查" class="headerlink" title="原型模式依赖检查"></a>原型模式依赖检查</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><span class="hljs-comment">// 因为 Spring 只解决单例模式下得循环依赖，在原型模式下如果存在循环依赖则会抛出异常。</span><br><span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName);<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring 只处理单例模式下得循环依赖，对于原型模式的循环依赖直接抛出异常。主要原因还是在于，<strong>和 Spring 解决循环依赖的策略有关</strong>。</p><ul><li>对于<strong>单例( Singleton )模式</strong>， Spring 在创建 Bean 的时候并不是等 Bean 完全创建完成后才会将 Bean 添加至缓存中，而是不等 Bean 创建完成就会将创建 Bean 的 ObjectFactory 提早加入到缓存中，这样一旦下一个 Bean 创建的时候需要依赖 bean 时则直接使用 ObjectFactroy 。</li><li>但是<strong>原型( Prototype )模式</strong>，我们知道是没法使用缓存的，所以 Spring 对原型模式的循环依赖处理策略则是不处理。</li></ul><h5 id="从父类容器加载bean"><a href="#从父类容器加载bean" class="headerlink" title="从父类容器加载bean"></a>从父类容器加载bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><br><span class="hljs-comment">// 如果当前容器中没有找到，则从父类容器中加载</span><br><span class="hljs-comment">// Check if bean definition exists in this factory.</span><br><span class="hljs-type">BeanFactory</span> <span class="hljs-variable">parentBeanFactory</span> <span class="hljs-operator">=</span> getParentBeanFactory();<br><span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;<br>    <span class="hljs-comment">// Not found -&gt; check parent.</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">nameToLookup</span> <span class="hljs-operator">=</span> originalBeanName(name);<br>    <span class="hljs-comment">// 如果，父类容器为 AbstractBeanFactory ，直接递归查找</span><br>    <span class="hljs-keyword">if</span> (parentBeanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory) &#123;<br>        <span class="hljs-keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(<br>                nameToLookup, requiredType, args, typeCheckOnly);<br>    <span class="hljs-comment">// 用明确的 args 从 parentBeanFactory 中，获取 Bean 对象</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Delegation to parent with explicit args.</span><br>        <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);<br>    <span class="hljs-comment">// 用明确的 requiredType 从 parentBeanFactory 中，获取 Bean 对象</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// No args -&gt; delegate to standard getBean method.</span><br>        <span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);<br>    <span class="hljs-comment">// 直接使用 nameToLookup 从 parentBeanFactory 获取 Bean 对象</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果<strong>当前</strong>容器缓存中没有相对应的 BeanDefinition 对象，则会尝试从父类工厂（<code>parentBeanFactory</code>）中加载，然后再去递归调用 <code>getBean(...)</code> 方法。</p><h5 id="标记当前bean为正在创建或者创建中"><a href="#标记当前bean为正在创建或者创建中" class="headerlink" title="标记当前bean为正在创建或者创建中"></a>标记当前bean为正在创建或者创建中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><br><span class="hljs-comment">// 如果不是仅仅做类型检查则是创建bean，这里需要记录</span><br><span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;<br>markBeanAsCreated(beanName);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="获取BeanDefinition"><a href="#获取BeanDefinition" class="headerlink" title="获取BeanDefinition"></a>获取BeanDefinition</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><br><span class="hljs-comment">// 从容器中获取 beanName 相应的 GenericBeanDefinition 对象，并将其转换为 RootBeanDefinition 对象</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br><span class="hljs-comment">// 检查给定的合并的 BeanDefinition</span><br>checkMergedBeanDefinition(mbd, beanName, args);<br></code></pre></td></tr></table></figure><p>因为从 XML 配置文件中读取到的 Bean 信息是存储在GenericBeanDefinition 中的。但是，所有的 Bean 后续处理都是针对于 RootBeanDefinition 的，所以这里需要进行一个转换。转换的同时，如果父类 bean 不为空的话，则会一并合并父类的属性。</p><h5 id="依赖bean处理"><a href="#依赖bean处理" class="headerlink" title="依赖bean处理"></a>依赖bean处理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><br><span class="hljs-comment">// Guarantee initialization of beans that the current bean depends on.</span><br><span class="hljs-comment">// 处理所依赖的 bean</span><br>String[] dependsOn = mbd.getDependsOn();<br><span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;<br>        <span class="hljs-comment">// 若给定的依赖 bean 已经注册为依赖给定的 bean</span><br>        <span class="hljs-comment">// 即循环依赖的情况，抛出 BeanCreationException 异常</span><br>        <span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                    <span class="hljs-string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 缓存依赖调用</span><br>        registerDependentBean(dep, beanName);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 递归处理依赖 Bean</span><br>            getBean(dep);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                    <span class="hljs-string">&quot;&#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>每个 Bean 都不是单独工作的，它会依赖其他 Bean，其他 Bean 也会依赖它。</li><li>对于依赖的 Bean ，它会优先加载，所以，在 Spring 的加载顺序中，在初始化某一个 Bean 的时候，首先会初始化这个 Bean 的依赖。</li></ul><h5 id="不同作用域的bean实例化"><a href="#不同作用域的bean实例化" class="headerlink" title="不同作用域的bean实例化"></a>不同作用域的bean实例化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><br><span class="hljs-comment">// bean 实例化</span><br><span class="hljs-comment">// Create bean instance.</span><br><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123; <span class="hljs-comment">// 单例模式</span><br>    sharedInstance = getSingleton(beanName, () -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>            <span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span><br>            <span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span><br>            <span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span><br>            <span class="hljs-comment">// 显式从单例缓存中删除 Bean 实例</span><br>            <span class="hljs-comment">// 因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它。 TODO 芋艿</span><br>            destroySingleton(beanName);<br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125;<br>    &#125;);<br>    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123; <span class="hljs-comment">// 原型模式</span><br>    <span class="hljs-comment">// It&#x27;s a prototype -&gt; create a new instance.</span><br>    Object prototypeInstance;<br>    <span class="hljs-keyword">try</span> &#123;<br>        beforePrototypeCreation(beanName);<br>        prototypeInstance = createBean(beanName, mbd, args);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        afterPrototypeCreation(beanName);<br>    &#125;<br>    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 从指定的 scope 下创建 bean</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">scopeName</span> <span class="hljs-operator">=</span> mbd.getScope();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Scope</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.scopes.get(scopeName);<br>    <span class="hljs-keyword">if</span> (scope == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>    &#125;<span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">scopedInstance</span> <span class="hljs-operator">=</span> scope.get(beanName, () -&gt; &#123;<br>            beforePrototypeCreation(beanName);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                afterPrototypeCreation(beanName);<br>            &#125;<br>        &#125;);<br>        bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(beanName,<br>                <span class="hljs-string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="hljs-string">&quot;&#x27; is not active for the current thread; consider &quot;</span> + <span class="hljs-string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,<br>                ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Spring Bean 的作用域默认为 singleton 。当然，还有其他作用域，如 prototype、request、session 等。</li><li>不同的作用域会有不同的初始化策略。</li></ul><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><br><span class="hljs-comment">// 检查需要的类型是否符合 bean 的实际类型</span><br><span class="hljs-comment">// Check if required type matches the type of the actual bean instance.</span><br><span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 执行转换</span><br>        <span class="hljs-type">T</span> <span class="hljs-variable">convertedBean</span> <span class="hljs-operator">=</span> getTypeConverter().convertIfNecessary(bean, requiredType);<br>        <span class="hljs-comment">// 转换失败，抛出 BeanNotOfRequiredTypeException 异常</span><br>        <span class="hljs-keyword">if</span> (convertedBean == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());<br>        &#125;<br>        <span class="hljs-keyword">return</span> convertedBean;<br>    &#125; <span class="hljs-keyword">catch</span> (TypeMismatchException ex) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27; to required type &#x27;&quot;</span> +<br>                    ClassUtils.getQualifiedName(requiredType) + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在调用 <code>#doGetBean(...)</code> 方法时，<code>有一个 requiredTyp</code>e 参数。该参数的功能就是将返回的 Bean 转换为 <code>requiredType</code> 类型。</li><li>当然就一般而言，我们是不需要进行类型转换的，也就是 <code>requiredType</code> 为空（比如 <code>#getBean(String name)</code> 方法）。但有，可能会存在这种情况，比如我们返回的 Bean 类型为 String ，我们在使用的时候需要将其转换为 Integer，那么这个时候 <code>requiredType</code> 就有用武之地了。<strong>当然我们一般是不需要这样做的</strong>。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上是对Spring Bean加载过程的概览，主要过程：</p><ol><li>分析从缓存中获取单例 Bean ，以及对 Bean 的实例中获取对象。</li><li>如果从单例缓存中获取 Bean ，Spring 是怎么加载的呢？所以第二部分是分析 Bean 加载，以及 Bean 的依赖处理。</li><li>Bean 已经加载了，依赖也处理完毕了，第三部分则分析各个作用域的 Bean 初始化过程。</li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八、bean标签的解析准备</title>
    <link href="/2022/06/11/%E5%BC%80%E5%90%AF%E8%A7%A3%E6%9E%90%E8%BF%9B%E7%A8%8B/"/>
    <url>/2022/06/11/%E5%BC%80%E5%90%AF%E8%A7%A3%E6%9E%90%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">bean标签的解析准备</font></div><p><code>bean</code>标签解析过程：</p><h4 id="processBeanDefinition-方法"><a href="#processBeanDefinition-方法" class="headerlink" title="processBeanDefinition()方法"></a><code>processBeanDefinition()</code>方法</h4><p><code>DefaultBeanDefinitionDocumentReader.processBeanDefinition()</code>：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">protected void process<span class="hljs-constructor">BeanDefinition(Element <span class="hljs-params">ele</span>, BeanDefinitionParserDelegate <span class="hljs-params">delegate</span>)</span> &#123;<br>   <span class="hljs-comment">// 进行 bean 元素解析。</span><br>   <span class="hljs-comment">//如之前所说BeanDefinitionParserDelegate负责解析`BeanDifinition`对象，定义了解析XML Element的各种方法</span><br>   <span class="hljs-comment">// &lt;1&gt; 如果解析成功，则返回 BeanDefinitionHolder 对象。而 BeanDefinitionHolder 为 name 和 alias（数组） 的 BeanDefinition 对象</span><br>   <span class="hljs-comment">// 如果解析失败，则返回 null 。错误由 ProblemReporter 处理（方法注释说明了）。</span><br>   BeanDefinitionHolder bdHolder = delegate.parse<span class="hljs-constructor">BeanDefinitionElement(<span class="hljs-params">ele</span>)</span>;<br>   <span class="hljs-keyword">if</span> (bdHolder != null) &#123;<br>      <span class="hljs-comment">// &lt;2&gt; 进行自定义标签处理</span><br>      bdHolder = delegate.decorate<span class="hljs-constructor">BeanDefinitionIfRequired(<span class="hljs-params">ele</span>, <span class="hljs-params">bdHolder</span>)</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">// Register the final decorated instance.</span><br>         <span class="hljs-comment">// &lt;3&gt; 进行 BeanDefinition 的注册</span><br>         <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BeanDefinitionReaderUtils</span>.</span></span>register<span class="hljs-constructor">BeanDefinition(<span class="hljs-params">bdHolder</span>, <span class="hljs-params">getReaderContext</span>()</span>.get<span class="hljs-constructor">Registry()</span>);<br>      &#125;<br>      catch (BeanDefinitionStoreException ex) &#123;<br>         get<span class="hljs-constructor">ReaderContext()</span>.error(<span class="hljs-string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +<br>               bdHolder.get<span class="hljs-constructor">BeanName()</span> + <span class="hljs-string">&quot;&#x27;&quot;</span>, ele, ex);<br>      &#125;<br>      <span class="hljs-comment">// Send registration event.</span><br>      <span class="hljs-comment">// &lt;4&gt; 发出响应事件，通知相关的监听器，已完成该 Bean 标签的解析。</span><br>      get<span class="hljs-constructor">ReaderContext()</span>.fire<span class="hljs-constructor">ComponentRegistered(<span class="hljs-params">new</span> BeanComponentDefinition(<span class="hljs-params">bdHolder</span>)</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="parseBeanDefinitionElement-方法"><a href="#parseBeanDefinitionElement-方法" class="headerlink" title="parseBeanDefinitionElement()方法"></a><code>parseBeanDefinitionElement()</code>方法</h4><p>bean元素解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title function_">parseBeanDefinitionElement</span><span class="hljs-params">(Element ele, <span class="hljs-meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> ele.getAttribute(ID_ATTRIBUTE);<span class="hljs-comment">//id</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">nameAttr</span> <span class="hljs-operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);<span class="hljs-comment">//name</span><br>    <span class="hljs-comment">//别名集合</span><br>    List&lt;String&gt; aliases = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;<br>        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);<br>        aliases.addAll(Arrays.asList(nameArr));<br>    &#125;<br>    <span class="hljs-comment">//beanName优先使用id</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> id;<br>    <span class="hljs-keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;<br>        <span class="hljs-comment">//其次使用aliases的第一个并移出aliases集合</span><br>        beanName = aliases.remove(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +<br>                         <span class="hljs-string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="hljs-string">&quot; as aliases&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (containingBean == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 检查 beanName 的唯一性</span><br>        checkNameUniqueness(beanName, aliases, ele);<br>    &#125;<br>    <span class="hljs-comment">// 解析属性，构造 AbstractBeanDefinition 对象</span><br>    <span class="hljs-type">AbstractBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);<br>    <span class="hljs-keyword">if</span> (beanDefinition != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// beanName ，再次，使用 beanName 生成规则</span><br>        <span class="hljs-keyword">if</span> (!StringUtils.hasText(beanName)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (containingBean != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 生成唯一的 beanName</span><br>                    beanName = BeanDefinitionReaderUtils.generateBeanName(<br>                        beanDefinition, <span class="hljs-built_in">this</span>.readerContext.getRegistry(), <span class="hljs-literal">true</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 生成唯一的 beanName</span><br>                    beanName = <span class="hljs-built_in">this</span>.readerContext.generateBeanName(beanDefinition);<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">beanClassName</span> <span class="hljs-operator">=</span> beanDefinition.getBeanClassName();<br>                    <span class="hljs-keyword">if</span> (beanClassName != <span class="hljs-literal">null</span> &amp;&amp;<br>                        beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;<br>                        !<span class="hljs-built_in">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;<br>                        aliases.add(beanClassName);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                    logger.trace(<span class="hljs-string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +<br>                                 <span class="hljs-string">&quot;using generated bean name [&quot;</span> + beanName + <span class="hljs-string">&quot;]&quot;</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                error(ex.getMessage(), ele);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// &lt;5&gt; 创建 BeanDefinitionHolder 对象</span><br>        String[] aliasesArray = StringUtils.toStringArray(aliases);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionHolder</span>(beanDefinition, beanName, aliasesArray);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处还未真正意义开始bean解析，只是解析前的准备工作，解析id、name属性，确定aliases集合，检测beanName是否唯一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//保存已经使用过的beanname</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; usedNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkNameUniqueness</span><span class="hljs-params">(String beanName, List&lt;String&gt; aliases, Element beanElement)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">foundName</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 寻找是否 beanName 已经使用</span><br>    <span class="hljs-keyword">if</span> (StringUtils.hasText(beanName) &amp;&amp; <span class="hljs-built_in">this</span>.usedNames.contains(beanName)) &#123;<br>        foundName = beanName;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (foundName == <span class="hljs-literal">null</span>) &#123;<br>        foundName = CollectionUtils.findFirstMatch(<span class="hljs-built_in">this</span>.usedNames, aliases);<br>    &#125;<br>    <span class="hljs-comment">// 若已使用，使用 problemReporter 提示错误</span><br>    <span class="hljs-keyword">if</span> (foundName != <span class="hljs-literal">null</span>) &#123;<br>        error(<span class="hljs-string">&quot;Bean name &#x27;&quot;</span> + foundName + <span class="hljs-string">&quot;&#x27; is already used in this &lt;beans&gt; element&quot;</span>, beanElement);<br>    &#125;<br><br>    <span class="hljs-comment">// 添加到 usedNames 集合</span><br>    <span class="hljs-built_in">this</span>.usedNames.add(beanName);<br>    <span class="hljs-built_in">this</span>.usedNames.addAll(aliases);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>beanName命名规则</code></strong></p><ol><li><p><strong>id不为空，beanName &#x3D; id；</strong></p></li><li><p><strong>id为空，aliases不为空，beanName为aliases的第一个元素；</strong></p></li><li><p><strong>如果id、aliases都为空，使用默认规则命名：</strong></p><p>spring通过核心接口<code>BeanNameGenerator</code>来生成beanName，目前只有两个具体实现类：<code>AnnotationBeanNameGenerator</code>（注解）和<code>DefaultBeanNameGenerator</code>（XML文件）。</p><p><strong>XML方式生成规则：<code>类名＋&#39;#&#39;+数字</code>，</strong></p><p><strong>注解方式生成规则：取短类名，即不包含路径，如果短类名长度大于１，且第一个第二个字母大写，则直接使用短类名，</strong>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">com.jievhaha.TEst<br>则beanName=TEst<br></code></pre></td></tr></table></figure><p><strong>其他情况短类名首字母小写。</strong></p></li></ol><h5 id="parseBeanDefinitionElement-方法-1"><a href="#parseBeanDefinitionElement-方法-1" class="headerlink" title="parseBeanDefinitionElement()方法"></a><code>parseBeanDefinitionElement()</code>方法</h5><p>解析bean标签的所有属性和子元素，并创建返回<code>AbstractBeanDefinition</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> AbstractBeanDefinition <span class="hljs-title function_">parseBeanDefinitionElement</span><span class="hljs-params">(</span><br><span class="hljs-params">    Element ele, String beanName, <span class="hljs-meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;<br><br>    <span class="hljs-built_in">this</span>.parseState.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanEntry</span>(beanName));<br><br>    <span class="hljs-comment">// 解析 class 属性</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;<br>        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();<br>    &#125;<br>    <span class="hljs-comment">// 解析 parent 属性</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;<br>        parent = ele.getAttribute(PARENT_ATTRIBUTE);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建 AbstractBeanDefinition 实例</span><br>        <span class="hljs-type">AbstractBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> createBeanDefinition(className, parent);<br><br>        <span class="hljs-comment">// 解析默认 bean 的各种属性</span><br>        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);<br>        <span class="hljs-comment">// 提取 description</span><br>        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));<br><br>        <span class="hljs-comment">// 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，</span><br>        <span class="hljs-comment">// 解析出来以后的信息都放到 bd 的属性中</span><br><br>        <span class="hljs-comment">// 解析元数据 &lt;meta /&gt;</span><br>        parseMetaElements(ele, bd);<br>        <span class="hljs-comment">// 解析 lookup-method 属性 &lt;lookup-method /&gt;</span><br>        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());<br>        <span class="hljs-comment">// 解析 replaced-method 属性 &lt;replaced-method /&gt;</span><br>        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());<br><br>        <span class="hljs-comment">// 解析构造函数参数 &lt;constructor-arg /&gt;</span><br>        parseConstructorArgElements(ele, bd);<br>        <span class="hljs-comment">// 解析 property 子元素 &lt;property /&gt;</span><br>        parsePropertyElements(ele, bd);<br>        <span class="hljs-comment">// 解析 qualifier 子元素 &lt;qualifier /&gt;</span><br>        parseQualifierElements(ele, bd);<br><br>        bd.setResource(<span class="hljs-built_in">this</span>.readerContext.getResource());<br>        bd.setSource(extractSource(ele));<br><br>        <span class="hljs-keyword">return</span> bd;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br>        error(<span class="hljs-string">&quot;Bean class [&quot;</span> + className + <span class="hljs-string">&quot;] not found&quot;</span>, ele, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (NoClassDefFoundError err) &#123;<br>        error(<span class="hljs-string">&quot;Class that bean class [&quot;</span> + className + <span class="hljs-string">&quot;] depends on not found&quot;</span>, ele, err);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        error(<span class="hljs-string">&quot;Unexpected failure during bean definition parsing&quot;</span>, ele, ex);<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-built_in">this</span>.parseState.pop();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="createBeanDefinition-方法"><a href="#createBeanDefinition-方法" class="headerlink" title="createBeanDefinition()方法"></a><code>createBeanDefinition()</code>方法</h5><p>创建 AbstractBeanDefinition 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> AbstractBeanDefinition <span class="hljs-title function_">createBeanDefinition</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String className, <span class="hljs-meta">@Nullable</span> String parentName)</span><br>    <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br><br>    <span class="hljs-keyword">return</span> BeanDefinitionReaderUtils.createBeanDefinition(<br>        parentName, className, <span class="hljs-built_in">this</span>.readerContext.getBeanClassLoader());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx安装</title>
    <link href="/2022/06/11/%E5%AE%89%E8%A3%85nginx/"/>
    <url>/2022/06/11/%E5%AE%89%E8%A3%85nginx/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">nginx安装</font></div><p>安装nginx之前要保证各种依赖已经安装完成。<br>看自己想安装在哪个目录，我所有软件安装在<code>/home/muzili/Documents/apps/</code>下。</p><h4 id="安装pcre"><a href="#安装pcre" class="headerlink" title="安装pcre"></a>安装<code>pcre</code></h4><h5 id="获取pcre压缩包"><a href="#获取pcre压缩包" class="headerlink" title="获取pcre压缩包"></a>获取pcre压缩包</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz<br></code></pre></td></tr></table></figure><p>这样可能会比较慢，最好自己copy下载地址其他地方下载然后上传到相应位置。</p><h5 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf pcre-8.37.tar.gz<br></code></pre></td></tr></table></figure><h5 id="进入解压后目录，执行-configure"><a href="#进入解压后目录，执行-configure" class="headerlink" title="进入解压后目录，执行./configure"></a>进入解压后目录，执行<code>./configure</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd pcre-8.37<br>./configure<br></code></pre></td></tr></table></figure><p>最后可能会提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">configure: error: You need a C++ compiler for C++ support<br></code></pre></td></tr></table></figure><p>那就安装依赖重新执行<code>./configure</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install -y gcc gcc-c++<br></code></pre></td></tr></table></figure><p>执行成功会提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">pcre-8.37 configuration summary:<br>    Install prefix .................. : /usr/local<br>    C preprocessor .................. : gcc -E<br>    C compiler ...................... : gcc<br>    C++ preprocessor ................ : g++ -E<br>    C++ compiler .................... : g++<br>    Linker .......................... : /usr/bin/ld -m elf_x86_64<br>    省略...<br></code></pre></td></tr></table></figure><h5 id="执行make-amp-make-install进行编译安装"><a href="#执行make-amp-make-install进行编译安装" class="headerlink" title="执行make &amp; make install进行编译安装"></a>执行<code>make &amp; make install</code>进行编译安装</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shelll">make &amp; make install<br></code></pre></td></tr></table></figure><h5 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pcre-config --version<br>返回：8.37（版本号）<br></code></pre></td></tr></table></figure><h4 id="安装编译工具及库文件"><a href="#安装编译工具及库文件" class="headerlink" title="安装编译工具及库文件"></a>安装编译工具及库文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel<br></code></pre></td></tr></table></figure><h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><h5 id="下载nginx压缩包"><a href="#下载nginx压缩包" class="headerlink" title="下载nginx压缩包"></a>下载nginx压缩包</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget http://nginx.org/download/nginx-1.12.2.tar.gz<br></code></pre></td></tr></table></figure><h5 id="解压文件-1"><a href="#解压文件-1" class="headerlink" title="解压文件"></a>解压文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -xzvf nginx-1.12.2.tar.gz<br></code></pre></td></tr></table></figure><h5 id="进入解压后目录，执行-configure-1"><a href="#进入解压后目录，执行-configure-1" class="headerlink" title="进入解压后目录，执行./configure"></a>进入解压后目录，执行<code>./configure</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd nginx-1.12.2<br>./configure<br></code></pre></td></tr></table></figure><h5 id="执行make-amp-make-install进行编译安装-1"><a href="#执行make-amp-make-install进行编译安装-1" class="headerlink" title="执行make &amp; make install进行编译安装"></a>执行<code>make &amp; make install</code>进行编译安装</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shelll">make &amp; make install<br></code></pre></td></tr></table></figure><p>安装成功后会在<code>/usr/local/</code>下多个<code>nginx</code>目录（如果执行<code>./configure</code>没有配置参数的话默认是这个目录）</p><h5 id="进入usr-local-nginx-sbin启动nginx"><a href="#进入usr-local-nginx-sbin启动nginx" class="headerlink" title="进入usr/local/nginx/sbin启动nginx"></a>进入<code>usr/local/nginx/sbin</code>启动nginx</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ./nginx<br></code></pre></td></tr></table></figure><p>因为默认端口号是80，好像nginx端口号小于1024需要root权限，不然会报</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx: [emerg] bind() to 0.0.0.0:80 failed (13: Permission denied)<br></code></pre></td></tr></table></figure><p>大于1024的需要查看防火墙是否开放端口，没有的话需要开放端口即可</p><h5 id="启动成功后浏览器输入nginx服务器IP"><a href="#启动成功后浏览器输入nginx服务器IP" class="headerlink" title="启动成功后浏览器输入nginx服务器IP"></a>启动成功后浏览器输入nginx服务器IP</h5><p>假如服务启动成功，但是访问失败，可能还是nginx端口未开放，手动开放重启防火墙和服务即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">（查看开放的端口）</span><br>sudo firewall-cmd --list-ports <br><span class="hljs-meta prompt_">#</span><span class="language-bash">开放80端口</span><br>sudo firewall-cmd --zone=public --add-port=80/tcp --permanent<br><span class="hljs-meta prompt_">#</span><span class="language-bash">重启防火墙</span><br>sudo firewall-cmd --reload<br></code></pre></td></tr></table></figure><p>访问成功可看到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Welcome to nginx!<br>省略...<br></code></pre></td></tr></table></figure><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>因为执行命令都要切入<code>/usr/local/nginx/sbin</code>目录才能执行命令，为了方便，直接配置到全局环境变量中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/profile<br><span class="hljs-meta prompt_">#</span><span class="language-bash">加入如下内容（因为之前自己配了java的，故在后边补加）</span><br>export PATH=$JAVA_HOME/bin:$PATH:/usr/local/nginx/sbin<br><span class="hljs-meta prompt_">#</span><span class="language-bash">或者之前没配过其他的，直接</span><br>export PATH=/usr/local/nginx/sbin<br><span class="hljs-meta prompt_">#</span><span class="language-bash">重新加载使其生效</span><br>source /etc/profile<br></code></pre></td></tr></table></figure><p>然后就可以在任意地方使用<code>nginx</code>命令了，不知道什么原因默认低于1024的端口报没有权限，切到<code>root</code>用户或者<code>sudo nginx</code>还是会报找不到nginx命令。<br>所以建议修改nginx默认端口（我改的1025）。<br>假如修改了环境变量之前服务已经启动，直接执行<code>nginx</code>会提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx: [emerg] bind() to 0.0.0.0:1025 failed (98: Address already in use)<br></code></pre></td></tr></table></figure><p>或者执行<code>nginx -s reload</code>没返回</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[muzili@jiev ~]$ nginx -s reload<br>[muzili@jiev ~]$ <br></code></pre></td></tr></table></figure><p>说明配置成功，可以任意地方执行<code>nginx</code>命令了。</p><p>以上是单机版。<br>假如为了做到高可用，那除了按照以上多几台nginx服务器外，还需要额外安装<code>keepalived</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y keepalived<br></code></pre></td></tr></table></figure><p>安装成功后会在<code>/etc</code>目录生成<code>keepalived</code>目录。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十九、各scope的Bean创建</title>
    <link href="/2022/06/11/%E5%90%84scope%E7%9A%84Bean%E5%88%9B%E5%BB%BA/"/>
    <url>/2022/06/11/%E5%90%84scope%E7%9A%84Bean%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">各scope的Bean创建</font></div><p>﻿在 Spring 中存在着不同的 scope，默认是 singleton ，还有 prototype、request 等其他的 scope 。</p><h4 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a><code>singleton</code></h4><p>Spring 的 scope 默认为 singleton ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstractBeanFactory.java</span><br><br><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<span class="hljs-comment">// 单例模式</span><br>    sharedInstance = getSingleton(beanName, () -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>            destroySingleton(beanName);<br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125;<br>    &#125;);<br>    beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果缓存中<strong>不存在</strong>bean呢？则需要从头开始加载 Bean ，这个过程由 <code>getSingleton(String beanName, ObjectFactory singletonFactory)</code> 方法来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultSingletonBeanRegistry.java</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;<br>    Assert.notNull(beanName, <span class="hljs-string">&quot;Bean name must not be null&quot;</span>);<br>    <span class="hljs-comment">// 全局加锁</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>        <span class="hljs-comment">// &lt;1&gt; 从缓存中检查一遍</span><br>        <span class="hljs-comment">// 因为 singleton 模式其实就是复用已经创建的 bean 所以这步骤必须检查</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>        <span class="hljs-comment">//  为空，开始加载过程</span><br>        <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.singletonsCurrentlyInDestruction) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationNotAllowedException</span>(beanName,<br>                                                          <span class="hljs-string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +<br>                                                          <span class="hljs-string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                logger.debug(<span class="hljs-string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// &lt;2&gt; 加载前置处理</span><br>            beforeSingletonCreation(beanName);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">newSingleton</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">recordSuppressedExceptions</span> <span class="hljs-operator">=</span> (<span class="hljs-built_in">this</span>.suppressedExceptions == <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<br>                <span class="hljs-built_in">this</span>.suppressedExceptions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// &lt;3&gt; 初始化 bean</span><br>                <span class="hljs-comment">// 这个过程其实是调用 createBean() 方法</span><br>                singletonObject = singletonFactory.getObject();<br>                newSingleton = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<br>                <span class="hljs-comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span><br>                <span class="hljs-comment">// if yes, proceed with it since the exception indicates that state.</span><br>                singletonObject = <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>                <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">throw</span> ex;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (BeanCreationException ex) &#123;<br>                <span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<br>                    <span class="hljs-keyword">for</span> (Exception suppressedException : <span class="hljs-built_in">this</span>.suppressedExceptions) &#123;<br>                        ex.addRelatedCause(suppressedException);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">throw</span> ex;<br>            &#125;<br>            <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<br>                    <span class="hljs-built_in">this</span>.suppressedExceptions = <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-comment">// &lt;4&gt; 后置处理</span><br>                afterSingletonCreation(beanName);<br>            &#125;<br>            <span class="hljs-comment">// &lt;5&gt; 加入缓存中</span><br>            <span class="hljs-keyword">if</span> (newSingleton) &#123;<br>                addSingleton(beanName, singletonObject);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singletonObject;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSingleton</span><span class="hljs-params">(String beanName, Object singletonObject)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>        <span class="hljs-built_in">this</span>.singletonObjects.put(beanName, singletonObject);<span class="hljs-comment">//添加到单例 bean 的缓存。</span><br>        <span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<span class="hljs-comment">//从单例 bean Factory 的缓存中移除。</span><br>        <span class="hljs-built_in">this</span>.earlySingletonObjects.remove(beanName);<span class="hljs-comment">//从预加载单例 bean 的缓存中移除。</span><br>        <span class="hljs-built_in">this</span>.registeredSingletons.add(beanName);<span class="hljs-comment">//添加到已经注册的单例缓存。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个过程并没有真正创建 Bean 对象，仅仅只是做了一部分准备和预处理步骤。真正获取单例 bean 的方法，其实是由 <code>&lt;3&gt;</code> 处的 <code>singletonFactory.getObject()</code> 这部分代码块来实现，而 <code>singletonFactory</code> 由回调方法产生。</p><p>该方法做的准备：</p><ul><li><code>&lt;1&gt;</code> 处，再次检查缓存是否已经加载过，如果已经加载了则直接返回，否则开始加载过程。</li><li><code>&lt;2&gt;</code> 处，调用 <code>beforeSingletonCreation(String beanName)</code> 方法，记录加载单例 bean 之前的加载状态，即前置处理，标记为正在创建中。在从缓存中获取单例Bean已经介绍。</li><li><code>&lt;3&gt;</code> 处，调用参数传递的 ObjectFactory 的 <code>getObject()</code> 方法，实例化 bean 。</li><li><code>&lt;4&gt;</code> 处，调用 <code>afterSingletonCreation(String beanName)</code> 方法，进行加载单例后的后置处理，删除标记为正在创建中。</li><li><code>&lt;5&gt;</code> 处，调用 <code>addSingleton(String beanName, Object singletonObject)</code> 方法，将结果记录并加入值���存中，同时删除加载 bean 过程中所记录的一些辅助状态。</li></ul><p>加载完单例Bean后，调用 <code>getObjectForBeanInstance(Object beanInstance, String name, String beanName, RootBeanDefinition mbd)</code> 方法，从 bean 实例中获取对象。在从缓存中获取单例Bean已经介绍。</p><h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><code>prototype</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstractBeanFactory.java</span><br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<span class="hljs-comment">// 原型模式</span><br>    <span class="hljs-comment">// It&#x27;s a prototype -&gt; create a new instance.</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">prototypeInstance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// &lt;1&gt; 加载前置处理</span><br>        beforePrototypeCreation(beanName);<br>        <span class="hljs-comment">// &lt;2&gt; 创建 Bean 对象</span><br>        prototypeInstance = createBean(beanName, mbd, args);<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// &lt;3&gt; 加载后置处理</span><br>        afterPrototypeCreation(beanName);<br>    &#125;<br>    <span class="hljs-comment">// &lt;4&gt; 从 Bean 实例中获取对象</span><br>    beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);<br>&#125;<br></code></pre></td></tr></table></figure><p>原型模式的初始化过程很简单：直接创建一个<strong>新</strong>的 Bean 的实例就可以了。</p><ul><li>在 <code>&lt;1&gt;</code> 处，调用 <code>beforePrototypeCreation(String beanName)</code> 方法，记录加载原型模式 bean 之前的加载状态，即前置处理。</li><li>在 <code>&lt;2&gt;</code> 处，调用 <code>createBean(String beanName)</code> 方法，创建一个 bean 实例对象。</li><li>在 <code>&lt;3&gt;</code> 处，调用 <code>afterSingletonCreation(String beanName)</code> 方法，进行加载原型模式 bean 后的后置处理。</li><li>在 <code>&lt;4&gt;</code> 处，加载了单例 bean 后，调用 <code>getObjectForBeanInstance(Object beanInstance, String name, String beanName, RootBeanDefinition mbd)</code> 方法，从 bean 实例中获取对象。在从缓存中获取单例Bean已经介绍。</li></ul><h5 id="beforePrototypeCreation-方法"><a href="#beforePrototypeCreation-方法" class="headerlink" title="beforePrototypeCreation()方法"></a><code>beforePrototypeCreation()</code>方法</h5><p>注册为当前正在创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforePrototypeCreation</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">curVal</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.prototypesCurrentlyInCreation.get();<br>    <span class="hljs-keyword">if</span> (curVal == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.prototypesCurrentlyInCreation.set(beanName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curVal <span class="hljs-keyword">instanceof</span> String) &#123;<br>        Set&lt;String&gt; beanNameSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(<span class="hljs-number">2</span>);<br>        beanNameSet.add((String) curVal);<br>        beanNameSet.add(beanName);<br>        <span class="hljs-built_in">this</span>.prototypesCurrentlyInCreation.set(beanNameSet);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        Set&lt;String&gt; beanNameSet = (Set&lt;String&gt;) curVal;<br>        beanNameSet.add(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="afterPrototypeCreation-方法"><a href="#afterPrototypeCreation-方法" class="headerlink" title="afterPrototypeCreation()方法"></a><code>afterPrototypeCreation()</code>方法</h5><p>标记为不在创建中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPrototypeCreation</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">curVal</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.prototypesCurrentlyInCreation.get();<br>    <span class="hljs-keyword">if</span> (curVal <span class="hljs-keyword">instanceof</span> String) &#123;<br>        <span class="hljs-built_in">this</span>.prototypesCurrentlyInCreation.remove();<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curVal <span class="hljs-keyword">instanceof</span> Set) &#123;<br>        Set&lt;String&gt; beanNameSet = (Set&lt;String&gt;) curVal;<br>        beanNameSet.remove(beanName);<br>        <span class="hljs-keyword">if</span> (beanNameSet.isEmpty()) &#123;<br>            <span class="hljs-built_in">this</span>.prototypesCurrentlyInCreation.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="其他scope"><a href="#其他scope" class="headerlink" title="其他scope"></a>其他scope</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 从指定的 scope 下创建 bean</span><br>    <span class="hljs-comment">// 获得 scopeName 对应的 Scope 对象</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">scopeName</span> <span class="hljs-operator">=</span> mbd.getScope();<br>    <span class="hljs-keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No scope name defined for bean ´&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">Scope</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.scopes.get(scopeName);<br>    <span class="hljs-keyword">if</span> (scope == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 从指定的 scope 下创建 bean</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">scopedInstance</span> <span class="hljs-operator">=</span> scope.get(beanName, () -&gt; &#123;<br>            <span class="hljs-comment">// 加载前置处理</span><br>            beforePrototypeCreation(beanName);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 创建 Bean 对象</span><br>                <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>            &#125;<br>            <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 加载后缀处理</span><br>                afterPrototypeCreation(beanName);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 从 Bean 实例中获取对象</span><br>        beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScopeNotActiveException</span>(beanName, scopeName, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>核心流程和原型模式一样</strong>，只不过获取 bean 实例是由 <code>Scope.get(String name, ObjectFactory objectFactory)</code> 方法来实现，处理方式和单例模式一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SimpleThreadScope.java</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadScope =<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadLocal</span>&lt;Map&lt;String, Object&gt;&gt;(<span class="hljs-string">&quot;SimpleThreadScope&quot;</span>) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Map&lt;String, Object&gt; <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> &#123;<br>    <span class="hljs-comment">// 获取 scope 缓存</span><br>    Map&lt;String, Object&gt; scope = <span class="hljs-built_in">this</span>.threadScope.get();<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">scopedObject</span> <span class="hljs-operator">=</span> scope.get(name);<br>    <span class="hljs-keyword">if</span> (scopedObject == <span class="hljs-literal">null</span>) &#123;<br>        scopedObject = objectFactory.getObject();<br>        <span class="hljs-comment">// 加入缓存</span><br>        scope.put(name, scopedObject);<br>    &#125;<br>    <span class="hljs-keyword">return</span> scopedObject;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>比较重要的两个：</p><ul><li><code>createBean(String beanName, RootBeanDefinition mbd, Object[] args)</code> 方法。</li><li><code>getObjectForBeanInstance(Object beanInstance, String name, String beanName, RootBeanDefinition mbd)</code> 方法。在从缓存中获取单例Bean已经介绍。</li></ul><p>以上两个方法在单例、原型、其他模式中都有调用。不过在单例和其他模式中，<code>createBean()</code>是以回调方式出现的。</p><blockquote><p><code>getObjectForBeanInstance()</code>这个方法主要是验证以下我们得到的 bean 的正确性，其实就是检测当前 bean 是否是 FactoryBean 类型的 bean 。</p><p>如果是，那么需要调用该 bean 对应的 FactoryBean 实例的 <code>getObject()</code> 方法，作为返回值。</p><p>无论是从缓存中获得到的 bean 还是通过不同的 scope 策略加载的 bean 都只是最原始的 bean 状态，并不一定就是我们最终想要的 bean。</p><p>举个例子，加入我们需要对工厂 bean 进行处理，那么这里得到的其实是工厂 bean 的初始状态，但是我们真正需要的是工厂 bean 中定义 <code>factory-method</code> 方法中返回的 bean，而 <code>getObjectForBeanInstance(Object beanInstance, String name, String beanName, RootBeanDefinition mbd)</code> 方法，就是完成这个工作的。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper单机</title>
    <link href="/2022/06/11/%E5%AE%89%E8%A3%85%E5%8D%95%E6%9C%BAZookeeper/"/>
    <url>/2022/06/11/%E5%AE%89%E8%A3%85%E5%8D%95%E6%9C%BAZookeeper/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">zookeeper单机</font></div><p>下载路径（没用官网，用的镜像）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.6.2/<br></code></pre></td></tr></table></figure><p>3.5及以上注意下载好正确的tar.gz包。</p><p>假如是官网的话，好像就是<code>.bin.tar.gz</code>包。</p><p><img src="/images/zookeeper/%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84.png" alt="安装路径"></p><p>从<code>3.5.5</code>开始，带有bin名称的包才是我们想要的下载可以直接使用的里面有编译后的二进制的包，而之前的<strong>普通的tar.gz</strong>的包里面是<strong>只是源码</strong>的包无法直接使用。</p><p>不然安装的是tar.gz的话，启动的时候提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Starting zookeeper ... FAILED TO START<br></code></pre></td></tr></table></figure><p>日志里提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">错误: 找不到或无法加载主类 org.apache.zookeeper.server.quorum.QuorumPeerMain<br></code></pre></td></tr></table></figure><p>下载好<code>-bin.tar.gz</code>包，解压到自己喜欢的目录。</p><ol><li><p>修改配置文件，运行的时候，默认运行的是<code>zoo.cfg</code>，而<code>conf</code>包下是<code>zoo_sample.cfg</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">当然先进入解压的安装包里的conf文件夹</span><br>cp zoo_sample.cfg zoo.cfg<br></code></pre></td></tr></table></figure></li><li><p>自己喜欢的目录创建<code>data</code>目录，修改配置文件内容（当然不改也可以）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">the directory <span class="hljs-built_in">where</span> the snapshot is stored.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">do</span> not use /tmp <span class="hljs-keyword">for</span> storage, /tmp here is just</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">example sakes.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">大概12行的位置</span><br>dataDir=/home/muzili/文档/apps/apache-zookeeper-3.6.2-bin/data<br></code></pre></td></tr></table></figure></li><li><p>启动，切到<code>bin</code>目录，然后启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./zkServer.sh start<br></code></pre></td></tr></table></figure><p>启动成功后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ZooKeeper JMX enabled by default<br>Using config: /home/muzili/文档/apps/apache-zookeeper-3.6.2-bin/bin/../conf/zoo.cfg<br>Starting zookeeper ... STARTED<br></code></pre></td></tr></table></figure><p>也可使用如下命令查看zookeeper状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./zkServer.sh status<br></code></pre></td></tr></table></figure><p>启动成功结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ZooKeeper JMX enabled by default<br>Using config: /home/muzili/文档/apps/apache-zookeeper-3.6.2-bin/bin/../conf/zoo.cfg<br>Client port found: 2181. Client address: localhost. Client SSL: false.<br>Mode: standalone<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二十六、加载Bean总结</title>
    <link href="/2022/06/11/%E5%8A%A0%E8%BD%BDBean%E6%80%BB%E7%BB%93/"/>
    <url>/2022/06/11/%E5%8A%A0%E8%BD%BDBean%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">加载Bean总结</font></div><p>开头十几篇分析了一个配置文件经历哪些过程转变成<code>BeanDefinition</code>对象，但这不是真正的bean，它仅仅包含了我们所需bean的信息。</p><p>之后十篇分析了bean的加载，此处做个总结。</p><p>bean的初始化起点，在我们第一次（显示或者隐式）调用<code>getBean()</code>来开启：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><span class="hljs-comment">// 内部调用 doGetBean(...) 方法。</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">return</span> doGetBean(name, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">protected</span> &lt;T&gt; T <span class="hljs-title function_">doGetBean</span><span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="hljs-meta">@Nullable</span> Object[] args, <span class="hljs-type">boolean</span> typeCheckOnly)</span><span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"> * &lt;1&gt;</span><br><span class="hljs-comment"> * 通过 name 获取 beanName。这里不使用 name 直接作为 beanName 有两点原因：</span><br><span class="hljs-comment"> * 1. name 可能会以 &amp; 字符开头，表明调用者想获取 FactoryBean 本身，而非 FactoryBean</span><br><span class="hljs-comment"> * 实现类所创建的 bean。在 BeanFactory 中，FactoryBean 的实现类和其他的 bean 存储</span><br><span class="hljs-comment"> * 方式是一致的，即 &lt;beanName, bean&gt;，beanName 中是没有 &amp; 这个字符的。所以我们需要</span><br><span class="hljs-comment"> * 将 name 的首字符 &amp; 移除，这样才能从缓存里取到 FactoryBean 实例。</span><br><span class="hljs-comment"> * 2. 若 name 是一个别名，则应将别名转换为具体的实例名，也就是 beanName。</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> transformedBeanName(name);<br>    Object beanInstance;<br><br>    <span class="hljs-comment">// 从缓存中或者实例工厂中获取 Bean 对象</span><br>    <span class="hljs-comment">// Eagerly check singleton cache for manually registered singletons.</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 如果容器中包含对应的bean则直接返回</span><br><span class="hljs-comment"> * 如果 sharedInstance = null，则说明缓存里没有对应的实例，表明这个实例还没创建。</span><br><span class="hljs-comment"> * BeanFactory 并不会在一开始就将所有的单例 bean 实例化好，而是在调用 getBean 获取</span><br><span class="hljs-comment"> * bean 时再实例化，也就是懒加载。</span><br><span class="hljs-comment"> * getBean 方法有很多重载，比如 getBean(String name, Object... args)，我们在首次获取</span><br><span class="hljs-comment"> * 某个 bean 时，可以传入用于初始化 bean 的参数数组（args），BeanFactory 会根据这些参数</span><br><span class="hljs-comment"> * 去匹配合适的构造方法构造 bean 实例。当然，如果单例 bean 早已创建好，这里的 args 就没有</span><br><span class="hljs-comment"> * 用了，BeanFactory 不会多次实例化单例 bean。</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-literal">null</span> &amp;&amp; args == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<span class="hljs-comment">//日志</span><br>            <span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;<br>                logger.trace(<span class="hljs-string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +<br>                             <span class="hljs-string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                logger.trace(<span class="hljs-string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment"> * &lt;2&gt;</span><br><span class="hljs-comment"> * 如果 sharedInstance 是普通的单例 bean，下面的方法会直接返回。但如果</span><br><span class="hljs-comment"> * sharedInstance 是 FactoryBean 类型的，则需调用 getObject 工厂方法获取真正的</span><br><span class="hljs-comment"> * bean 实例。如果用户想获取 FactoryBean 本身，这里也不会做特别的处理，直接返回</span><br><span class="hljs-comment"> * 即可。毕竟 FactoryBean 的实现类本身也是一种 bean，只不过具有一点特殊的功能而已。</span><br><span class="hljs-comment"> */</span><br>        beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 如果上面的条件不满足，则表明 sharedInstance 可能为空，此时 beanName 对应的 bean</span><br><span class="hljs-comment"> * 实例可能还未创建。这里还存在另一种可能，如果当前容器有父容器，beanName 对应的 bean 实例</span><br><span class="hljs-comment"> * 可能是在父容器中被创建了，所以在创建实例前，需要先去父容器里检查一下。</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Fail if we&#x27;re already creating this bean instance:</span><br>        <span class="hljs-comment">// We&#x27;re assumably within a circular reference.</span><br>        <span class="hljs-comment">// 检查bean是否正在创建， BeanFactory 不缓存 Prototype 类型的 bean，无法处理该类型 bean 的循环依赖问题</span><br>        <span class="hljs-comment">// &lt;3&gt; 因为 Spring 只解决单例模式下得循环依赖，在原型模式下如果存在循环依赖则会抛出异常。</span><br>        <span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName);<br>        &#125;<br><br>        <span class="hljs-comment">// Check if bean definition exists in this factory.</span><br>        <span class="hljs-comment">// &lt;4&gt; 如果 sharedInstance = null，则到父容器中查找 bean 实例</span><br>        <span class="hljs-type">BeanFactory</span> <span class="hljs-variable">parentBeanFactory</span> <span class="hljs-operator">=</span> getParentBeanFactory();<br>        <span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;<br>            <span class="hljs-comment">// Not found -&gt; check parent.</span><br>            <span class="hljs-comment">// 获取 name 对应的 beanName，如果 name 是以 &amp; 字符开头，则返回 &amp; + beanName</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">nameToLookup</span> <span class="hljs-operator">=</span> originalBeanName(name);<br>            <span class="hljs-keyword">if</span> (parentBeanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory) &#123;<br>                <span class="hljs-keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(<br>                    nameToLookup, requiredType, args, typeCheckOnly);<br>            &#125;<br>            <span class="hljs-comment">// 根据 args 是否为空，以决定调用父容器哪个方法获取 bean</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// Delegation to parent with explicit args.</span><br>                <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// No args -&gt; delegate to standard getBean method.</span><br>                <span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//&lt;5&gt; 标记当前bean正在创建中，alreadyCreated中</span><br>        <span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;<br>            markBeanAsCreated(beanName);<br>        &#125;<br><br>        <span class="hljs-type">StartupStep</span> <span class="hljs-variable">beanCreation</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.beans.instantiate&quot;</span>)<br>            .tag(<span class="hljs-string">&quot;beanName&quot;</span>, name);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span>) &#123;<br>                beanCreation.tag(<span class="hljs-string">&quot;beanType&quot;</span>, requiredType::toString);<br>            &#125;<br>            <span class="hljs-comment">// &lt;6&gt;</span><br>            <span class="hljs-comment">// 从容器中获取 beanName 相应的 GenericBeanDefinition 对象，并将其转换为 RootBeanDefinition 对象</span><br>            <span class="hljs-comment">// 因为从 XML 配置文件中读取到的 Bean 信息是存储在GenericBeanDefinition 中的。但是，所有的 Bean 后续处理都是针对于 RootBeanDefinition 的，所以这里需要进行一个转换。</span><br>            <span class="hljs-comment">// 转换的同时，如果父类 bean 不为空的话，则会一并合并父类的属性。</span><br>            <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br>            <span class="hljs-comment">//检查是否为抽象类</span><br>            checkMergedBeanDefinition(mbd, beanName, args);<br><br>            <span class="hljs-comment">// Guarantee initialization of beans that the current bean depends on.</span><br>            <span class="hljs-comment">// &lt;7&gt; 处理所依赖的 bean，先创建需要在当前bean创建之前必须创建的bean，通过@DependsOn(&quot;eventListener&quot;)注解设置该信息， 检查是否有 dependsOn 依赖，如果有则先初始化所依赖的 bean</span><br>            String[] dependsOn = mbd.getDependsOn();<br>            <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 检测是否存在 depends-on 循环依赖，若存在则抛异常。比如 A 依赖 B，</span><br><span class="hljs-comment"> * B 又依赖 A，他们的配置如下：</span><br><span class="hljs-comment"> *   &lt;bean id=&quot;beanA&quot; class=&quot;BeanA&quot; depends-on=&quot;beanB&quot;&gt;</span><br><span class="hljs-comment"> *   &lt;bean id=&quot;beanB&quot; class=&quot;BeanB&quot; depends-on=&quot;beanA&quot;&gt;</span><br><span class="hljs-comment"> * beanA 要求 beanB 在其之前被创建，但 beanB 又要求 beanA 先于它</span><br><span class="hljs-comment"> * 创建。这个时候形成了循环，对于 depends-on 循环，Spring 会直接</span><br><span class="hljs-comment"> * 抛出异常</span><br><span class="hljs-comment"> */</span><br>                    <span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                                                        <span class="hljs-string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-comment">// 缓存依赖调用，注册依赖记录，便于在销毁 Bean 之前对其进行销毁。</span><br>                    registerDependentBean(dep, beanName);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 加载 depends-on 依赖</span><br>                        getBean(dep);<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                                                        <span class="hljs-string">&quot;&#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// Create bean instance.</span><br>            <span class="hljs-comment">// &lt;8&gt; 创建 bean 实例</span><br>            <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<span class="hljs-comment">// 单例模式</span><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 这里并没有直接调用 createBean 方法创建 bean 实例，而是通过</span><br><span class="hljs-comment"> * getSingleton(String, ObjectFactory) 方法获取 bean 实例。</span><br><span class="hljs-comment"> * getSingleton(String, ObjectFactory) 方法会在内部调用</span><br><span class="hljs-comment"> * ObjectFactory 的 getObject() 方法创建 bean，并会在创建完成后，</span><br><span class="hljs-comment"> * 将 bean 放入缓存中。</span><br><span class="hljs-comment"> */</span><br>                sharedInstance = getSingleton(beanName, () -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 创建 bean 实例</span><br>                        <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>                        <span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span><br>                        <span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span><br>                        <span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span><br>                        <span class="hljs-comment">// 显式从单例缓存中删除 Bean 实例</span><br>                        <span class="hljs-comment">// 因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它。</span><br>                        destroySingleton(beanName);<br>                        <span class="hljs-keyword">throw</span> ex;<br>                    &#125;<br>                &#125;);<br>                <span class="hljs-comment">// 如果 bean 是 FactoryBean 类型，则调用工厂方法获取真正的 bean 实例。否则直接返回 bean 实例</span><br>                beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<span class="hljs-comment">// 原型模式</span><br>                <span class="hljs-comment">// It&#x27;s a prototype -&gt; create a new instance.</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">prototypeInstance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// &lt;1&gt; 加载前置处理</span><br>                    beforePrototypeCreation(beanName);<br>                    <span class="hljs-comment">// &lt;2&gt; 创建 Bean 对象</span><br>                    prototypeInstance = createBean(beanName, mbd, args);<br>                &#125;<br>                <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// &lt;3&gt; 加载后置处理</span><br>                    afterPrototypeCreation(beanName);<br>                &#125;<br>                <span class="hljs-comment">// &lt;4&gt; 从 Bean 实例中获取对象</span><br>                beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 从指定的 scope 下创建 bean</span><br>                <span class="hljs-comment">// 获得 scopeName 对应的 Scope 对象</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">scopeName</span> <span class="hljs-operator">=</span> mbd.getScope();<br>                <span class="hljs-keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No scope name defined for bean ´&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                &#125;<br>                <span class="hljs-type">Scope</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.scopes.get(scopeName);<br>                <span class="hljs-keyword">if</span> (scope == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 从指定的 scope 下创建 bean</span><br>                    <span class="hljs-type">Object</span> <span class="hljs-variable">scopedInstance</span> <span class="hljs-operator">=</span> scope.get(beanName, () -&gt; &#123;<br>                        <span class="hljs-comment">// 加载前置处理</span><br>                        beforePrototypeCreation(beanName);<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">// 创建 Bean 对象</span><br>                            <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>                        &#125;<br>                        <span class="hljs-keyword">finally</span> &#123;<br>                            <span class="hljs-comment">// 加载后缀处理</span><br>                            afterPrototypeCreation(beanName);<br>                        &#125;<br>                    &#125;);<br>                    <span class="hljs-comment">// 从 Bean 实例中获取对象</span><br>                    beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScopeNotActiveException</span>(beanName, scopeName, ex);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>            beanCreation.tag(<span class="hljs-string">&quot;exception&quot;</span>, ex.getClass().toString());<br>            beanCreation.tag(<span class="hljs-string">&quot;message&quot;</span>, String.valueOf(ex.getMessage()));<br>            cleanupAfterBeanCreationFailure(beanName);<br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            beanCreation.end();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;9&gt;</span><br>    <span class="hljs-keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);<br>&#125;<br><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>&lt;T&gt; T <span class="hljs-title function_">adaptBeanInstance</span><span class="hljs-params">(String name, Object bean, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; requiredType)</span> &#123;<br>    <span class="hljs-comment">// Check if required type matches the type of the actual bean instance.</span><br>    <span class="hljs-comment">//&lt;9&gt; 检查需要的类型是否符合 bean 的实际类型，如果需要进行类型转换，则在此处进行转换。</span><br>    <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">convertedBean</span> <span class="hljs-operator">=</span> getTypeConverter().convertIfNecessary(bean, requiredType);<br>            <span class="hljs-keyword">if</span> (convertedBean == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());<br>            &#125;<br>            <span class="hljs-keyword">return</span> (T) convertedBean;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (TypeMismatchException ex) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                logger.trace(<span class="hljs-string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27; to required type &#x27;&quot;</span> +<br>                             ClassUtils.getQualifiedName(requiredType) + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (T) bean;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>doGetBean()</code>方法的主要过程：</p><ol><li>**转换 beanName **。因为我们调用 <code>getBean(...)</code> 方法传入的 <code>name</code> 并不一定就是 beanName，可以传入 aliasName，FactoryBean，所以这里需要进行简单的转换过程。</li><li>尝试**从缓存中加载单例 bean **。</li><li><strong>bean 的实例化</strong>。</li><li><strong>原型模式的依赖检查</strong>。因为 Spring 只会解决单例模式的循环依赖，对于原型模式的循环依赖都是直接抛出 <code>BeanCurrentlyInCreationException</code> 异常。</li><li><strong>尝试从 parentBeanFactory 获取 bean 实例</strong>。如果 <code>parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)</code> 则尝试从 parentBeanFactory 中获取 bean 实例对象，因为 <code>!containsBeanDefinition(beanName)</code> 就意味着定义的 xml 文件中没有 beanName 相应的配置，这个时候就只能从 <code>parentBeanFactory</code> 中获取。</li><li><strong>获取 RootBeanDefinition，并对其进行合并检查</strong>。从缓存中获取已经解析的 RootBeanDefinition 。同时，如果父类不为 <code>null</code> 的话，则会合并父类的属性。</li><li><strong>依赖检查</strong>。某个 bean 依赖其他 bean ，则需要先加载依赖的 bean。</li><li><strong>对不同的 scope 进行处理</strong>。</li><li><strong>类型转换处理</strong>。如果传递的 <code>requiredType</code> 不为 <code>null</code>，则需要检测所得到 bean 的类型是否与该 <code>requiredType</code> 一致。如果不一致则尝试转换，当然也要能够转换成功，否则抛出 <code>BeanNotOfRequiredTypeException</code> 异常。</li></ol><p>更加简单的总结：</p><ol><li>从缓存中获取 bean。</li><li>创建 bean 实例对象。</li><li>从 bean 实例中获取对象。</li></ol><h4 id="从缓存中获取-bean"><a href="#从缓存中获取-bean" class="headerlink" title="从缓存中获取 bean"></a>从缓存中获取 bean</h4><p>Spring 中根据 scope 可以将 bean 分为以下几类：singleton、prototype 和 其他，这样分的原因在于 Spring 在对不同 scope 处理的时候是这么处理的：</p><ul><li>singleton ：在 Spring 的 IoC 容器中只存在一个对象实例，所有该对象的引用都共享这个实例。Spring 容器只会创建该 bean 定义的唯一实例，这个实例会被保存到缓存中，并且对该bean的所有后续请求和引用都将返回该缓存中的对象实例。</li><li>prototype ：每次对该bean的请求都会创建一个新的实例</li><li>其他：<ul><li>request：每次 http 请求将会有各自的 bean 实例。</li><li>session：在一个 http session 中，一个 bean 定义对应一个 bean 实例。</li><li>global session：在一个全局的 http session 中，一个 bean 定义对应一个 bean 实例。</li></ul></li></ul><p>所以，<strong>从缓存中获取的 bean 一定是 singleton bean</strong>，这也是 <strong>Spring 为何只解决 singleton bean 的循环依赖</strong>。</p><p>调用 <code>getSingleton(String beanName)</code> 方法，从缓存中获取 singleton bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultSingletonBeanRegistry.java</span><br><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-keyword">return</span> getSingleton(beanName, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-type">boolean</span> allowEarlyReference)</span> &#123;<br>    <span class="hljs-comment">// 从单例缓冲中加载 bean</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>    <span class="hljs-comment">// 缓存中的 bean 为空，且当前 bean 正在创建</span><br>    <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<br>        <span class="hljs-comment">// 加锁</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>            <span class="hljs-comment">// 从 earlySingletonObjects 获取</span><br>            singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);<br>            <span class="hljs-comment">// earlySingletonObjects 中没有，且允许提前创建</span><br>            <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; allowEarlyReference) &#123;<br>                <span class="hljs-comment">// 从 singletonFactories 中获取对应的 ObjectFactory</span><br>                ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-built_in">this</span>.singletonFactories.get(beanName);<br>                <span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 获得 bean</span><br>                    singletonObject = singletonFactory.getObject();<br>                    <span class="hljs-comment">// 添加 bean 到 earlySingletonObjects 中</span><br>                    <span class="hljs-built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br>                    <span class="hljs-comment">// 从 singletonFactories 中移除对应的 ObjectFactory</span><br>                    <span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singletonObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法就是从 <code>singletonObjects</code>、<code>earlySingletonObjects</code>、 <code>singletonFactories</code> 三个缓存中获取，这里也是 Spring 解决 bean 循环依赖的关键之处。可看《从单例缓存中获取单例 bean》、《循环依赖处理》。</p><h4 id="创建Bean实例对象"><a href="#创建Bean实例对象" class="headerlink" title="创建Bean实例对象"></a>创建Bean实例对象</h4><p>如果缓存中没有，也没有 <code>parentBeanFactory</code> ，则会调用 <code>createBean(String beanName, RootBeanDefinition mbd, Object[] args)</code> 方法，创建 bean 实例。该方法主要是在处理不同 scope 的 bean 的时候进行调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><span class="hljs-comment">// bean 的名字</span><br><span class="hljs-comment">// 已经合并了父类属性的（如果有的话）BeanDefinition</span><br><span class="hljs-comment">// 用于构造函数或者工厂方法创建 bean 实例对象的参数 </span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span> <span class="hljs-keyword">throws</span> BeanCreationException;<br></code></pre></td></tr></table></figure><p>该方法是定义在 AbstractBeanFactory 中的<strong>抽象</strong>方法，其含义是根据给定的 BeanDefinition 和 <code>args</code> 实例化一个 bean 对象。如果该 BeanDefinition 存在父类，则该 BeanDefinition 已经合并了父类的属性。所有 Bean 实例的创建都会委托给该方法实现。</p><p>该抽象方法的<strong>默认实现</strong>是在类 AbstractAutowireCapableBeanFactory 中实现，该方法其实只是做一些检查和验证工作，真正的初始化工作是由 <code>doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)</code> 方法来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> RootBeanDefinition mbd, <span class="hljs-keyword">final</span> <span class="hljs-meta">@Nullable</span> Object[] args)</span> <span class="hljs-keyword">throws</span> BeanCreationException &#123;<br><br>    <span class="hljs-comment">// BeanWrapper 是对 Bean 的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，获取被包装 bean 的属性描述器</span><br>    <span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// &lt;1&gt; 单例模型，则从未完成的 FactoryBean 缓存中删除</span><br>    <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>        instanceWrapper = <span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);<br>    &#125;<br>    <span class="hljs-comment">// &lt;2&gt; 使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化</span><br>    <span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>        instanceWrapper = createBeanInstance(beanName, mbd, args);<br>    &#125;<br>    <span class="hljs-comment">// 包装的实例对象</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> instanceWrapper.getWrappedInstance();<br>    <span class="hljs-comment">// 包装的实例对象的类型</span><br>    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();<br>    <span class="hljs-keyword">if</span> (beanType != NullBean.class) &#123;<br>        mbd.resolvedTargetType = beanType;<br>    &#125;<br>    <span class="hljs-comment">// Allow post-processors to modify the merged bean definition.</span><br>    <span class="hljs-comment">// &lt;3&gt; 判断是否有后置处理</span><br>    <span class="hljs-comment">// 如果有后置处理，则允许后置处理修改 BeanDefinition</span><br>    <span class="hljs-keyword">synchronized</span> (mbd.postProcessingLock) &#123;<br>        <span class="hljs-keyword">if</span> (!mbd.postProcessed) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 后置处理修改 BeanDefinition</span><br>                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                        <span class="hljs-string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);<br>            &#125;<br>            mbd.postProcessed = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;4&gt; 解决单例模式的循环依赖</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">earlySingletonExposure</span> <span class="hljs-operator">=</span> (mbd.isSingleton() <span class="hljs-comment">// 单例模式</span><br>            &amp;&amp; <span class="hljs-built_in">this</span>.allowCircularReferences <span class="hljs-comment">// 运行循环依赖</span><br>            &amp;&amp; isSingletonCurrentlyInCreation(beanName)); <span class="hljs-comment">// 当前单例 bean 是否正在被创建</span><br>    <span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +<br>                    <span class="hljs-string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 提前将创建的 bean 实例加入到 singletonFactories 中</span><br>        <span class="hljs-comment">// 这里是为了后期避免循环依赖</span><br>        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br>    &#125;<br><br>    <span class="hljs-comment">// 开始初始化 bean 实例对象</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// &lt;5&gt; 对 bean 进行填充，将各个属性值注入，其中，可能存在依赖于其他 bean 的属性</span><br>        <span class="hljs-comment">// 则会递归初始依赖 bean</span><br>        populateBean(beanName, mbd, instanceWrapper);<br>        <span class="hljs-comment">// &lt;6&gt; 调用初始化方法</span><br>        exposedObject = initializeBean(beanName, exposedObject, mbd);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;<br>            <span class="hljs-keyword">throw</span> (BeanCreationException) ex;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>                    mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Initialization of bean failed&quot;</span>, ex);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;7&gt; 循环依赖处理</span><br>    <span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>        <span class="hljs-comment">// 获取 earlySingletonReference</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">earlySingletonReference</span> <span class="hljs-operator">=</span> getSingleton(beanName, <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 只有在存在循环依赖的情况下，earlySingletonReference 才不会为空</span><br>        <span class="hljs-keyword">if</span> (earlySingletonReference != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果 exposedObject 没有在初始化方法中被改变，也就是没有被增强</span><br>            <span class="hljs-keyword">if</span> (exposedObject == bean) &#123;<br>                exposedObject = earlySingletonReference;<br>            <span class="hljs-comment">// 处理依赖</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;<br>                String[] dependentBeans = getDependentBeans(beanName);<br>                Set&lt;String&gt; actualDependentBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);<br>                <span class="hljs-keyword">for</span> (String dependentBean : dependentBeans) &#123;<br>                    <span class="hljs-keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;<br>                        actualDependentBeans.add(dependentBean);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName,<br>                            <span class="hljs-string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; has been injected into other beans [&quot;</span> +<br>                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +<br>                            <span class="hljs-string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +<br>                            <span class="hljs-string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +<br>                            <span class="hljs-string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +<br>                            <span class="hljs-string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;8&gt; 注册 bean</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        registerDisposableBeanIfNecessary(beanName, bean, mbd);<br>    &#125; <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>                mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Invalid destruction signature&quot;</span>, ex);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>doCreateBean(...)</code> 方法，是创建 bean 实例的核心方法，主要流程如下：</p><ul><li><code>&lt;1&gt;</code> 处，如果是单例模式，则清除 <code>factoryBeanInstanceCache 缓存</code>，同时返回 BeanWrapper 实例对象，当然如果存在。</li><li><code>&lt;2&gt;</code> 处，如果缓存中没有 BeanWrapper 或者不是单例模式，则调用 <code>createBeanInstance(...)</code> 方法，实例化 bean，主要是将 BeanDefinition 转换为 BeanWrapper 。</li><li><code>&lt;3&gt;</code> 处，MergedBeanDefinitionPostProcessor 的应用。</li><li><code>&lt;4&gt;</code> 处，单例模式的循环依赖处理。</li><li><code>&lt;5&gt;</code> 处，调用 <code>populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</code> 方法，进行属性填充。将所有属性填充至 bean 的实例中。</li><li><code>&lt;6&gt;</code> 处，调用 <code>initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd)</code> 方法，初始化 bean 。</li><li><code>&lt;7&gt;</code> 处，依赖检查。</li><li><code>&lt;8&gt;</code> 处，注册 DisposableBean 。</li></ul><h5 id="实例化Bean"><a href="#实例化Bean" class="headerlink" title="实例化Bean"></a>实例化Bean</h5><p>如果缓存中没有 BeanWrapper 实例对象或者该 bean 不是 singleton，则调用 <code>createBeanInstance(...)</code> 方法。创建 bean 实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><br><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title function_">createBeanInstance</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span> &#123;<br>    <span class="hljs-comment">// 解析 bean ，将 bean 类名解析为 class 引用。</span><br>    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);<br><br>    <span class="hljs-keyword">if</span> (beanClass != <span class="hljs-literal">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123; <span class="hljs-comment">// 校验</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                <span class="hljs-string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;1&gt; 如果存在 Supplier 回调，则使用给定的回调方法初始化策略</span><br>    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();<br>    <span class="hljs-keyword">if</span> (instanceSupplier != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;2&gt; 使用 FactoryBean 的 factory-method 来创建，支持静态工厂和实例工厂</span><br>    <span class="hljs-keyword">if</span> (mbd.getFactoryMethodName() != <span class="hljs-literal">null</span>)  &#123;<br>        <span class="hljs-keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;3&gt; Shortcut when re-creating the same bean...</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">resolved</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">autowireNecessary</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (args == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// constructorArgumentLock 构造函数的常用锁</span><br>        <span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;<br>            <span class="hljs-comment">// 如果已缓存的解析的构造函数或者工厂方法不为空，则可以利用构造函数解析</span><br>            <span class="hljs-comment">// 因为需要根据参数确认到底使用哪个构造函数，该过程比较消耗性能，所有采用缓存机制</span><br>            <span class="hljs-keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="hljs-literal">null</span>) &#123;<br>                resolved = <span class="hljs-literal">true</span>;<br>                autowireNecessary = mbd.constructorArgumentsResolved;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 已经解析好了，直接注入即可</span><br>    <span class="hljs-keyword">if</span> (resolved) &#123;<br>        <span class="hljs-comment">// &lt;3.1&gt; autowire 自动注入，调用构造函数自动注入</span><br>        <span class="hljs-keyword">if</span> (autowireNecessary) &#123;<br>            <span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// &lt;3.2&gt; 使用默认构造函数构造</span><br>            <span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;4&gt; 确定解析的构造函数</span><br>    <span class="hljs-comment">// 主要是检查已经注册的 SmartInstantiationAwareBeanPostProcessor</span><br>    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);<br>    <span class="hljs-comment">// &lt;4.1&gt; 有参数情况时，创建 Bean 。先利用参数个数，类型等，确定最精确匹配的构造方法。</span><br>    <span class="hljs-keyword">if</span> (ctors != <span class="hljs-literal">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||<br>            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;<br>        <span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;4.1&gt; 选择构造方法，创建 Bean 。</span><br>    ctors = mbd.getPreferredConstructors();<br>    <span class="hljs-keyword">if</span> (ctors != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="hljs-literal">null</span>); <span class="hljs-comment">// args = null</span><br>    &#125;<br><br>    <span class="hljs-comment">// &lt;4.2&gt; 有参数时，又没获取到构造方法，则只能调用无参构造方法来创建实例了(兜底方法)</span><br>    <span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);<br>&#125;<br></code></pre></td></tr></table></figure><p>实例化 Bean 对象，主要过程：</p><ul><li><code>&lt;1&gt;</code> 处，如果存在 Supplier 回调，则调用 <code>obtainFromSupplier(Supplier instanceSupplier, String beanName)</code> 方法，进行初始化。</li><li><code>&lt;2&gt;</code> 处，如果存在工厂方法，则使用工厂方法进行初始化，并直接return。</li><li><code>&lt;3&gt;</code> 处，首先判断缓存，如果<strong>缓存中存在</strong>，即已经解析过了，则直接使用已经解析了的。根据 <code>constructorArgumentsResolved</code> 参数来判断：<ul><li><code>&lt;3.1&gt;</code> 处，是使用构造函数自动注入，即调用 <code>autowireConstructor(String beanName, RootBeanDefinition mbd, Constructor[] ctors, Object[] explicitArgs)</code> 方法。</li><li><code>&lt;3.2&gt;</code> 处，还是默认构造函数，即调用 <code>instantiateBean(final String beanName, final RootBeanDefinition mbd)</code> 方法。</li></ul></li></ul><ul><li><code>&lt;4&gt;</code> 处，如果<strong>缓存中没有</strong>，则需要先确定到底使用哪个构造函数来完成解析工作，因为一个类有多个构造函数，每个构造函数都有不同的构造参数，所以需要根据参数来锁定构造函数并完成初始化。<ul><li><code>&lt;4.1&gt;</code> 处，如果存在参数，则使用相应的带有参数的构造函数，即调用 <code>autowireConstructor(String beanName, RootBeanDefinition mbd, Constructor[] ctors, Object[] explicitArgs)</code> 方法。</li><li><code>&lt;4.2&gt;</code> 处，否则，使用默认构造函数，即调用 <code>instantiateBean(final String beanName, final RootBeanDefinition mbd)</code> 方法。</li></ul></li></ul><p>其实<strong>核心思想</strong>还是在于根据不同的情况执行不同的实例化策略，主要是包括如下四种策略：</p><ol><li>Supplier 回调</li><li><code>instantiateUsingFactoryMethod(...)</code> 方法，工厂方法初始化</li><li><code>autowireConstructor(...)</code> 方法，构造函数自动注入初始化</li><li><code>instantiateBean(...)</code> 方法，默认构造函数注入</li></ol><p>其实无论哪种策略，他们的实现逻辑都差不多：确定构造函数和构造方法，然后实例化。</p><p>只不过相对于 <strong>Supplier 回调</strong>和<strong>默认构造函数</strong>注入而言，<strong>工厂方法初始化</strong>和<strong>构造函数</strong>自动注入初始化会比较复杂，因为他们<strong>构造函数和构造参数的不确定性</strong>，Spring 需要花大量的精力来确定构造函数和构造参数，如果确定了则好办，直接选择实例化策略即可。当然在实例化的时候会根据<strong>是否有需要覆盖或者动态替换掉的方法</strong>，因为存在覆盖或者织入的话需要创建<strong>动态代理</strong>将方法织入，这个时候就只能选择 CGLIB 的方式来实例化，否则直接利用<strong>反射</strong>的方式即可。</p><h5 id="属性填充"><a href="#属性填充" class="headerlink" title="属性填充"></a>属性填充</h5><p>属性填充其实就是将 BeanDefinition 的属性值赋值给 BeanWrapper 实例对象的过程。在填充的过程需要根据注入的类型不同来区分是根据<strong>类型注入</strong>还是<strong>名字注入</strong>，当然在这个过程还会涉及<strong>循环依赖</strong>的问题的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">populateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> BeanWrapper bw)</span> &#123;<br>    <span class="hljs-comment">// 没有实例化对象</span><br>    <span class="hljs-keyword">if</span> (bw == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 有属性，则抛出 BeanCreationException 异常</span><br>        <span class="hljs-keyword">if</span> (mbd.hasPropertyValues()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>                    mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Cannot apply property values to null instance&quot;</span>);<br>            <span class="hljs-comment">// 没有属性，直接 return 返回</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;1&gt; 在设置属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">continueWithPropertyPopulation</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (!mbd.isSynthetic()  <span class="hljs-comment">// bean 不是&quot;合成&quot;的，即未由应用程序本身定义</span><br>            &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; <span class="hljs-comment">// 是否持有 InstantiationAwareBeanPostProcessor</span><br>        <span class="hljs-comment">// 迭代所有的 BeanPostProcessors</span><br>        <span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<br>            <span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123; <span class="hljs-comment">// 如果为 InstantiationAwareBeanPostProcessor</span><br>                <span class="hljs-type">InstantiationAwareBeanPostProcessor</span> <span class="hljs-variable">ibp</span> <span class="hljs-operator">=</span> (InstantiationAwareBeanPostProcessor) bp;<br>                <span class="hljs-comment">// 返回值为是否继续填充 bean</span><br>                <span class="hljs-comment">// postProcessAfterInstantiation：如果应该在 bean上面设置属性则返回 true，否则返回 false</span><br>                <span class="hljs-comment">// 一般情况下，应该是返回true 。</span><br>                <span class="hljs-comment">// 返回 false 的话，将会阻止在此 Bean 实例上调用任何后续的 InstantiationAwareBeanPostProcessor 实例。</span><br>                <span class="hljs-keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;<br>                    continueWithPropertyPopulation = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果后续处理器发出停止填充命令，则终止后续操作</span><br>    <span class="hljs-keyword">if</span> (!continueWithPropertyPopulation) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// bean 的属性值</span><br>    <span class="hljs-type">PropertyValues</span> <span class="hljs-variable">pvs</span> <span class="hljs-operator">=</span> (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="hljs-literal">null</span>);<br><br>    <span class="hljs-comment">// &lt;2&gt; 自动注入</span><br>    <span class="hljs-keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;<br>        <span class="hljs-comment">// 将 PropertyValues 封装成 MutablePropertyValues 对象</span><br>        <span class="hljs-comment">// MutablePropertyValues 允许对属性进行简单的操作，并提供构造函数以支持Map的深度复制和构造。</span><br>        <span class="hljs-type">MutablePropertyValues</span> <span class="hljs-variable">newPvs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutablePropertyValues</span>(pvs);<br>        <span class="hljs-comment">// Add property values based on autowire by name if applicable.</span><br>        <span class="hljs-comment">// 根据名称自动注入</span><br>        <span class="hljs-keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) &#123;<br>            autowireByName(beanName, mbd, bw, newPvs);<br>        &#125;<br>        <span class="hljs-comment">// Add property values based on autowire by type if applicable.</span><br>        <span class="hljs-comment">// 根据类型自动注入</span><br>        <span class="hljs-keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;<br>            autowireByType(beanName, mbd, bw, newPvs);<br>        &#125;<br>        pvs = newPvs;<br>    &#125;<br><br>    <span class="hljs-comment">// 是否已经注册了 InstantiationAwareBeanPostProcessors</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">hasInstAwareBpps</span> <span class="hljs-operator">=</span> hasInstantiationAwareBeanPostProcessors();<br>    <span class="hljs-comment">// 是否需要进行【依赖检查】</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">needsDepCheck</span> <span class="hljs-operator">=</span> (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);<br><br>    <span class="hljs-comment">// &lt;3&gt; BeanPostProcessor 处理</span><br>    PropertyDescriptor[] filteredPds = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (hasInstAwareBpps) &#123;<br>        <span class="hljs-keyword">if</span> (pvs == <span class="hljs-literal">null</span>) &#123;<br>            pvs = mbd.getPropertyValues();<br>        &#125;<br>        <span class="hljs-comment">// 遍历 BeanPostProcessor 数组</span><br>        <span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<br>            <span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;<br>                <span class="hljs-type">InstantiationAwareBeanPostProcessor</span> <span class="hljs-variable">ibp</span> <span class="hljs-operator">=</span> (InstantiationAwareBeanPostProcessor) bp;<br>                <span class="hljs-comment">// 对所有需要依赖检查的属性进行后处理</span><br>                <span class="hljs-type">PropertyValues</span> <span class="hljs-variable">pvsToUse</span> <span class="hljs-operator">=</span> ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);<br>                <span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 从 bw 对象中提取 PropertyDescriptor 结果集</span><br>                    <span class="hljs-comment">// PropertyDescriptor：可以通过一对存取方法提取一个属性</span><br>                    <span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-literal">null</span>) &#123;<br>                        filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);<br>                    &#125;<br>                    pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);<br>                    <span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>                pvs = pvsToUse;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// &lt;4&gt; 依赖检查</span><br>    <span class="hljs-keyword">if</span> (needsDepCheck) &#123;<br>        <span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-literal">null</span>) &#123;<br>            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);<br>        &#125;<br>        <span class="hljs-comment">// 依赖检查，对应 depends-on 属性</span><br>        checkDependencies(beanName, mbd, filteredPds, pvs);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;5&gt; 将属性应用到 bean 中</span><br>    <span class="hljs-keyword">if</span> (pvs != <span class="hljs-literal">null</span>) &#123;<br>        applyPropertyValues(beanName, mbd, bw, pvs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要过程：</p><ul><li><p><code>&lt;1&gt;</code> ，根据 <code>hasInstantiationAwareBeanPostProcessors</code> 属性来判断，是否需要在注入属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会。<strong>此过程可以控制 Spring 是否继续进行属性填充</strong>。</p></li><li><p>统一存入到 PropertyValues 中，PropertyValues 用于描述 bean 的属性。</p><ul><li><code>&lt;2&gt;</code> ，根据注入类型( <code>AbstractBeanDefinition.getResolvedAutowireMode()</code> 方法的返回值 )的不同来判断：是根据名称来自动注入<code>autowireByName()</code>，还是根据类型来自动注入<code>autowireByType()</code>。</li><li><code>&lt;3&gt;</code> ，进行 BeanPostProcessor 处理。</li><li><code>&lt;4&gt;</code> ，依赖检测。</li></ul></li><li><p><code>&lt;5&gt;</code> ，将所有 PropertyValues 中的属性，填充到 BeanWrapper 中。</p></li></ul><h5 id="初始化Bean"><a href="#初始化Bean" class="headerlink" title="初始化Bean"></a>初始化Bean</h5><p>初始化 bean 为 <code>createBean(...)</code> 方法的最后一个过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">initializeBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;<br>    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 安全模式</span><br>        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;<br>            <span class="hljs-comment">// &lt;1&gt; 激活 Aware 方法，对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware</span><br>            invokeAwareMethods(beanName, bean);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;, getAccessControlContext());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// &lt;1&gt; 激活 Aware 方法，对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware</span><br>        invokeAwareMethods(beanName, bean);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;2&gt; 后处理器，before</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">wrappedBean</span> <span class="hljs-operator">=</span> bean;<br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;3&gt; 激活用户自定义的 init 方法</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        invokeInitMethods(beanName, wrappedBean, mbd);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>                (mbd != <span class="hljs-literal">null</span> ? mbd.getResourceDescription() : <span class="hljs-literal">null</span>),<br>                beanName, <span class="hljs-string">&quot;Invocation of init method failed&quot;</span>, ex);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;2&gt; 后处理器，after</span><br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> wrappedBean;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化 bean 的方法其实就是三个步骤的处理，而这三个步骤主要还是根据<strong>用户设定</strong>的来进行初始化，这三个过程为：</p><ul><li><code>&lt;1&gt;</code> 激活 Aware 方法。</li><li><code>&lt;3&gt;</code> 后置处理器的应用。</li><li><code>&lt;2&gt;</code> 激活自定义的 init 方法。</li></ul><h4 id="从Bean实例中获取对象"><a href="#从Bean实例中获取对象" class="headerlink" title="从Bean实例中获取对象"></a>从Bean实例中获取对象</h4><p>无论是从单例缓存中获取的 bean 实例 还是通过 <code>createBean(...)</code> 方法来创建的 bean 实例，最终都会调用 <code>getObjectForBeanInstance(...)</code> 方法来根据传入的 bean 实例获取对象，按照 Spring 的传统，该方法也只是做一些检测工作，真正的实现逻辑是委托给 <code>getObjectFromFactoryBean(...)</code> 方法来实现。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getObjectFromFactoryBean</span><span class="hljs-params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="hljs-type">boolean</span> shouldPostProcess)</span> &#123;<br>    <span class="hljs-comment">// &lt;1&gt; 为单例模式且缓存中存在</span><br>    <span class="hljs-keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;<br>        <span class="hljs-keyword">synchronized</span> (getSingletonMutex()) &#123; <span class="hljs-comment">// &lt;1.1&gt; 单例锁</span><br>            <span class="hljs-comment">// &lt;1.2&gt; 从缓存中获取指定的 factoryBean</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.factoryBeanObjectCache.get(beanName);<br>            <span class="hljs-keyword">if</span> (object == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 为空，则从 FactoryBean 中获取对象</span><br>                object = doGetObjectFromFactoryBean(factory, beanName);<br>                <span class="hljs-comment">// 从缓存中获取</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">alreadyThere</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.factoryBeanObjectCache.get(beanName);<br>                <span class="hljs-keyword">if</span> (alreadyThere != <span class="hljs-literal">null</span>) &#123;<br>                    object = alreadyThere;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// &lt;1.3&gt; 需要后续处理</span><br>                    <span class="hljs-keyword">if</span> (shouldPostProcess) &#123;<br>                        <span class="hljs-comment">// 若该 Bean 处于创建中，则返回非处理对象，而不是存储它</span><br>                        <span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;<br>                            <span class="hljs-comment">// Temporarily return non-post-processed object, not storing it yet..</span><br>                            <span class="hljs-keyword">return</span> object;<br>                        &#125;<br>                        <span class="hljs-comment">// 单例 Bean 的前置处理</span><br>                        beforeSingletonCreation(beanName);<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">// 对从 FactoryBean 获取的对象进行后处理</span><br>                            <span class="hljs-comment">// 生成的对象将暴露给 bean 引用</span><br>                            object = postProcessObjectFromFactoryBean(object, beanName);<br>                        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(beanName,<br>                                    <span class="hljs-string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            <span class="hljs-comment">// 单例 Bean 的后置处理</span><br>                            afterSingletonCreation(beanName);<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// &lt;1.4&gt; 添加到 factoryBeanObjectCache 中，进行缓存</span><br>                    <span class="hljs-keyword">if</span> (containsSingleton(beanName)) &#123;<br>                        <span class="hljs-built_in">this</span>.factoryBeanObjectCache.put(beanName, object);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> object;<br>        &#125;<br>    <span class="hljs-comment">// &lt;2&gt;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 为空，则从 FactoryBean 中获取对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> doGetObjectFromFactoryBean(factory, beanName);<br>        <span class="hljs-comment">// 需要后续处理</span><br>        <span class="hljs-keyword">if</span> (shouldPostProcess) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 对从 FactoryBean 获取的对象进行后处理</span><br>                <span class="hljs-comment">// 生成的对象将暴露给 bean 引用</span><br>                object = postProcessObjectFromFactoryBean(object, beanName);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(beanName, <span class="hljs-string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要流程：</p><ul><li>若为单例且单例 Bean 缓存中存在 <code>beanName</code> ，则 <code>&lt;1&gt;</code> 进行后续处理（跳转到下一步），否则，则 <code>&lt;2&gt;</code> 从 FactoryBean 中获取 Bean 实例对象。</li><li><code>&lt;1.1&gt;</code> 首先，获取锁。其实我们在前面篇幅中发现了大量的同步锁，锁住的对象都是 <code>this.singletonObjects</code>，主要是因为在单例模式中必须要<strong>保证全局唯一</strong>。</li><li><code>&lt;1.2&gt;</code> 然后，从 <code>factoryBeanObjectCache</code> 缓存中获取实例对象 <code>object</code> 。若 <code>object</code> 为空，则调用 <code>doGetObjectFromFactoryBean(FactoryBean factory, String beanName)</code> 方法，从 FactoryBean 获取对象，其实内部就是调用 <code>FactoryBean.getObject()</code> 方法。</li><li><code>&lt;1.3&gt;</code> 如果需要后续处理( <code>shouldPostProcess = true</code> )，则进行进一步处理：<ul><li>若该 Bean 处于创建中（<code>isSingletonCurrentlyInCreation(String beanName)</code> 方法返回 <code>true</code> ），则返回<strong>非处理的 Bean 对象</strong>，而不是存储它。</li><li>调用 <code>beforeSingletonCreation(String beanName)</code> 方法，进行创建之前的处理。默认实现将该 Bean 标志为当前创建的。</li><li>调用 <code>postProcessObjectFromFactoryBean(Object object, String beanName)</code> 方法，对从 FactoryBean 获取的 Bean 实例对象进行后置处理。</li><li>调用 <code>afterSingletonCreation(String beanName)</code> 方法，进行创建 Bean 之后的处理，默认实现是将该 bean 标记为不再在创建中。</li></ul></li></ul><ul><li><code>&lt;1.4&gt;</code> 最后，加入到 <code>factoryBeanObjectCache</code> 缓存中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三、加载BeanDefinition</title>
    <link href="/2022/06/11/%E5%8A%A0%E8%BD%BDBeanDefinition/"/>
    <url>/2022/06/11/%E5%8A%A0%E8%BD%BDBeanDefinition/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">加载BeanDefinition</font></div><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//获取资源</span><br>ClassPathResource resource = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ClassPathResource(<span class="hljs-string">&quot;bean.xml&quot;</span>)</span>;<br><span class="hljs-comment">//获取 BeanFactory</span><br>DefaultListableBeanFactory factory = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultListableBeanFactory()</span>;<br><span class="hljs-comment">//根据新建的 BeanFactory 创建一个 BeanDefinitionReader 对象，该 Reader 对象为资源的解析器</span><br>XmlBeanDefinitionReader reader = <span class="hljs-keyword">new</span> <span class="hljs-constructor">XmlBeanDefinitionReader(<span class="hljs-params">factory</span>)</span>;<br><span class="hljs-comment">//装载资源</span><br>reader.load<span class="hljs-constructor">BeanDefinitions(<span class="hljs-params">resource</span>)</span>;<br></code></pre></td></tr></table></figure><p>这段代码是 Spring 中编程式使用 IoC 容器，IoC 容器的使用过程如下：</p><p>资源定位、装载、注册。</p><p><strong>资源定位：</strong>IOC容器定位资源上一片《Spring统一资源加载策略》。</p><p><strong>装载：</strong>装载就是 BeanDefinition 的载入，<em>BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IoC 容器的内部数据结构：BeanDefinition</em> 。</p><ul><li>在 IoC 容器内部维护着一个 BeanDefinition Map 的数据结构。</li><li>在配置文件中每一个<bean>都对应着一个 BeanDefinition 对象。</li></ul><p><strong>注册：</strong>向 IoC 容器注册在第二步解析好的 BeanDefinition，其实就是将BeanDefinition注入到一个HashMap容器中，这个过程是通过 BeanDefinitionRegistry 接口来实现的，IoC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。</p><ul><li>在这里需要注意的一点是这个过程并没有完成依赖注入（Bean 创建），Bean 创建是发生在应用第一次调用 <code>getBean(...)</code> 方法，向容器索要 Bean 时。</li><li>当然我们可以通过设置预处理，即对某个 Bean 设置 <code>lazyinit = false</code> 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。</li></ul><h4 id="loadBeanDefinitions"><a href="#loadBeanDefinitions" class="headerlink" title="loadBeanDefinitions"></a>loadBeanDefinitions</h4><p>装载，通过reader.loadBeanDefinitions(resource);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    <span class="hljs-keyword">return</span> loadBeanDefinitions(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EncodedResource</span>(resource));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>从指定的 xml 文件加载 BeanDefinition ，这里会先对 Resource 资源封装成 <code>org.springframework.core.io.support.EncodedResource</code> 对象。这里为什么需要将 Resource 封装成 EncodedResource 呢？主要是为了对 Resource 进行编码，保证内容读取的正确性。</p></li><li><p>然后，再调用 <code>#loadBeanDefinitions(EncodedResource encodedResource)</code> 方法，执行真正的逻辑实现。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Set&lt;EncodedResource&gt;&gt; resourcesCurrentlyBeingLoaded =<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadLocal</span>&lt;Set&lt;EncodedResource&gt;&gt;(<span class="hljs-string">&quot;XML bean definition resources currently being loaded&quot;</span>)&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Set&lt;EncodedResource&gt; <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(<span class="hljs-number">4</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(EncodedResource encodedResource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    Assert.notNull(encodedResource, <span class="hljs-string">&quot;EncodedResource must not be null&quot;</span>);<br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>        logger.trace(<span class="hljs-string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;1&gt; 获取已经加载过的资源</span><br>    Set&lt;EncodedResource&gt; currentResources = <span class="hljs-built_in">this</span>.resourcesCurrentlyBeingLoaded.get();<br><br>    <span class="hljs-keyword">if</span> (!currentResources.add(encodedResource)) &#123;<span class="hljs-comment">// 将当前资源加入记录中。如果已存在，抛出异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(<br>            <span class="hljs-string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="hljs-string">&quot; - check your import definitions!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;2&gt; 从 EncodedResource 获取封装的 Resource ，并从 Resource 中获取其中的 InputStream</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> encodedResource.getResource().getInputStream()) &#123;<br>        <span class="hljs-type">InputSource</span> <span class="hljs-variable">inputSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(inputStream);<br>        <span class="hljs-keyword">if</span> (encodedResource.getEncoding() != <span class="hljs-literal">null</span>) &#123;<br>            inputSource.setEncoding(encodedResource.getEncoding());<br>        &#125;<br>        <span class="hljs-comment">// 核心逻辑部分，执行加载 BeanDefinition</span><br>        <span class="hljs-keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(<br>            <span class="hljs-string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 从缓存中剔除该资源 &lt;3&gt;</span><br>        currentResources.remove(encodedResource);<br>        <span class="hljs-keyword">if</span> (currentResources.isEmpty()) &#123;<br>            <span class="hljs-built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&lt;1&gt;</code> 处，通过 <code>resourcesCurrentlyBeingLoaded.get()</code> 代码，来获取已经加载过的资源，然后将 <code>encodedResource</code> 加入其中，如果 <code>resourcesCurrentlyBeingLoaded</code> 中已经存在该资源，则抛出 BeanDefinitionStoreException 异常。</p><ul><li>为什么需要这么做呢？答案在 <code>&quot;Detected cyclic loading&quot;</code> ，避免一个 EncodedResource 在加载时，还没加载完成，又加载自身，从而导致<strong>死循环</strong>。</li><li>也因此，在 <code>&lt;3&gt;</code> 处，当一个 EncodedResource 加载完成后，需要从缓存中剔除。</li></ul><p><code>&lt;2&gt;</code> 处理，从 <code>encodedResource</code> 获取封装的 Resource 资源，并从 Resource 中获取相应的 InputStream ，然后将 InputStream 封装为 InputSource ，最后调用 <code>#doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code> 方法，执行加载 Bean Definition 的真正逻辑。</p><h4 id="doLoadBeanDefinitions"><a href="#doLoadBeanDefinitions" class="headerlink" title="doLoadBeanDefinitions"></a>doLoadBeanDefinitions</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doLoadBeanDefinitions</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span><br><span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// &lt;1&gt; 获取 XML Document 实例</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">doc</span> <span class="hljs-operator">=</span> doLoadDocument(inputSource, resource);<br>        <span class="hljs-comment">// &lt;2&gt; 根据 Document 实例，注册 Bean 信息</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> registerBeanDefinitions(doc, resource);<br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            logger.debug(<span class="hljs-string">&quot;Loaded &quot;</span> + count + <span class="hljs-string">&quot; bean definitions from &quot;</span> + resource);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;<br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (SAXParseException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),<br>                                                  <span class="hljs-string">&quot;Line &quot;</span> + ex.getLineNumber() + <span class="hljs-string">&quot; in XML document from &quot;</span> + resource + <span class="hljs-string">&quot; is invalid&quot;</span>, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (SAXException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),<br>                                                  <span class="hljs-string">&quot;XML document from &quot;</span> + resource + <span class="hljs-string">&quot; is invalid&quot;</span>, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (ParserConfigurationException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(resource.getDescription(),<br>                                               <span class="hljs-string">&quot;Parser configuration exception parsing XML from &quot;</span> + resource, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(resource.getDescription(),<br>                                               <span class="hljs-string">&quot;IOException parsing XML document from &quot;</span> + resource, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(resource.getDescription(),<br>                                               <span class="hljs-string">&quot;Unexpected exception parsing XML document from &quot;</span> + resource, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在 <code>&lt;1&gt;</code> 处，调用 <code>#doLoadDocument(InputSource inputSource, Resource resource)</code> 方法，根据 xml 文件，获取 Document 实例。</li><li>在 <code>&lt;2&gt;</code> 处，调用 <code>#registerBeanDefinitions(Document doc, Resource resource)</code> 方法，根据获取的 Document 实例，注册 Bean 信息。</li></ul><h5 id="doLoadDocument"><a href="#doLoadDocument" class="headerlink" title="doLoadDocument"></a>doLoadDocument</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Document <span class="hljs-title function_">doLoadDocument</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="hljs-built_in">this</span>.errorHandler,getValidationModeForResource(resource), isNamespaceAware());<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 <code>#getValidationModeForResource(Resource resource)</code> 方法，获取指定资源（xml）的<strong>验证模式</strong>。<em><strong>看下一篇</strong></em></p><p>调用 <code>DocumentLoader#loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware)</code> 方法，获取 XML Document 实例。</p><h5 id="registerBeanDefinitions"><a href="#registerBeanDefinitions" class="headerlink" title="registerBeanDefinitions"></a>registerBeanDefinitions</h5><p><em><strong>看注册BeanDefinitions</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二十二、创建Bean之实例化Bean对象二</title>
    <link href="/2022/06/11/%E5%88%9B%E5%BB%BABean%E4%B9%8B%E5%AE%9E%E4%BE%8B%E5%8C%96Bean%E5%AF%B9%E8%B1%A12/"/>
    <url>/2022/06/11/%E5%88%9B%E5%BB%BABean%E4%B9%8B%E5%AE%9E%E4%BE%8B%E5%8C%96Bean%E5%AF%B9%E8%B1%A12/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">创建Bean之实例化Bean对象二</font></div><p>createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args)&#96; 方法，用于实例化 Bean 对象。它会根据不同情况，选择不同的实例化策略来完成 Bean 的初始化，主要包括：</p><ul><li>Supplier 回调：<code>obtainFromSupplier(final String beanName, final RootBeanDefinition mbd)</code> 方法。</li><li>工厂方法初始化：<code>instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs)</code> 方法。</li><li>构造函数自动注入初始化：<code>autowireConstructor(final String beanName, final RootBeanDefinition mbd, Constructor[] chosenCtors, final Object[] explicitArgs)</code> 方法。</li><li>默认构造函数注入：<code>instantiateBean(final String beanName, final RootBeanDefinition mbd)</code> 方法。</li></ul><h4 id="autowireConstructor"><a href="#autowireConstructor" class="headerlink" title="autowireConstructor()"></a><code>autowireConstructor()</code></h4><p>这个初始化方法，我们可以简单理解为是<strong>带有参数的构造方法</strong>，来初始化 Bean 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><br><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title function_">autowireConstructor</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Constructor&lt;?&gt;[] ctors, <span class="hljs-meta">@Nullable</span> Object[] explicitArgs)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstructorResolver</span>(<span class="hljs-built_in">this</span>).autowireConstructor(beanName, mbd, ctors, explicitArgs);<br>&#125;<br><br><span class="hljs-comment">// ConstructorResolver.java</span><br><span class="hljs-keyword">public</span> BeanWrapper <span class="hljs-title function_">autowireConstructor</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd,</span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> Constructor&lt;?&gt;[] chosenCtors, <span class="hljs-meta">@Nullable</span> Object[] explicitArgs)</span> &#123;<br><br>    <span class="hljs-comment">// 封装 BeanWrapperImpl 对象，并完成初始化</span><br>    <span class="hljs-type">BeanWrapperImpl</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanWrapperImpl</span>();<br>    <span class="hljs-built_in">this</span>.beanFactory.initBeanWrapper(bw);<br><br>    <span class="hljs-comment">// 获得 constructorToUse、argsHolderToUse、argsToUse</span><br>    Constructor&lt;?&gt; constructorToUse = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-type">ArgumentsHolder</span> <span class="hljs-variable">argsHolderToUse</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">// 构造参数</span><br>    Object[] argsToUse = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 构造参数</span><br><br>    <span class="hljs-comment">// 确定构造参数</span><br>    <span class="hljs-comment">// 如果 getBean() 已经传递，则直接使用</span><br>    <span class="hljs-keyword">if</span> (explicitArgs != <span class="hljs-literal">null</span>) &#123;<br>        argsToUse = explicitArgs;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 尝试从缓存中获取</span><br>        Object[] argsToResolve = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;<br>            <span class="hljs-comment">// 缓存中的构造函数或者工厂方法</span><br>            constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;<br>            <span class="hljs-keyword">if</span> (constructorToUse != <span class="hljs-literal">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;<br>                <span class="hljs-comment">// Found a cached constructor...</span><br>                <span class="hljs-comment">// 缓存中的构造参数</span><br>                argsToUse = mbd.resolvedConstructorArguments;<br>                <span class="hljs-keyword">if</span> (argsToUse == <span class="hljs-literal">null</span>) &#123;<br>                    argsToResolve = mbd.preparedConstructorArguments;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 缓存中存在,则解析存储在 BeanDefinition 中的参数</span><br>        <span class="hljs-comment">// 如给定方法的构造函数 A(int ,int )，则通过此方法后就会把配置文件中的(&quot;1&quot;,&quot;1&quot;)转换为 (1,1)</span><br>        <span class="hljs-comment">// 缓存中的值可能是原始值也有可能是最终值</span><br>        <span class="hljs-keyword">if</span> (argsToResolve != <span class="hljs-literal">null</span>) &#123;<br>            argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 没有缓存，则尝试从配置文件中获取参数</span><br>    <span class="hljs-keyword">if</span> (constructorToUse == <span class="hljs-literal">null</span> || argsToUse == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Take specified constructors, if any.</span><br>        <span class="hljs-comment">// 如果 chosenCtors 未传入，则获取构造方法们</span><br>        Constructor&lt;?&gt;[] candidates = chosenCtors;<br>        <span class="hljs-keyword">if</span> (candidates == <span class="hljs-literal">null</span>) &#123;<br>            Class&lt;?&gt; beanClass = mbd.getBeanClass();<br>            <span class="hljs-keyword">try</span> &#123;<br>                candidates = (mbd.isNonPublicAccessAllowed() ?<br>                              beanClass.getDeclaredConstructors() : beanClass.getConstructors());<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                                                <span class="hljs-string">&quot;Resolution of declared constructors on bean Class [&quot;</span> + beanClass.getName() +<br>                                                <span class="hljs-string">&quot;] from ClassLoader [&quot;</span> + beanClass.getClassLoader() + <span class="hljs-string">&quot;] failed&quot;</span>, ex);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//创建 Bean</span><br>        <span class="hljs-keyword">if</span> (candidates.length == <span class="hljs-number">1</span> &amp;&amp; explicitArgs == <span class="hljs-literal">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;<br>            Constructor&lt;?&gt; uniqueCandidate = candidates[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;<br>                    mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;<br>                    mbd.constructorArgumentsResolved = <span class="hljs-literal">true</span>;<br>                    mbd.resolvedConstructorArguments = EMPTY_ARGS;<br>                &#125;<br>                bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));<br>                <span class="hljs-keyword">return</span> bw;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Need to resolve the constructor.</span><br>        <span class="hljs-comment">// 是否需要解析构造器</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autowiring</span> <span class="hljs-operator">=</span> (chosenCtors != <span class="hljs-literal">null</span> ||<br>                              mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);<br>        <span class="hljs-comment">// 用于承载解析后的构造函数参数的值</span><br>        <span class="hljs-type">ConstructorArgumentValues</span> <span class="hljs-variable">resolvedValues</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">int</span> minNrOfArgs;<br>        <span class="hljs-keyword">if</span> (explicitArgs != <span class="hljs-literal">null</span>) &#123;<br>            minNrOfArgs = explicitArgs.length;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 从 BeanDefinition 中获取构造参数，也就是从配置文件中提取构造参数</span><br>            <span class="hljs-type">ConstructorArgumentValues</span> <span class="hljs-variable">cargs</span> <span class="hljs-operator">=</span> mbd.getConstructorArgumentValues();<br>            resolvedValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstructorArgumentValues</span>();<br>            <span class="hljs-comment">// 解析构造函数的参数</span><br>            <span class="hljs-comment">// 将该 bean 的构造函数参数解析为 resolvedValues 对象，其中会涉及到其他 bean</span><br>            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);<br>        &#125;<br><br>        <span class="hljs-comment">// 对构造函数进行排序处理</span><br>        <span class="hljs-comment">// public 构造函数优先参数数量降序，非public 构造函数参数数量降序</span><br>        AutowireUtils.sortConstructors(candidates);<br>        <span class="hljs-comment">// 最小参数类型权重</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">minTypeDiffWeight</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = <span class="hljs-literal">null</span>;<br>        Deque&lt;UnsatisfiedDependencyException&gt; causes = <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// 迭代所有构造函数</span><br>        <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; candidate : candidates) &#123;<br>            <span class="hljs-comment">// 获取该构造函数的参数类型</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">parameterCount</span> <span class="hljs-operator">=</span> candidate.getParameterCount();<br><br>            <span class="hljs-comment">// 如果已经找到选用的构造函数或者需要的参数个数小于当前的构造函数参数个数，则终止。</span><br>            <span class="hljs-comment">// 因为，已经按照参数个数降序排列了</span><br>            <span class="hljs-keyword">if</span> (constructorToUse != <span class="hljs-literal">null</span> &amp;&amp; argsToUse != <span class="hljs-literal">null</span> &amp;&amp; argsToUse.length &gt; parameterCount) &#123;<br>                <span class="hljs-comment">// Already found greedy constructor that can be satisfied -&gt;</span><br>                <span class="hljs-comment">// do not look any further, there are only less greedy constructors left.</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 参数个数不等，继续</span><br>            <span class="hljs-keyword">if</span> (parameterCount &lt; minNrOfArgs) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 参数持有者 ArgumentsHolder 对象</span><br>            ArgumentsHolder argsHolder;<br>            Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();<br>            <span class="hljs-keyword">if</span> (resolvedValues != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 注释上获取参数名称</span><br>                    String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, parameterCount);<br>                    <span class="hljs-keyword">if</span> (paramNames == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">// 获取构造函数、方法参数的探测器</span><br>                        <span class="hljs-type">ParameterNameDiscoverer</span> <span class="hljs-variable">pnd</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.beanFactory.getParameterNameDiscoverer();<br>                        <span class="hljs-keyword">if</span> (pnd != <span class="hljs-literal">null</span>) &#123;<br>                            <span class="hljs-comment">// 通过探测器获取构造函数的参数名称</span><br>                            paramNames = pnd.getParameterNames(candidate);<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// 根据构造函数和构造参数，创建参数持有者 ArgumentsHolder 对象</span><br>                    argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,<br>                                                     getUserDeclaredConstructor(candidate), autowiring, candidates.length == <span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;<br>                    <span class="hljs-comment">// 若发生 UnsatisfiedDependencyException 异常，添加到 causes 中。</span><br>                    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                        logger.trace(<span class="hljs-string">&quot;Ignoring constructor [&quot;</span> + candidate + <span class="hljs-string">&quot;] of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;: &quot;</span> + ex);<br>                    &#125;<br>                    <span class="hljs-comment">// Swallow and try next constructor.</span><br>                    <span class="hljs-keyword">if</span> (causes == <span class="hljs-literal">null</span>) &#123;<br>                        causes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(<span class="hljs-number">1</span>);<br>                    &#125;<br>                    causes.add(ex);<br>                    <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// continue ，继续执行</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 构造函数没有参数</span><br>                <span class="hljs-comment">// Explicit arguments given -&gt; arguments length must match exactly.</span><br>                <span class="hljs-keyword">if</span> (parameterCount != explicitArgs.length) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 根据 explicitArgs ，创建 ArgumentsHolder 对象</span><br>                argsHolder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArgumentsHolder</span>(explicitArgs);<br>            &#125;<br><br>            <span class="hljs-comment">// isLenientConstructorResolution 判断解析构造函数的时候是否以宽松模式还是严格模式</span><br>            <span class="hljs-comment">// 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常</span><br>            <span class="hljs-comment">// 宽松模式：使用具有&quot;最接近的模式&quot;进行匹配</span><br>            <span class="hljs-comment">// typeDiffWeight：类型差异权重</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">typeDiffWeight</span> <span class="hljs-operator">=</span> (mbd.isLenientConstructorResolution() ?<br>                                  argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));<br>            <span class="hljs-comment">// Choose this constructor if it represents the closest match.</span><br>            <span class="hljs-comment">// 如果它代表着当前最接近的匹配则选择其作为构造函数</span><br>            <span class="hljs-keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;<br>                constructorToUse = candidate;<br>                argsHolderToUse = argsHolder;<br>                argsToUse = argsHolder.arguments;<br>                minTypeDiffWeight = typeDiffWeight;<br>                ambiguousConstructors = <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (constructorToUse != <span class="hljs-literal">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;<br>                <span class="hljs-keyword">if</span> (ambiguousConstructors == <span class="hljs-literal">null</span>) &#123;<br>                    ambiguousConstructors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>                    ambiguousConstructors.add(constructorToUse);<br>                &#125;<br>                ambiguousConstructors.add(candidate);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 没有可执行的工厂方法，抛出异常</span><br>        <span class="hljs-keyword">if</span> (constructorToUse == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (causes != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">UnsatisfiedDependencyException</span> <span class="hljs-variable">ex</span> <span class="hljs-operator">=</span> causes.removeLast();<br>                <span class="hljs-keyword">for</span> (Exception cause : causes) &#123;<br>                    <span class="hljs-built_in">this</span>.beanFactory.onSuppressedException(cause);<br>                &#125;<br>                <span class="hljs-keyword">throw</span> ex;<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                                            <span class="hljs-string">&quot;Could not resolve matching constructor &quot;</span> +<br>                                            <span class="hljs-string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ambiguousConstructors != <span class="hljs-literal">null</span> &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                                            <span class="hljs-string">&quot;Ambiguous constructor matches found in bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; &quot;</span> +<br>                                            <span class="hljs-string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot;</span> +<br>                                            ambiguousConstructors);<br>        &#125;<br><br>        <span class="hljs-comment">// 将解析的构造函数加入缓存</span><br>        <span class="hljs-keyword">if</span> (explicitArgs == <span class="hljs-literal">null</span> &amp;&amp; argsHolderToUse != <span class="hljs-literal">null</span>) &#123;<br>            argsHolderToUse.storeCache(mbd, constructorToUse);<br>        &#125;<br>    &#125;<br><br>    Assert.state(argsToUse != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Unresolved constructor arguments&quot;</span>);<br>    <span class="hljs-comment">// 创建 Bean 对象，并设置到 bw 中</span><br>    bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));<br>    <span class="hljs-keyword">return</span> bw;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一句话概括：首先确定构造函数参数、构造函数，然后调用相应的初始化策略进行 bean 的初始化。关于如何确定构造函数、构造参数，该部分逻辑和 <code>instantiateUsingFactoryMethod(...)</code> 方法，基本一致。</li></ul><h5 id="instantiate"><a href="#instantiate" class="headerlink" title="instantiate"></a><code>instantiate</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">instantiate</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd,</span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> Object factoryBean, Method factoryMethod, Object[] args)</span> &#123;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;<br>                                                 <span class="hljs-built_in">this</span>.beanFactory.getInstantiationStrategy().instantiate(<br>    mbd, beanName, <span class="hljs-built_in">this</span>.beanFactory, factoryBean, factoryMethod, args),<br>                                                 <span class="hljs-built_in">this</span>.beanFactory.getAccessControlContext());<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.beanFactory.getInstantiationStrategy().instantiate(<br>                mbd, beanName, <span class="hljs-built_in">this</span>.beanFactory, factoryBean, factoryMethod, args);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                                        <span class="hljs-string">&quot;Bean instantiation via factory method failed&quot;</span>, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先，是获取实例化 Bean 的策略 InstantiationStrategy 对象。</li><li>然后，调用其 <code>instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner, Constructor ctor, Object... args)</code> 方法，该方法在 SimpleInstantiationStrategy 中实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SimpleInstantiationStrategy.java</span><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">instantiate</span><span class="hljs-params">(RootBeanDefinition bd, <span class="hljs-meta">@Nullable</span> String beanName, BeanFactory owner,<span class="hljs-keyword">final</span> Constructor&lt;?&gt; ctor, Object... args)</span> &#123;<br><br>    <span class="hljs-comment">// &lt;x1&gt; 没有覆盖，直接使用反射实例化即可</span><br>    <span class="hljs-keyword">if</span> (!bd.hasMethodOverrides()) &#123;<br>        <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// use own privileged to change accessibility (when security is on)</span><br>            <span class="hljs-comment">// 设置构造方法，可访问</span><br>            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;<br>                ReflectionUtils.makeAccessible(ctor);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">// 通过 BeanUtils 直接使用构造器对象实例化 Bean 对象</span><br>        <span class="hljs-keyword">return</span> BeanUtils.instantiateClass(ctor, args);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// &lt;x2&gt; 生成 CGLIB 创建的子类对象</span><br>        <span class="hljs-keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner, ctor, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>&lt;1&gt;</code> 如果该 bean 没有配置 <code>lookup-method</code>、<code>replaced-method</code> 标签或者 <code>@Lookup</code> 注解，则直接通过<strong>反射</strong>的方式实例化 Bean 对象即可，方便快捷。</li><li><code>&lt;2&gt;</code> 但是，如果存在需要覆盖的方法或者动态替换的方法时，则需要使用 CGLIB 进行动态代理，因为可以在创建代理的同时将动态方法织入类中。</li></ul><h6 id="反射创建-Bean-对象"><a href="#反射创建-Bean-对象" class="headerlink" title="反射创建 Bean 对象"></a>反射创建 Bean 对象</h6><p>调用工具类 BeanUtils 的 <code>instantiateClass(Constructor ctor, Object... args)</code> 方法，完成反射工作，创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// BeanUtils.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">instantiateClass</span><span class="hljs-params">(Constructor&lt;T&gt; ctor, Object... args)</span> <span class="hljs-keyword">throws</span> BeanInstantiationException &#123;<br>    Assert.notNull(ctor, <span class="hljs-string">&quot;Constructor must not be null&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 设置构造方法，可访问</span><br>        ReflectionUtils.makeAccessible(ctor);<br>        <span class="hljs-keyword">if</span> (KotlinDetector.isKotlinReflectPresent() &amp;&amp; KotlinDetector.isKotlinType(ctor.getDeclaringClass())) &#123;<br>            <span class="hljs-comment">// 使用构造方法，创建对象</span><br>            <span class="hljs-keyword">return</span> KotlinDelegate.instantiateClass(ctor, args);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            Class&lt;?&gt;[] parameterTypes = ctor.getParameterTypes();<br>            Assert.isTrue(args.length &lt;= parameterTypes.length, <span class="hljs-string">&quot;Can&#x27;t specify more arguments than constructor parameters&quot;</span>);<br>            Object[] argsWithDefaultValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[args.length];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; args.length; i++) &#123;<br>                <span class="hljs-keyword">if</span> (args[i] == <span class="hljs-literal">null</span>) &#123;<br>                    Class&lt;?&gt; parameterType = parameterTypes[i];<br>                    argsWithDefaultValues[i] = (parameterType.isPrimitive() ? DEFAULT_TYPE_VALUES.get(parameterType) : <span class="hljs-literal">null</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    argsWithDefaultValues[i] = args[i];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ctor.newInstance(argsWithDefaultValues);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 各种异常的翻译，最终统一抛出 BeanInstantiationException 异常</span><br>    <span class="hljs-keyword">catch</span> (InstantiationException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(ctor, <span class="hljs-string">&quot;Is it an abstract class?&quot;</span>, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IllegalAccessException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(ctor, <span class="hljs-string">&quot;Is the constructor accessible?&quot;</span>, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IllegalArgumentException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(ctor, <span class="hljs-string">&quot;Illegal arguments for constructor&quot;</span>, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (InvocationTargetException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(ctor, <span class="hljs-string">&quot;Constructor threw exception&quot;</span>, ex.getTargetException());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="CGLIB-创建-Bean-对象"><a href="#CGLIB-创建-Bean-对象" class="headerlink" title="CGLIB 创建 Bean 对象"></a>CGLIB 创建 Bean 对象</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SimpleInstantiationStrategy.java</span><br><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">instantiateWithMethodInjection</span><span class="hljs-params">(RootBeanDefinition bd, <span class="hljs-meta">@Nullable</span> String beanName, BeanFactory owner)</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;Method Injection not supported in SimpleInstantiationStrategy&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法默认是<strong>没有实现</strong>的，具体过程由其子类 <code>org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy</code> 来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// CglibSubclassingInstantiationStrategy.java</span><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">instantiateWithMethodInjection</span><span class="hljs-params">(RootBeanDefinition bd, <span class="hljs-meta">@Nullable</span> String beanName, BeanFactory owner)</span> &#123;<br>    <span class="hljs-keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner, <span class="hljs-literal">null</span>);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">instantiateWithMethodInjection</span><span class="hljs-params">(RootBeanDefinition bd, <span class="hljs-meta">@Nullable</span> String beanName, BeanFactory owner, <span class="hljs-meta">@Nullable</span> Constructor&lt;?&gt; ctor, Object... args)</span> &#123;<br>    <span class="hljs-comment">// Must generate CGLIB subclass...</span><br>    <span class="hljs-comment">// 通过CGLIB生成一个子类对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CglibSubclassCreator</span>(bd, owner).instantiate(ctor, args);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>创建一个 CglibSubclassCreator 对象，后调用其 <code>instantiate(Constructor ctor, Object... args)</code> 方法，生成其子类对象。</p><p><strong>注：</strong><code>CglibSubclassCreator</code>是个内部类。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// CglibSubclassingInstantiationStrategy.java</span><br><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">instantiate</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Constructor&lt;?&gt; ctor, Object... args)</span> &#123;<br>    <span class="hljs-comment">// 通过 Cglib 创建一个代理类</span><br>    Class&lt;?&gt; subclass = createEnhancedSubclass(<span class="hljs-built_in">this</span>.beanDefinition);<br>    Object instance;<br>    <span class="hljs-comment">// 没有构造器，通过 BeanUtils 使用默认构造器创建一个bean实例</span><br>    <span class="hljs-keyword">if</span> (ctor == <span class="hljs-literal">null</span>) &#123;<br>        instance = BeanUtils.instantiateClass(subclass);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取代理类对应的构造器对象，并实例化 bean</span><br>            Constructor&lt;?&gt; enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());<br>            instance = enhancedSubclassConstructor.newInstance(args);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(<span class="hljs-built_in">this</span>.beanDefinition.getBeanClass(),<br>                    <span class="hljs-string">&quot;Failed to invoke constructor for CGLIB enhanced subclass [&quot;</span> + subclass.getName() + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// SPR-10785: set callbacks directly on the instance instead of in the</span><br>    <span class="hljs-comment">// enhanced class (via the Enhancer) in order to avoid memory leaks.</span><br>    <span class="hljs-comment">// 为了避免 memory leaks 异常，直接在 bean 实例上设置回调对象</span><br>    <span class="hljs-type">Factory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> (Factory) instance;<br>    factory.setCallbacks(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>[] &#123;NoOp.INSTANCE,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LookupOverrideMethodInterceptor</span>(<span class="hljs-built_in">this</span>.beanDefinition, <span class="hljs-built_in">this</span>.owner),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReplaceOverrideMethodInterceptor</span>(<span class="hljs-built_in">this</span>.beanDefinition, <span class="hljs-built_in">this</span>.owner)&#125;);<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="instantiateBean-方法"><a href="#instantiateBean-方法" class="headerlink" title="instantiateBean()方法"></a><code>instantiateBean()</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><br><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title function_">instantiateBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> RootBeanDefinition mbd)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object beanInstance;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">BeanFactory</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-comment">// 安全模式</span><br>        <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>            beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;<br>                    <span class="hljs-comment">// 获得 InstantiationStrategy 对象，并使用它，创建 Bean 对象</span><br>                    getInstantiationStrategy().instantiate(mbd, beanName, parent),<br>                    getAccessControlContext());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 获得 InstantiationStrategy 对象，并使用它，创建 Bean 对象</span><br>            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);<br>        &#125;<br>        <span class="hljs-comment">// 封装 BeanWrapperImpl  并完成初始化</span><br>        <span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanWrapperImpl</span>(beanInstance);<br>        initBeanWrapper(bw);<br>        <span class="hljs-keyword">return</span> bw;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>                mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Instantiation of bean failed&quot;</span>, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="instantiate-方法"><a href="#instantiate-方法" class="headerlink" title="instantiate()方法"></a><code>instantiate()</code>方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SimpleInstantiationStrategy.java</span><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">instantiate</span><span class="hljs-params">(RootBeanDefinition bd, <span class="hljs-meta">@Nullable</span> String beanName, BeanFactory owner)</span> &#123;<br>    <span class="hljs-comment">// Don&#x27;t override the class with CGLIB if no overrides.</span><br>    <span class="hljs-comment">// 没有覆盖，直接使用反射实例化即可</span><br>    <span class="hljs-keyword">if</span> (!bd.hasMethodOverrides()) &#123;<br>        Constructor&lt;?&gt; constructorToUse;<br>        <span class="hljs-keyword">synchronized</span> (bd.constructorArgumentLock) &#123;<br>            <span class="hljs-comment">// 获得构造方法 constructorToUse</span><br>            constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;<br>            <span class="hljs-keyword">if</span> (constructorToUse == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();<br>                <span class="hljs-comment">// 如果是接口，抛出 BeanInstantiationException 异常</span><br>                <span class="hljs-keyword">if</span> (clazz.isInterface()) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(clazz, <span class="hljs-string">&quot;Specified class is an interface&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 从 clazz 中，获得构造方法</span><br>                    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 安全模式</span><br>                        constructorToUse = AccessController.doPrivileged(<br>                                (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        constructorToUse =  clazz.getDeclaredConstructor();<br>                    &#125;<br>                    <span class="hljs-comment">// 标记 resolvedConstructorOrFactoryMethod 属性</span><br>                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(clazz, <span class="hljs-string">&quot;No default constructor found&quot;</span>, ex);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 通过 BeanUtils 直接使用构造器对象实例化 Bean 对象</span><br>        <span class="hljs-keyword">return</span> BeanUtils.instantiateClass(constructorToUse);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Must generate CGLIB subclass.</span><br>        <span class="hljs-comment">// 生成 CGLIB 创建的子类对象</span><br>        <span class="hljs-keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对于 <code>createBeanInstance(...)</code> 方法而言，他就是<strong>选择合适实例化策略</strong>来为 bean 创建实例对象，具体的策略有：</p><ul><li>Supplier 回调方式</li><li>工厂方法初始化</li><li>构造函数自动注入初始化</li><li>默认构造函数注入。</li></ul><p>其中，工厂方法初始化和构造函数自动注入初始化两种方式<strong>最为复杂</strong>，主要是因为构造函数和构造参数的不确定性，Spring 需要花大量的精力来确定构造函数和构造参数，如果确定了则好办，直接选择实例化策略即可。</p><p>当然，在实例化的时候会根据是否有需要覆盖或者动态替换掉的方法，因为存在覆盖或者织入的话需要创建动态代理将方法织入，这个时候就只能选择 CGLIB 的方式来实例化，否则直接利用反射的方式即可，方便快捷。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二十三、创建Bean之属性填充</title>
    <link href="/2022/06/11/%E5%88%9B%E5%BB%BABean%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%A1%AB%E5%85%85/"/>
    <url>/2022/06/11/%E5%88%9B%E5%BB%BABean%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%A1%AB%E5%85%85/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">创建Bean之属性填充</font></div><p><code>doCreateBean(...)</code> 方法，主要用于完成 bean 的创建和初始化工作，我们可以将其分为四个过程：</p><ul><li><code>createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args)</code> 方法，实例化 bean 。</li><li>循环依赖的处理。</li><li><code>populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</code> 方法，进行属性填充。</li><li><code>initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd)</code> 方法，初始化 Bean 。</li></ul><h4 id="populateBean-方法"><a href="#populateBean-方法" class="headerlink" title="populateBean()方法"></a><code>populateBean()</code>方法</h4><p>该函数的作用是将 BeanDefinition 中的属性值赋值给 BeanWrapper 实例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;deprecation&quot;)</span>  <span class="hljs-comment">// for postProcessPropertyValues</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">populateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> BeanWrapper bw)</span> &#123;<br>    <span class="hljs-comment">// 没有实例化对象</span><br>    <span class="hljs-keyword">if</span> (bw == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 有属性，则抛出 BeanCreationException 异常</span><br>        <span class="hljs-keyword">if</span> (mbd.hasPropertyValues()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>                mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Cannot apply property values to null instance&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Skip property population phase for null instance.</span><br>            <span class="hljs-comment">// 没有属性，直接 return 返回</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;1&gt; 在设置属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会</span><br>    <span class="hljs-keyword">if</span> (!mbd.isSynthetic()  <span class="hljs-comment">// bean 不是&quot;合成&quot;的，即未由应用程序本身定义</span><br>        &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<span class="hljs-comment">// 是否持有 InstantiationAwareBeanPostProcessor</span><br>        <span class="hljs-comment">// 迭代所有的 BeanPostProcessors</span><br>        <span class="hljs-keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;<br>            <span class="hljs-comment">//此处for循环内和之前版本不一样，该处使用了缓存</span><br>            <span class="hljs-comment">// 返回值为是否继续填充 bean</span><br>            <span class="hljs-comment">// postProcessAfterInstantiation：如果应该在 bean上面设置属性则返回 true，否则返回 false</span><br>            <span class="hljs-comment">// 一般情况下，应该是返回true 。</span><br>            <span class="hljs-comment">// 返回 false 的话，将会阻止在此 Bean 实例上调用任何后续的 InstantiationAwareBeanPostProcessor 实例。</span><br>            <span class="hljs-keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// bean 的属性值</span><br>    <span class="hljs-type">PropertyValues</span> <span class="hljs-variable">pvs</span> <span class="hljs-operator">=</span> (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="hljs-literal">null</span>);<br><br>    <span class="hljs-comment">// &lt;2&gt; 自动注入</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">resolvedAutowireMode</span> <span class="hljs-operator">=</span> mbd.getResolvedAutowireMode();<br>    <span class="hljs-keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;<br>        <span class="hljs-comment">// 将 PrbuopertyValues 封装成 MutablePropertyValues 对象</span><br>        <span class="hljs-comment">// MutablePropertyValues 允许对属性进行简单的操作，并提供构造函数以支持Map的深度复制和构造。</span><br>        <span class="hljs-type">MutablePropertyValues</span> <span class="hljs-variable">newPvs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutablePropertyValues</span>(pvs);<br>        <span class="hljs-comment">// Add property values based on autowire by name if applicable.</span><br>        <span class="hljs-comment">// 根据名称自动注入</span><br>        <span class="hljs-keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;<br>            autowireByName(beanName, mbd, bw, newPvs);<br>        &#125;<br>        <span class="hljs-comment">// Add property values based on autowire by type if applicable.</span><br>        <span class="hljs-comment">// 根据类型自动注入</span><br>        <span class="hljs-keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;<br>            autowireByType(beanName, mbd, bw, newPvs);<br>        &#125;<br>        pvs = newPvs;<br>    &#125;<br><br>    <span class="hljs-comment">// 是否已经注册了 InstantiationAwareBeanPostProcessors</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">hasInstAwareBpps</span> <span class="hljs-operator">=</span> hasInstantiationAwareBeanPostProcessors();<br>    <span class="hljs-comment">// 是否需要进行【依赖检查】</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">needsDepCheck</span> <span class="hljs-operator">=</span> (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);<br><br>    <span class="hljs-comment">// &lt;3&gt; BeanPostProcessor 处理</span><br>    PropertyDescriptor[] filteredPds = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (hasInstAwareBpps) &#123;<br>        <span class="hljs-keyword">if</span> (pvs == <span class="hljs-literal">null</span>) &#123;<br>            pvs = mbd.getPropertyValues();<br>        &#125;<br>        <span class="hljs-comment">// 遍历 BeanPostProcessor 数组</span><br>        <span class="hljs-comment">// 此处for循环内和之前版本不一样，该处使用了缓存</span><br>        <span class="hljs-keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;<br>            <span class="hljs-comment">// 对所有需要依赖检查的属性进行后处理</span><br>            <span class="hljs-type">PropertyValues</span> <span class="hljs-variable">pvsToUse</span> <span class="hljs-operator">=</span> bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);<br>            <span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 从 bw 对象中提取 PropertyDescriptor 结果集</span><br>                <span class="hljs-comment">// PropertyDescriptor：可以通过一对存取方法提取一个属性</span><br>                <span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-literal">null</span>) &#123;<br>                    filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);<br>                &#125;<br>                pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);<br>                <span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            pvs = pvsToUse;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// &lt;4&gt; 依赖检查</span><br>    <span class="hljs-keyword">if</span> (needsDepCheck) &#123;<br>        <span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-literal">null</span>) &#123;<br>            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);<br>        &#125;<br>        <span class="hljs-comment">// 依赖检查，对应 depends-on 属性</span><br>        checkDependencies(beanName, mbd, filteredPds, pvs);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;5&gt; 将属性应用到 bean 中</span><br>    <span class="hljs-keyword">if</span> (pvs != <span class="hljs-literal">null</span>) &#123;<br>        applyPropertyValues(beanName, mbd, bw, pvs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>处理过程如下：</p><ul><li><p><code>&lt;1&gt;</code> ，根据 <code>hasInstantiationAwareBeanPostProcessors</code> 属性来判断，是否需要在注入属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会。<strong>此过程可以控制 Spring 是否继续进行属性填充</strong>。</p></li><li><p>统一存入到 PropertyValues 中，PropertyValues 用于描述 bean 的属性。</p><p><code>&lt;2&gt;</code> ，根据注入类型( <code>AbstractBeanDefinition.getResolvedAutowireMode()</code> 方法的返回值 )的不同来判断：是根据名称来自动注入（autowireByName(…)），还是根据类型来自动注入（autowireByType(…)）。</p></li></ul><ul><li><code>&lt;3&gt;</code> ，进行 BeanPostProcessor 处理。</li><li><code>&lt;4&gt;</code> ，依赖检测。</li><li><code>&lt;5&gt;</code> ，将所有 PropertyValues 中的属性，填充到 BeanWrapper 中。</li></ul><h5 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h5><p>Spring 会根据注入类型（ <code>byName</code> &#x2F; <code>byType</code> ）的不同，调用不同的方法来注入属性值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstractAutowireCapableBeanFactory</span><br><span class="hljs-type">int</span> <span class="hljs-variable">resolvedAutowireMode</span> <span class="hljs-operator">=</span> mbd.getResolvedAutowireMode();<br><br><span class="hljs-comment">// AbstractBeanDefinition.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">autowireMode</span> <span class="hljs-operator">=</span> AUTOWIRE_NO;<span class="hljs-comment">//0</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResolvedAutowireMode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.autowireMode == AUTOWIRE_AUTODETECT) &#123;<span class="hljs-comment">// 自动检测模式，获得对应的检测模式</span><br>        Constructor&lt;?&gt;[] constructors = getBeanClass().getConstructors();<br>        <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;<br>            <span class="hljs-keyword">if</span> (constructor.getParameterCount() == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> AUTOWIRE_BY_TYPE;<span class="hljs-comment">//2</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> AUTOWIRE_CONSTRUCTOR;<span class="hljs-comment">//3</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.autowireMode;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="autowireByName-方法"><a href="#autowireByName-方法" class="headerlink" title="autowireByName()方法"></a><code>autowireByName()</code>方法</h6><p>该方法，是根据<strong>属性名称</strong>，完成自动依赖注入的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autowireByName</span><span class="hljs-params">(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> &#123;<br><br>    <span class="hljs-comment">// &lt;1&gt; 对 Bean 对象中非简单属性</span><br>    <span class="hljs-comment">// 非简单属性：类型为对象类型的属性，但这里并不是将所有的对象类型都会找到，比如8个原始类型，String类型、Number类型、Date类型等会被忽略</span><br>    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);<br>    <span class="hljs-comment">// 遍历 propertyName 数组</span><br>    <span class="hljs-keyword">for</span> (String propertyName : propertyNames) &#123;<br>        <span class="hljs-comment">// 如果容器中包含指定名称的 bean，则将该 bean 注入到 bean中</span><br>        <span class="hljs-keyword">if</span> (containsBean(propertyName)) &#123;<br>            <span class="hljs-comment">// 递归初始化相关 bean</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> getBean(propertyName);<br>            <span class="hljs-comment">// 为指定名称的属性赋予属性值</span><br>            pvs.add(propertyName, bean);<br>            <span class="hljs-comment">// &lt;2&gt; 属性依赖注入</span><br>            registerDependentBean(propertyName, beanName);<br>            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                logger.trace(<span class="hljs-string">&quot;Added autowiring by name from bean name &#x27;&quot;</span> + beanName +<br>                             <span class="hljs-string">&quot;&#x27; via property &#x27;&quot;</span> + propertyName + <span class="hljs-string">&quot;&#x27; to bean named &#x27;&quot;</span> + propertyName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                logger.trace(<span class="hljs-string">&quot;Not autowiring property &#x27;&quot;</span> + propertyName + <span class="hljs-string">&quot;&#x27; of bean &#x27;&quot;</span> + beanName +<br>                             <span class="hljs-string">&quot;&#x27; by name: no matching bean found&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>&lt;1&gt;</code> 处，获取该 bean 的非简单属性。非简单属性就是类型为对象类型的属性，但是这里并不是将所有的对象类型都都会找到，比如 8 个原始类型，String 类型 ，Number类型、Date类型、URL类型、URI类型等都会被忽略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw) &#123;<br>    <span class="hljs-comment">// 创建 result 集合</span><br>    Set&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>    <span class="hljs-type">PropertyValues</span> <span class="hljs-variable">pvs</span> <span class="hljs-operator">=</span> mbd.getPropertyValues();<br>    <span class="hljs-comment">// 遍历 PropertyDescriptor 数组</span><br>    PropertyDescriptor[] pds = bw.getPropertyDescriptors();<br>    <span class="hljs-keyword">for</span> (PropertyDescriptor pd : pds) &#123;<br>        <span class="hljs-keyword">if</span> (pd.getWriteMethod() != <span class="hljs-literal">null</span> <span class="hljs-comment">// 有可写方法</span><br>            &amp;&amp; !isExcludedFromDependencyCheck(pd) <span class="hljs-comment">// 依赖检测中没有被忽略</span><br>            &amp;&amp; !pvs.contains(pd.getName()) &amp;&amp;<span class="hljs-comment">// pvs 不包含该属性名</span><br>            !BeanUtils.isSimpleProperty(pd.getPropertyType())) &#123; <span class="hljs-comment">// 不是简单属性类型</span><br>            result.add(pd.getName());<span class="hljs-comment">// 添加到 result 中</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> StringUtils.toStringArray(result);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>过滤<strong>条件</strong>为：有可写方法、依赖检测中没有被忽略、不是简单属性类型。</li><li>过滤<strong>结果</strong>为：其实这里获取的就是需要依赖注入的属性。</li></ul></li><li><p>&lt;2&gt;处，获取需要依赖注入的属性后，通过迭代、递归的方式初始化相关的 bean ，然后调用 <code>registerDependentBean(String beanName, String dependentBeanName)</code> 方法，完成注册依赖。该方法之前《parentBeanFactory和依赖处理》已经分析过了。</p></li></ul><h6 id="autowireByType-方法"><a href="#autowireByType-方法" class="headerlink" title="autowireByType()方法"></a><code>autowireByType()</code>方法</h6><p>该方法，是根据<strong>属性类型</strong>，完成自动依赖注入的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autowireByType</span><span class="hljs-params">(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> &#123;<br><br>    <span class="hljs-comment">// 获取 TypeConverter 实例</span><br>    <span class="hljs-comment">// 使用自定义的 TypeConverter，用于取代默认的 PropertyEditor 机制</span><br>    <span class="hljs-type">TypeConverter</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> getCustomTypeConverter();<br>    <span class="hljs-keyword">if</span> (converter == <span class="hljs-literal">null</span>) &#123;<br>        converter = bw;<br>    &#125;<br><br>    Set&lt;String&gt; autowiredBeanNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(<span class="hljs-number">4</span>);<br>    <span class="hljs-comment">// 获取非简单属性</span><br>    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);<br>    <span class="hljs-comment">// 遍历 PROPERTYNAME 数组</span><br>    <span class="hljs-keyword">for</span> (String propertyName : propertyNames) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取 PropertyDescriptor 实例</span><br>            <span class="hljs-type">PropertyDescriptor</span> <span class="hljs-variable">pd</span> <span class="hljs-operator">=</span> bw.getPropertyDescriptor(propertyName);<br>            <span class="hljs-comment">// 不要尝试按类型</span><br>            <span class="hljs-keyword">if</span> (Object.class != pd.getPropertyType()) &#123;<br>                <span class="hljs-comment">// 探测指定属性的 set 方法</span><br>                <span class="hljs-type">MethodParameter</span> <span class="hljs-variable">methodParam</span> <span class="hljs-operator">=</span> BeanUtils.getWriteMethodParameter(pd);<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">eager</span> <span class="hljs-operator">=</span> !(bw.getWrappedInstance() <span class="hljs-keyword">instanceof</span> PriorityOrdered);<br>                <span class="hljs-type">DependencyDescriptor</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutowireByTypeDependencyDescriptor</span>(methodParam, eager);<br>                <span class="hljs-comment">// &lt;1&gt;解析指定 beanName 的属性所匹配的值，并把解析到的属性名称存储在 autowiredBeanNames 中</span><br>                <span class="hljs-comment">// 当属性存在多个封装 bean 时将会找到所有匹配的 bean 并将其注入</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">autowiredArgument</span> <span class="hljs-operator">=</span> resolveDependency(desc, beanName, autowiredBeanNames, converter);<br>                <span class="hljs-keyword">if</span> (autowiredArgument != <span class="hljs-literal">null</span>) &#123;<br>                    pvs.add(propertyName, autowiredArgument);<br>                &#125;<br>                <span class="hljs-comment">// 遍历 autowiredBeanName 数组</span><br>                <span class="hljs-keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;<br>                    <span class="hljs-comment">// 属性依赖注入</span><br>                    registerDependentBean(autowiredBeanName, beanName);<br>                    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                        logger.trace(<span class="hljs-string">&quot;Autowiring by type from bean name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; via property &#x27;&quot;</span> +<br>                                     propertyName + <span class="hljs-string">&quot;&#x27; to bean named &#x27;&quot;</span> + autowiredBeanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 清空 autowiredBeanName 数组</span><br>                autowiredBeanNames.clear();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsatisfiedDependencyException</span>(mbd.getResourceDescription(), beanName, propertyName, ex);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实主要过程和根据名称自动注入<strong>差不多</strong>，都是找到需要依赖注入的属性，然后通过迭代的方式寻找所匹配的 bean，最后调用 <code>registerDependentBean(...)</code> 方法，来注册依赖。</p><p>**resolveDependency()**方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultListableBeanFactory.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">resolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, <span class="hljs-meta">@Nullable</span> String requestingBeanName,<span class="hljs-meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="hljs-meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>    <span class="hljs-comment">// 初始化参数名称发现器，该方法并不会在这个时候尝试检索参数名称</span><br>    <span class="hljs-comment">// getParameterNameDiscoverer 返回 parameterNameDiscoverer 实例，parameterNameDiscoverer 方法参数名称的解析器</span><br>    descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());<br>    <span class="hljs-comment">// 依赖类型为 Optional 类型</span><br>    <span class="hljs-keyword">if</span> (Optional.class == descriptor.getDependencyType()) &#123;<br>        <span class="hljs-keyword">return</span> createOptionalDependency(descriptor, requestingBeanName);<br>    &#125;<br>    <span class="hljs-comment">// 依赖类型为ObjectFactory、ObjectProvider</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() ||<br>             ObjectProvider.class == descriptor.getDependencyType()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DependencyObjectProvider</span>(descriptor, requestingBeanName);<br>    &#125;<br>    <span class="hljs-comment">// javaxInjectProviderClass 类注入的特殊处理</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jsr330Factory</span>().createDependencyProvider(descriptor, requestingBeanName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 为实际依赖关系目标的延迟解析构建代理</span><br>        <span class="hljs-comment">// 默认实现返回 null</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(<br>            descriptor, requestingBeanName);<br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 通用处理逻辑</span><br>            result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通用处理逻辑</strong><code>doResolveDependency()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultListableBeanFactory.java</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doResolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, <span class="hljs-meta">@Nullable</span> String beanName,<span class="hljs-meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="hljs-meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>    <span class="hljs-comment">// 注入点</span><br>    <span class="hljs-type">InjectionPoint</span> <span class="hljs-variable">previousInjectionPoint</span> <span class="hljs-operator">=</span> ConstructorResolver.setCurrentInjectionPoint(descriptor);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 针对给定的工厂给定一个快捷实现的方式，例如考虑一些预先解析的信息</span><br>        <span class="hljs-comment">// 在进入所有bean的常规类型匹配算法之前，解析算法将首先尝试通过此方法解析快捷方式。</span><br>        <span class="hljs-comment">// 子类可以覆盖此方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">shortcut</span> <span class="hljs-operator">=</span> descriptor.resolveShortcut(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (shortcut != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 返回快捷的解析信息</span><br>            <span class="hljs-keyword">return</span> shortcut;<br>        &#125;<br><br>        <span class="hljs-comment">// 依赖的类型</span><br>        Class&lt;?&gt; type = descriptor.getDependencyType();<br>        <span class="hljs-comment">// 支持 Spring 的注解 @value</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> getAutowireCandidateResolver().getSuggestedValue(descriptor);<br>        <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> String) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">strVal</span> <span class="hljs-operator">=</span> resolveEmbeddedValue((String) value);<br>                <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> (beanName != <span class="hljs-literal">null</span> &amp;&amp; containsBean(beanName) ?<br>                                     getMergedBeanDefinition(beanName) : <span class="hljs-literal">null</span>);<br>                value = evaluateBeanDefinitionString(strVal, bd);<br>            &#125;<br>            <span class="hljs-type">TypeConverter</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> (typeConverter != <span class="hljs-literal">null</span> ? typeConverter : getTypeConverter());<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (UnsupportedOperationException ex) &#123;<br>                <span class="hljs-comment">// A custom TypeConverter which does not support TypeDescriptor resolution...</span><br>                <span class="hljs-keyword">return</span> (descriptor.getField() != <span class="hljs-literal">null</span> ?<br>                        converter.convertIfNecessary(value, type, descriptor.getField()) :<br>                        converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 解析复合 bean，其实就是对 bean 的属性进行解析</span><br>        <span class="hljs-comment">// 包括：数组、Collection 、Map 类型</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">multipleBeans</span> <span class="hljs-operator">=</span> resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);<br>        <span class="hljs-keyword">if</span> (multipleBeans != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> multipleBeans;<br>        &#125;<br><br>        <span class="hljs-comment">// 查找与类型相匹配的 bean</span><br>        <span class="hljs-comment">// 返回值构成为：key = 匹配的 beanName，value = beanName 对应的实例化 bean</span><br>        Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);<br>        <span class="hljs-comment">// 没有找到，检验 @autowire  的 require 是否为 true</span><br>        <span class="hljs-keyword">if</span> (matchingBeans.isEmpty()) &#123;<br>            <span class="hljs-comment">// 如果 @autowire 的 require 属性为 true ，但是没有找到相应的匹配项，则抛出异常</span><br>            <span class="hljs-keyword">if</span> (isRequired(descriptor)) &#123;<br>                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        String autowiredBeanName;<br>        Object instanceCandidate;<br><br>        <span class="hljs-keyword">if</span> (matchingBeans.size() &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 确认给定 bean autowire 的候选者</span><br>            <span class="hljs-comment">// 按照 @Primary 和 @Priority 的顺序</span><br>            autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);<br>            <span class="hljs-keyword">if</span> (autowiredBeanName == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;<br>                    <span class="hljs-comment">// 唯一性处理</span><br>                    <span class="hljs-keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span><br>                    <span class="hljs-comment">// possibly it was meant to be an empty collection of multiple regular beans</span><br>                    <span class="hljs-comment">// (before 4.3 in particular when we didn&#x27;t even look for collection beans).</span><br>                    <span class="hljs-comment">// 在可选的Collection / Map的情况下，默默地忽略一个非唯一的情况：可能它是一个多个常规bean的空集合</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            instanceCandidate = matchingBeans.get(autowiredBeanName);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// We have exactly one match.</span><br>            Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();<br>            autowiredBeanName = entry.getKey();<br>            instanceCandidate = entry.getValue();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (autowiredBeanNames != <span class="hljs-literal">null</span>) &#123;<br>            autowiredBeanNames.add(autowiredBeanName);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (instanceCandidate <span class="hljs-keyword">instanceof</span> Class) &#123;<br>            instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="hljs-built_in">this</span>);<br>        &#125;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> instanceCandidate;<br>        <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> NullBean) &#123;<br>            <span class="hljs-keyword">if</span> (isRequired(descriptor)) &#123;<br>                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);<br>            &#125;<br>            result = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!ClassUtils.isAssignableValue(type, result)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanNotOfRequiredTypeException</span>(autowiredBeanName, type, instanceCandidate.getClass());<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里就已经完成了所有属性的注入了。</p><ul><li>下一步，则是对依赖 bean 的依赖检测和 PostProcessor 处理（该分析放在最后）。</li></ul><ul><li>最后一步：<code>applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</code> 方法。</li></ul><h5 id="applyPropertyValues-方法"><a href="#applyPropertyValues-方法" class="headerlink" title="applyPropertyValues()方法"></a><code>applyPropertyValues()</code>方法</h5><p>上面只是完成了所有注入属性的获取，将获取的属性封装在 PropertyValues 的实例对象 <code>pvs</code> 中，并没有应用到已经实例化的 bean 中。该方法是<code>populateBean()</code>的最后一步&lt;5&gt;，将属性添加到Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstractAutowireCapableBeanFactory.java</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyPropertyValues</span><span class="hljs-params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> &#123;<br>    <span class="hljs-keyword">if</span> (pvs.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置 BeanWrapperImpl 的 SecurityContext 属性</span><br>    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span> &amp;&amp; bw <span class="hljs-keyword">instanceof</span> BeanWrapperImpl) &#123;<br>        ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());<br>    &#125;<br><br>    <span class="hljs-comment">// MutablePropertyValues 类型属性</span><br>    <span class="hljs-type">MutablePropertyValues</span> <span class="hljs-variable">mpvs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 原始类型</span><br>    List&lt;PropertyValue&gt; original;<br><br>    <span class="hljs-comment">// 获得 original</span><br>    <span class="hljs-keyword">if</span> (pvs <span class="hljs-keyword">instanceof</span> MutablePropertyValues) &#123;<br>        mpvs = (MutablePropertyValues) pvs;<br>        <span class="hljs-comment">// 属性值已经转换</span><br>        <span class="hljs-keyword">if</span> (mpvs.isConverted()) &#123;<br>            <span class="hljs-comment">// Shortcut: use the pre-converted values as-is.</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 为实例化对象设置属性值 ，依赖注入真真正正地实现在此！！！！！</span><br>                bw.setPropertyValues(mpvs);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>                    mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Error setting property values&quot;</span>, ex);<br>            &#125;<br>        &#125;<br>        original = mpvs.getPropertyValueList();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果 pvs 不是 MutablePropertyValues 类型，则直接使用原始类型</span><br>        original = Arrays.asList(pvs.getPropertyValues());<br>    &#125;<br><br>    <span class="hljs-comment">// 获取 TypeConverter = 获取用户自定义的类型转换</span><br>    <span class="hljs-type">TypeConverter</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> getCustomTypeConverter();<br>    <span class="hljs-keyword">if</span> (converter == <span class="hljs-literal">null</span>) &#123;<br>        converter = bw;<br>    &#125;<br>    <span class="hljs-comment">// 获取对应的解析器</span><br>    <span class="hljs-type">BeanDefinitionValueResolver</span> <span class="hljs-variable">valueResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionValueResolver</span>(<span class="hljs-built_in">this</span>, beanName, mbd, converter);<br><br>    <span class="hljs-comment">// Create a deep copy, resolving any references for values.</span><br>    List&lt;PropertyValue&gt; deepCopy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(original.size());<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">resolveNecessary</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 遍历属性，将属性转换为对应类的对应属性的类型</span><br>    <span class="hljs-keyword">for</span> (PropertyValue pv : original) &#123;<br>        <span class="hljs-comment">// 属性值不需要转换</span><br>        <span class="hljs-keyword">if</span> (pv.isConverted()) &#123;<br>            deepCopy.add(pv);<br>        &#125;<br>        <span class="hljs-comment">// 属性值需要转换</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">propertyName</span> <span class="hljs-operator">=</span> pv.getName();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">originalValue</span> <span class="hljs-operator">=</span> pv.getValue();<span class="hljs-comment">// 原始的属性值，即转换之前的属性值</span><br>            <span class="hljs-keyword">if</span> (originalValue == AutowiredPropertyMarker.INSTANCE) &#123;<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">writeMethod</span> <span class="hljs-operator">=</span> bw.getPropertyDescriptor(propertyName).getWriteMethod();<br>                <span class="hljs-keyword">if</span> (writeMethod == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Autowire marker for property without write method: &quot;</span> + pv);<br>                &#125;<br>                originalValue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DependencyDescriptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodParameter</span>(writeMethod, <span class="hljs-number">0</span>), <span class="hljs-literal">true</span>);<br>            &#125;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">resolvedValue</span> <span class="hljs-operator">=</span> valueResolver.resolveValueIfNecessary(pv, originalValue); <span class="hljs-comment">// 转换属性值，例如将引用转换为IoC容器中实例化对象引用 ！！！！！ 对属性值的解析！！</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">convertedValue</span> <span class="hljs-operator">=</span> resolvedValue;<span class="hljs-comment">// 转换之后的属性值</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">convertible</span> <span class="hljs-operator">=</span> bw.isWritableProperty(propertyName) &amp;&amp;<br>                !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);<span class="hljs-comment">// 属性值是否可以转换</span><br>            <span class="hljs-keyword">if</span> (convertible) &#123;<br>                <span class="hljs-comment">// 使用用户自定义的类型转换器转换属性值</span><br>                convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);<br>            &#125;<br>            <span class="hljs-comment">// Possibly store converted value in merged bean definition,</span><br>            <span class="hljs-comment">// in order to avoid re-conversion for every created bean instance.</span><br>            <span class="hljs-comment">// 存储转换后的属性值，避免每次属性注入时的转换工作</span><br>            <span class="hljs-keyword">if</span> (resolvedValue == originalValue) &#123;<br>                <span class="hljs-keyword">if</span> (convertible) &#123;<br>                    <span class="hljs-comment">// 设置属性转换之后的值</span><br>                    pv.setConvertedValue(convertedValue);<br>                &#125;<br>                deepCopy.add(pv);<br>            &#125;<br>            <span class="hljs-comment">// 属性是可转换的，且属性原始值是字符串类型，且属性的原始类型值不是</span><br>            <span class="hljs-comment">// 动态生成的字符串，且属性的原始值不是集合或者数组类型</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (convertible &amp;&amp; originalValue <span class="hljs-keyword">instanceof</span> TypedStringValue &amp;&amp;<br>                     !((TypedStringValue) originalValue).isDynamic() &amp;&amp;<br>                     !(convertedValue <span class="hljs-keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;<br>                pv.setConvertedValue(convertedValue);<br>                deepCopy.add(pv);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                resolveNecessary = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// 重新封装属性的值</span><br>                deepCopy.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyValue</span>(pv, convertedValue));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 标记属性值已经转换过</span><br>    <span class="hljs-keyword">if</span> (mpvs != <span class="hljs-literal">null</span> &amp;&amp; !resolveNecessary) &#123;<br>        mpvs.setConverted();<br>    &#125;<br><br>    <span class="hljs-comment">// Set our (possibly massaged) deep copy.</span><br>    <span class="hljs-comment">// 进行属性依赖注入，依赖注入的真真正正实现依赖的注入方法在此！！！</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        bw.setPropertyValues(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MutablePropertyValues</span>(deepCopy));<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>            mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Error setting property values&quot;</span>, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上完成了属性转换：</p><ul><li>属性值类型<strong>不需要</strong>转换时，不需要解析属性值，直接准备进行依赖注入。</li><li>属性值<strong>需要</strong>进行类型转换时，如对其他对象的引用等，首先需要解析属性值，然后对解析后的属性值进行依赖注入。</li></ul><p>其中调用了 <code>resolveValueIfNecessary(...)</code>方法对属性值的解析。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二十四、创建Bean之循环依赖</title>
    <link href="/2022/06/11/%E5%88%9B%E5%BB%BABean%E4%B9%8B%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <url>/2022/06/11/%E5%88%9B%E5%BB%BABean%E4%B9%8B%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">创建Bean之循环依赖</font></div><p><code>doCreateBean()</code>的第三步：<strong>循环依赖处理</strong>，其他步骤已经在前边介绍了。</p><p>循环依赖并不仅仅只是在 <code>doCreateBean(...)</code> 方法中处理，而是在整个加载 bean 的过程中都有涉及。所以，本文内容并不仅仅只局限于 <code>doCreateBean(...)</code> 方法，而是从整个 Bean 的加载过程进行分析。</p><h4 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h4><p>循环依赖，其实就是循环引用，就是两个或者两个以上的 bean 互相引用对方，最终形成一个闭环，如 A 依赖 B，B 依赖 C，C 依赖 A。</p><p>其实就是一个<strong>死循环</strong>的过程，在初始化 A 的时候发现引用了 B，这时就会去初始化 B，然后又发现 B 引用 C，跑去初始化 C，初始化 C 的时候发现引用了 A，则又会去初始化 A，依次循环永不退出，除非有<strong>终结条件</strong>。</p><p>循环依赖的情况有两种：</p><ul><li>构造器的循环依赖。</li><li>field属性的循环依赖。</li></ul><p><strong>注</strong>：对于构造器的循环依赖，Spring 是无法解决的，只能抛出 <code>BeanCurrentlyInCreationException</code> 异常表示循环依赖。</p><p>在《开启Bean的加载》中已说到：Spring 只解决 scope 为 singleton 的循环依赖。对于scope 为 prototype 的 bean ，Spring 无法解决，直接抛出 BeanCurrentlyInCreationException 异常。所以本文说的解决循环依赖就是解决scope为singleton的循环依赖。</p><h4 id="解决循环依赖"><a href="#解决循环依赖" class="headerlink" title="解决循环依赖"></a>解决循环依赖</h4><h5 id="getSingleton-方法"><a href="#getSingleton-方法" class="headerlink" title="getSingleton()方法"></a><code>getSingleton()</code>方法</h5><p>从加载bean的最初始方法开始：<code>AbstractBeanFactory.getBean()</code>—&gt;<code>AbstractBeanFactory.doGetBean()</code>.</p><p>在 <code>doGetBean(...)</code> 方法中，首先会根据 <code>beanName</code> 从单例 <code>bean 缓存</code>中获取，<strong>如果不为空则直接返回</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><br><span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br></code></pre></td></tr></table></figure><p>调用 <code>getSingleton(String beanName, boolean allowEarlyReference)</code> 方法，从单例缓存中获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultSingletonBeanRegistry.java</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-type">boolean</span> allowEarlyReference)</span> &#123;<br>    <span class="hljs-comment">// 从单例缓冲中加载 bean，//先从一级缓存拿</span><br>    <span class="hljs-comment">//singletonObjects 就是Spring内部用来存放单例Bean的对象池,key为beanName，value为Bean</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>    <span class="hljs-comment">// 缓存中的 bean 为空，且当前 bean 正在创建，属性还没有DI（依赖注入）</span><br>    <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<br>        <span class="hljs-comment">//从二级缓存中拿</span><br>        <span class="hljs-comment">// earlySingletonObjects 是早期单例Bean的缓存池,此时Bean已经被创建(newInstance),但是还没有完成初始化</span><br>        singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);<br>        <span class="hljs-comment">//如果还拿不到，并且允许bean提前引用（解决循环依赖）</span><br>        <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; allowEarlyReference) &#123;<br>            <span class="hljs-comment">// 加锁</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>                <span class="hljs-comment">// Consistent creation of early reference within full singleton lock</span><br>                singletonObject = <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>                <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;<br>                    singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);<br>                    <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">//从三级缓存中拿到对象工厂</span><br>                        <span class="hljs-comment">//singletonFactories 单例工厂的缓存,key为beanName,value 为ObjectFactory</span><br>                        ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-built_in">this</span>.singletonFactories.get(beanName);<br>                        <span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-literal">null</span>) &#123;<br>                            <span class="hljs-comment">//从工厂中拿到对象</span><br>                            singletonObject = singletonFactory.getObject();<br>                            <span class="hljs-comment">//升级到二级缓存</span><br>                            <span class="hljs-built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br>                            <span class="hljs-comment">// 从 singletonFactories 中移除对应的 ObjectFactory</span><br>                            <span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singletonObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法主要是从三个缓存中获取，分别是：<code>singletonObjects</code>、<code>earlySingletonObjects</code>、<code>singletonFactories</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultSingletonBeanRegistry.java</span><br>        <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一级缓存，存放的是单例 bean 的映射。</span><br><span class="hljs-comment"> * 注意，这里的 bean 是已经创建完成的。</span><br><span class="hljs-comment"> * 对应关系为 bean name --&gt; bean instance</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);<br>    <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 二级缓存，存放的是未初始化完的 bean，对应关系也是 bean name --&gt; bean instance。</span><br><span class="hljs-comment"> * 它与 &#123;<span class="hljs-doctag">@link</span> #singletonObjects&#125; 区别在于， 它自己存放的 bean 不一定是完整。</span><br><span class="hljs-comment"> * 这个 Map 也是【循环依赖】的关键所在。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br>    <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三级缓存，存放的是 ObjectFactory，可以理解为创建未初始化完的 bean 的 factory ，最终添加到二级缓存 &#123;<span class="hljs-doctag">@link</span> earlySingletonObjects&#125; 中</span><br><span class="hljs-comment"> * 对应关系是 bean name --&gt; ObjectFactory</span><br><span class="hljs-comment"> * 这个 Map 也是【循环依赖】的关键所在。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p>以上三个缓存变量是解决<code>singleton bean</code>的关键，成为<strong>三级缓存</strong>：</p><p>一级缓存为<code>singletonObjects</code>，二级缓存为<code>earlySingletonObjects</code>，三级缓存为<code>singletonFactories</code>。</p><p>在<code>getSingleton()</code>方法中其中涉及了一个<code>isSingletonCurrentlyInCreation(String beanName)</code>方法和<code>allowEarlyReference</code>变量：</p><ul><li><p><code>isSingletonCurrentlyInCreation(String beanName)</code>方法：判断当前 singleton bean 是否处于创建中。bean 处于创建中，也就是说 bean 在初始化但是没有完成初始化，有一个这样的过程其实和 Spring 解决 bean 循环依赖的理念相辅相成。<strong>因为 Spring 解决 singleton bean 的核心就在于提前曝光 bean</strong> 。</p></li><li><p><code>allowEarlyReference</code> 变量：从字面意思上面理解就是允许提前拿到引用。其实真正的意思是，是否允许从 <code>singletonFactories</code> 缓存中通过 <code>getObject()</code> 方法，拿到对象。为什么会有这样一个字段呢？<strong>原因就在于 <code>singletonFactories</code> 才是 Spring 解决 singleton bean 的诀窍所在</strong>。</p></li></ul><p><code>getSingleton(String beanName, boolean allowEarlyReference)</code>方法，过程如下：</p><ul><li><p>首先，从一级缓存 <code>singletonObjects</code> 获取。</p></li><li><p>如果没有，且当前指定的 <code>beanName</code> 正在创建，就再从二级缓存 <code>earlySingletonObjects</code> 中获取。</p></li><li><p>如果还是没有获取到，并且允许 <code>singletonFactories</code> 通过 <code>getObject()</code> 获取，则从三级缓存 <code>singletonFactories</code> 获取。如果获取到，则通过其 <code>getObject()</code> 方法，获取对象，并将其加入到二级缓存 <code>earlySingletonObjects</code> 中，并从三级缓存 <code>singletonFactories</code> 删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultSingletonBeanRegistry.java</span><br><br>singletonObject = singletonFactory.getObject();<br><span class="hljs-built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br><span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br></code></pre></td></tr></table></figure><p>这样，就从三级缓存<strong>升级</strong>到二级缓存了。</p><p>所以，二级缓存存在的<strong>意义</strong>：就是缓存三级缓存中的 ObjectFactory 的 <code>getObject()</code> 方法的执行结果，提早曝光的<strong>单例</strong> Bean 对象。</p></li></ul><h5 id="addSingletonFactory-方法"><a href="#addSingletonFactory-方法" class="headerlink" title="addSingletonFactory()方法"></a><code>addSingletonFactory()</code>方法</h5><p>上面是从缓存中获取，但是缓存中的数据从哪里添加进来的呢？一直往下跟会发现在 AbstractAutowireCapableBeanFactory 的 <code>doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">earlySingletonExposure</span> <span class="hljs-operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-comment">// 单例模式</span><br>        <span class="hljs-built_in">this</span>.allowCircularReferences &amp;&amp; <span class="hljs-comment">// 运行循环依赖</span><br>        isSingletonCurrentlyInCreation(beanName));<span class="hljs-comment">// 当前单例 bean 是否正在被创建</span><br><span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>        logger.trace(<span class="hljs-string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +<br>                     <span class="hljs-string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 提前将创建的 bean 实例加入到 singletonFactories 中</span><br>    <span class="hljs-comment">// 这里是为了后期避免循环依赖</span><br>    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br>&#125;<br></code></pre></td></tr></table></figure><p>当一个Bean满足<code>单例的</code>、<code>运行提前暴露bean</code>、<code>当前bean正在创建</code>三个条件，就将它添加到缓存中。</p><p><code>addSingletonFactory()</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultSingletonBeanRegistry.java</span><br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSingletonFactory</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;<br>Assert.notNull(singletonFactory, <span class="hljs-string">&quot;Singleton factory must not be null&quot;</span>);<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;<br><span class="hljs-built_in">this</span>.singletonFactories.put(beanName, singletonFactory);<br><span class="hljs-built_in">this</span>.earlySingletonObjects.remove(beanName);<br><span class="hljs-built_in">this</span>.registeredSingletons.add(beanName);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>从这段代码我们可以看出，<code>singletonFactories</code> 这个三级缓存才是解决 Spring Bean 循环依赖的诀窍所在。同时这段代码发生在 <code>createBeanInstance(...)</code> 方法之后，也就是说这个 bean 其实已经被创建出来了，<strong>但是它还不是很完美（没有进行属性填充和初始化），而这对于其他依赖它的对象而言已经足够了（可以根据对象引用定位到堆中对象），能够被认出来了</strong>。所以 Spring 在这个时候，选择将该对象提前曝光出来让大家认识认识。</li></ul><p>另外，<code>addSingletonFactory()</code>中的回调函数<code>getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean)</code> 方法也<strong>非常重要</strong>，这里会创建早期初始化 Bean 可能存在的 AOP 代理等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对创建的早期半成品（未初始化）的 Bean 处理引用</span><br><span class="hljs-comment"> * 例如说，AOP 就是在这里动态织入，创建其代理 Bean 返回</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getEarlyBeanReference</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br><span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br><span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<br><span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;<br><span class="hljs-type">SmartInstantiationAwareBeanPostProcessor</span> <span class="hljs-variable">ibp</span> <span class="hljs-operator">=</span> (SmartInstantiationAwareBeanPostProcessor) bp;<br>exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这也是为什么 Spring 需要额外增加 <code>singletonFactories</code> 三级缓存的原因，解决 Spring 循环依赖情况下的 Bean 存在动态代理等情况，不然循环注入到别人的 Bean 就是原始的，而不是经过动态代理的！</li></ul><h5 id="addSingleton-方法"><a href="#addSingleton-方法" class="headerlink" title="addSingleton()方法"></a><code>addSingleton()</code>方法</h5><p>二级缓存<code>earlySingletonObjects</code>、三级缓存<code>singletonFactory</code>如上设置，一级缓存如何设置呢？</p><p>在类 DefaultSingletonBeanRegistry 中，可以发现这个 <code>addSingleton(String beanName, Object singletonObject)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultSingletonBeanRegistry.java</span><br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSingleton</span><span class="hljs-params">(String beanName, Object singletonObject)</span> &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br><span class="hljs-built_in">this</span>.singletonObjects.put(beanName, singletonObject);<br><span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br><span class="hljs-built_in">this</span>.earlySingletonObjects.remove(beanName);<br><span class="hljs-built_in">this</span>.registeredSingletons.add(beanName);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>添加至一级缓存，同时从二级、三级缓存中删除。</p><p>该方法何时被引用的？之前介绍《各scope的Bean创建》中，<code>doGetBean()</code>方法中处理不同scope时，如果是singleton，则调用<code>getSingleton()</code>，和上边<code>getSingleton()</code>不同。</p><p><img src="/images/spring_IOC/getSingleton.jpeg" alt="getSingleton"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;<br>    Assert.notNull(beanName, <span class="hljs-string">&quot;Bean name must not be null&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>        <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//....</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                singletonObject = singletonFactory.getObject();<br>                newSingleton = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">//.....</span><br>            <span class="hljs-keyword">if</span> (newSingleton) &#123;<br>                addSingleton(beanName, singletonObject);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singletonObject;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最上边循环依赖Spring解决过程如下：</p><ul><li>首先 A 完成初始化第一步并将自己提前曝光出来（通过 ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象 B，此时就会去尝试 get(B)，这个时候发现 B 还没有被创建出来。</li><li>然后 B 就走创建流程，在 B 初始化的时候，同样发现自己依赖 C，C 也没有被创建出来。</li><li>这个时候 C 又开始初始化进程，但是在初始化的过程中发现自己依赖 A，于是尝试 get(A)，这个时候由于 A 已经添加至缓存中（一般都是添加至三级缓存 <code>singletonFactories</code> ），通过 ObjectFactory 提前曝光，所以可以通过 <code>ObjectFactory.getObject()</code> 方法来拿到 A 对象，C 拿到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中。</li><li>回到 B ，B 也可以拿到 C 对象，完成初始化，A 可以顺利拿到 B 完成初始化。到这里整个链路就已经完成了初始化过程了。</li></ul><p><img src="/images/spring_IOC/%E5%A4%84%E7%90%86%E5%BE%AA%E5%9D%8F%E4%BE%9D%E8%B5%96.png" alt="处理循坏依赖"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二十一、创建Bean之实例化Bean对象一</title>
    <link href="/2022/06/11/%E5%88%9B%E5%BB%BABean%E4%B9%8B%E5%AE%9E%E4%BE%8B%E5%8C%96Bean%E5%AF%B9%E8%B1%A11/"/>
    <url>/2022/06/11/%E5%88%9B%E5%BB%BABean%E4%B9%8B%E5%AE%9E%E4%BE%8B%E5%8C%96Bean%E5%AF%B9%E8%B1%A11/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">创建Bean之实例化Bean对象一</font></div><h4 id="createBeanInstance-方法"><a href="#createBeanInstance-方法" class="headerlink" title="createBeanInstance()方法"></a><code>createBeanInstance()</code>方法</h4><p>创建Bean实例过程的第一步：实例化Bean，方法为<code>createBeanInstance()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title function_">createBeanInstance</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span> &#123;<br>    <span class="hljs-comment">// 解析 bean ，将 bean 类名解析为 class 引用。</span><br>    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);<br><br>    <span class="hljs-keyword">if</span> (beanClass != <span class="hljs-literal">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                                        <span class="hljs-string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;1&gt; 如果存在 Supplier 回调，则使用给定的回调方法初始化策略</span><br>    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();<br>    <span class="hljs-keyword">if</span> (instanceSupplier != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;2&gt; 使用 FactoryBean 的 factory-method 来创建，支持静态工厂和实例工厂</span><br>    <span class="hljs-keyword">if</span> (mbd.getFactoryMethodName() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">resolved</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">autowireNecessary</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (args == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// constructorArgumentLock 构造函数的常用锁</span><br>        <span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;<br>            <span class="hljs-comment">// 如果已缓存的解析的构造函数或者工厂方法不为空，则可以利用构造函数解析</span><br>            <span class="hljs-comment">// 因为需要根据参数确认到底使用哪个构造函数，该过程比较消耗性能，所有采用缓存机制</span><br>            <span class="hljs-keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="hljs-literal">null</span>) &#123;<br>                resolved = <span class="hljs-literal">true</span>;<br>                autowireNecessary = mbd.constructorArgumentsResolved;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 已经解析好了，直接注入即可</span><br>    <span class="hljs-keyword">if</span> (resolved) &#123;<br>        <span class="hljs-keyword">if</span> (autowireNecessary) &#123;<br>            <span class="hljs-comment">// &lt;3.1&gt; autowire 自动注入，调用构造函数自动注入</span><br>            <span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// &lt;3.2&gt; 使用默认构造函数构造</span><br>            <span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;4&gt; 确定解析的构造函数</span><br>    <span class="hljs-comment">// 主要是检查已经注册的 SmartInstantiationAwareBeanPostProcessor</span><br>    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);<br>    <span class="hljs-comment">// &lt;4.1&gt; 有参数情况时，创建 Bean 。先利用参数个数，类型等，确定最精确匹配的构造方法。</span><br>    <span class="hljs-keyword">if</span> (ctors != <span class="hljs-literal">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||<br>        mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;<br>        <span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;4.1&gt; 选择构造方法，创建 Bean 。</span><br>    ctors = mbd.getPreferredConstructors();<br>    <span class="hljs-keyword">if</span> (ctors != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;4.2&gt; 有参数时，又没获取到构造方法，则只能调用无参构造方法来创建实例了(兜底方法)</span><br>    <span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);<br>&#125;<br></code></pre></td></tr></table></figure><p>实例化 Bean 对象，主要的逻辑为：</p><ul><li><p><code>&lt;1&gt;</code> 处，如果存在 Supplier 回调，则调用 <code>obtainFromSupplier(Supplier instanceSupplier, String beanName)</code> 方法，进行初始化。</p></li><li><p><code>&lt;2&gt;</code> 处，如果存在工厂方法，则使用工厂方法进行初始化。</p></li><li><p><code>&lt;3&gt;</code> 处，首先判断缓存，如果<strong>缓存中存在</strong>，即已经解析过了，则直接使用已经解析了的。根据 <code>constructorArgumentsResolved</code> 参数来判断：</p><p><code>&lt;3.1&gt;</code> 处，是使用构造函数自动注入，即调用 <code>autowireConstructor(String beanName, RootBeanDefinition mbd, Constructor[] ctors, Object[] explicitArgs)</code> 方法。</p><p><code>&lt;3.2&gt;</code> 处，还是默认构造函数，即调用 <code>instantiateBean(final String beanName, final RootBeanDefinition mbd)</code> 方法。</p></li><li><p><code>&lt;4&gt;</code> 处，如果<strong>缓存中没有</strong>，则需要先确定到底使用哪个构造函数来完成解析工作，因为一个类有多个构造函数，每个构造函数都有不同的构造参数，所以需要根据参数来锁定构造函数并完成初始化。</p><p><code>&lt;4.1&gt;</code> 处，如果存在参数，则使用相应的带有参数的构造函数，即调用 <code>autowireConstructor(String beanName, RootBeanDefinition mbd, Constructor[] ctors, Object[] explicitArgs)</code> 方法。</p><p><code>&lt;4.2&gt;</code> 处，否则，使用默认构造函数，即调用 <code>instantiateBean(final String beanName, final RootBeanDefinition mbd)</code> 方法。</p></li></ul><h5 id="obtainFromSupplier-方法"><a href="#obtainFromSupplier-方法" class="headerlink" title="obtainFromSupplier()方法"></a><code>obtainFromSupplier()</code>方法</h5><p>如果存在 Supplier 回调，则使用给定的回调方法初始化策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br>Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();<br><span class="hljs-keyword">if</span> (instanceSupplier != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先,从 BeanDefinition 中获取 Supplier 对象。如果不为空，则调用 <code>obtainFromSupplier(final String beanName, final RootBeanDefinition mbd)</code> 方法。</p><h6 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a><code>Supplier</code></h6><p><code>Supplier</code>：java1.8的一个函数式接口，提供者。用于指定创建 bean 的回调。如果我们设置了这样的回调，那么其他的构造器或者工厂方法都会没有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Supplier</span>&lt;T&gt; &#123;<br>    T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如何设置<code>Supplier</code>参数，有对应的<code>setter</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanDefinition.java</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建 Bean 的 Supplier 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> Supplier&lt;?&gt; instanceSupplier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInstanceSupplier</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Supplier&lt;?&gt; instanceSupplier)</span> &#123;<br><span class="hljs-built_in">this</span>.instanceSupplier = instanceSupplier;<br>&#125;<br></code></pre></td></tr></table></figure><p>在构造 BeanDefinition 对象的时候，设置了 <code>instanceSupplier</code> 该值，（以 RootBeanDefinition 为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// RootBeanDefinition.java</span><br><span class="hljs-keyword">public</span> &lt;T&gt; RootBeanDefinition(<span class="hljs-meta">@Nullable</span> Class&lt;T&gt; beanClass, String scope, <span class="hljs-meta">@Nullable</span> Supplier&lt;T&gt; instanceSupplier) &#123;<br><span class="hljs-built_in">super</span>();<br>setBeanClass(beanClass);<br>setScope(scope);<br><span class="hljs-comment">// 设置 instanceSupplier 属性</span><br>setInstanceSupplier(instanceSupplier);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="obtainFromSupplier-方法-1"><a href="#obtainFromSupplier-方法-1" class="headerlink" title="obtainFromSupplier()方法"></a><code>obtainFromSupplier()</code>方法</h6><p>如果设置了 <code>instanceSupplier</code> 属性，则可以调用 <code>obtainFromSupplier(Supplier instanceSupplier, String beanName)</code> 方法，完成 Bean 的初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title function_">obtainFromSupplier</span><span class="hljs-params">(Supplier&lt;?&gt; instanceSupplier, String beanName)</span> &#123;<br>    Object instance;<br><br>    <span class="hljs-comment">// 获得原创建的 Bean 的对象名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">outerBean</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.currentlyCreatedBean.get();<br>    <span class="hljs-comment">// 设置新的 Bean 的对象名，到 currentlyCreatedBean 中</span><br>    <span class="hljs-built_in">this</span>.currentlyCreatedBean.set(beanName);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// &lt;1&gt; 调用 Supplier 的 get()，返回一个 Bean 对象</span><br>        instance = instanceSupplier.get();<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 设置原创建的 Bean 的对象名，到 currentlyCreatedBean 中</span><br>        <span class="hljs-keyword">if</span> (outerBean != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.currentlyCreatedBean.set(outerBean);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.currentlyCreatedBean.remove();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 未创建 Bean 对象，则创建 NullBean 对象</span><br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullBean</span>();<br>    &#125;<br>    <span class="hljs-comment">// &lt;2&gt; 创建 BeanWrapper 对象</span><br>    <span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanWrapperImpl</span>(instance);<br>    <span class="hljs-comment">// &lt;3&gt; 初始化 BeanWrapper 对象</span><br>    initBeanWrapper(bw);<br>    <span class="hljs-keyword">return</span> bw;<br>&#125;<br></code></pre></td></tr></table></figure><p>流程如下：</p><ul><li><code>&lt;1&gt;</code> 首先，调用 Supplier 的 <code>get()</code> 方法，获得一个 Bean 实例对象。</li><li><code>&lt;2&gt;</code> 然后，根据该实例对象构造一个 BeanWrapper 对象 <code>bw</code> 。</li><li><code>&lt;3&gt;</code> 最后，初始化该对象。</li></ul><h5 id="instantiateUsingFactoryMethod-方法"><a href="#instantiateUsingFactoryMethod-方法" class="headerlink" title="instantiateUsingFactoryMethod()方法"></a><code>instantiateUsingFactoryMethod()</code>方法</h5><p>如果存在工厂方法，使用 FactoryBean 的 factory-method 来创建，支持静态工厂和实例工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><span class="hljs-comment">// &lt;2&gt; 使用 FactoryBean 的 factory-method 来创建，支持静态工厂和实例工厂</span><br><span class="hljs-keyword">if</span> (mbd.getFactoryMethodName() != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *构造一个 ConstructorResolver 对象，然后调用其 instantiateUsingFactoryMethod(EvaluationContext context, String typeName, List&lt;TypeDescriptor&gt; argumentTypes) 方法。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title function_">instantiateUsingFactoryMethod</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] explicitArgs)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstructorResolver</span>(<span class="hljs-built_in">this</span>).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="ConstructorResolver"><a href="#ConstructorResolver" class="headerlink" title="ConstructorResolver"></a><code>ConstructorResolver</code></h6><p><code>org.springframework.expression.ConstructorResolver</code> 是构造方法或者工厂类初始化 bean 的委托类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConstructorResolver.java</span><br><br><span class="hljs-keyword">public</span> BeanWrapper <span class="hljs-title function_">instantiateUsingFactoryMethod</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] explicitArgs)</span> &#123;<br>    <span class="hljs-comment">// 构造 BeanWrapperImpl 对象</span><br>    <span class="hljs-type">BeanWrapperImpl</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanWrapperImpl</span>();<br>    <span class="hljs-comment">// 初始化 BeanWrapperImpl</span><br>    <span class="hljs-comment">// 向BeanWrapper对象中添加 ConversionService 对象和属性编辑器 PropertyEditor 对象</span><br>    <span class="hljs-built_in">this</span>.beanFactory.initBeanWrapper(bw);<br><br>    <span class="hljs-comment">// &lt;1&gt; 获得 factoryBean、factoryClass、isStatic、factoryBeanName 属性</span><br>    Object factoryBean;<br>    Class&lt;?&gt; factoryClass;<br>    <span class="hljs-type">boolean</span> isStatic;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">factoryBeanName</span> <span class="hljs-operator">=</span> mbd.getFactoryBeanName();<br>    <span class="hljs-comment">// 工厂名不为空</span><br>    <span class="hljs-keyword">if</span> (factoryBeanName != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (factoryBeanName.equals(beanName)) &#123;<span class="hljs-comment">// 抛出 BeanDefinitionStoreException 异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(mbd.getResourceDescription(), beanName,<br>                                                   <span class="hljs-string">&quot;factory-bean reference points back to the same bean definition&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 获取工厂实例</span><br>        factoryBean = <span class="hljs-built_in">this</span>.beanFactory.getBean(factoryBeanName);<br>        <span class="hljs-keyword">if</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-built_in">this</span>.beanFactory.containsSingleton(beanName)) &#123;<span class="hljs-comment">// 抛出 ImplicitlyAppearedSingletonException 异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImplicitlyAppearedSingletonException</span>();<br>        &#125;<br>        <span class="hljs-built_in">this</span>.beanFactory.registerDependentBean(factoryBeanName, beanName);<br>        factoryClass = factoryBean.getClass();<br>        isStatic = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 工厂名为空，则其可能是一个静态工厂</span><br>        <span class="hljs-comment">// 静态工厂创建bean，必须要提供工厂的全类名</span><br>        <span class="hljs-keyword">if</span> (!mbd.hasBeanClass()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(mbd.getResourceDescription(), beanName,<br>                                                   <span class="hljs-string">&quot;bean definition declares neither a bean class nor a factory-bean reference&quot;</span>);<br>        &#125;<br>        factoryBean = <span class="hljs-literal">null</span>;<br>        factoryClass = mbd.getBeanClass();<br>        isStatic = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;2&gt; 获得 factoryMethodToUse、argsHolderToUse、argsToUse 属性</span><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">factoryMethodToUse</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">// 工厂方法</span><br>    <span class="hljs-type">ArgumentsHolder</span> <span class="hljs-variable">argsHolderToUse</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    Object[] argsToUse = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 参数</span><br><br>    <span class="hljs-comment">// &lt;2.1&gt; 如果指定了构造参数则直接使用</span><br>    <span class="hljs-comment">// 在调用 getBean 方法的时候指定了方法参数</span><br>    <span class="hljs-keyword">if</span> (explicitArgs != <span class="hljs-literal">null</span>) &#123;<br>        argsToUse = explicitArgs;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 没有指定，则尝试从配置文件中解析</span><br>        Object[] argsToResolve = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// &lt;2.2&gt; 首先尝试从缓存中获取</span><br>        <span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;<br>            <span class="hljs-comment">// 获取缓存中的构造函数或者工厂方法</span><br>            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;<br>            <span class="hljs-keyword">if</span> (factoryMethodToUse != <span class="hljs-literal">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;<br>                <span class="hljs-comment">// Found a cached factory method...</span><br>                <span class="hljs-comment">// 获取缓存中的构造参数</span><br>                argsToUse = mbd.resolvedConstructorArguments;<br>                <span class="hljs-keyword">if</span> (argsToUse == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 获取缓存中的构造函数参数的包可见字段</span><br>                    argsToResolve = mbd.preparedConstructorArguments;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 缓存中存在,则解析存储在 BeanDefinition 中的参数</span><br>        <span class="hljs-comment">// 如给定方法的构造函数 A(int ,int )，则通过此方法后就会把配置文件中的(&quot;1&quot;,&quot;1&quot;)转换为 (1,1)</span><br>        <span class="hljs-comment">// 缓存中的值可能是原始值也有可能是最终值</span><br>        <span class="hljs-keyword">if</span> (argsToResolve != <span class="hljs-literal">null</span>) &#123;<br>            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;3&gt;</span><br>    <span class="hljs-keyword">if</span> (factoryMethodToUse == <span class="hljs-literal">null</span> || argsToUse == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 获取工厂方法的类全名称</span><br>        factoryClass = ClassUtils.getUserClass(factoryClass);<br><br>        List&lt;Method&gt; candidates = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (mbd.isFactoryMethodUnique) &#123;<br>            <span class="hljs-keyword">if</span> (factoryMethodToUse == <span class="hljs-literal">null</span>) &#123;<br>                factoryMethodToUse = mbd.getResolvedFactoryMethod();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (factoryMethodToUse != <span class="hljs-literal">null</span>) &#123;<br>                candidates = Collections.singletonList(factoryMethodToUse);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (candidates == <span class="hljs-literal">null</span>) &#123;<br>            candidates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-comment">// 获取所有待定方法</span><br>            Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);<br>            <span class="hljs-keyword">for</span> (Method candidate : rawCandidates) &#123;<br>                <span class="hljs-comment">// 检索所有方法，这里是对方法进行过滤</span><br>                <span class="hljs-keyword">if</span> (Modifier.isStatic(candidate.getModifiers()) == isStatic &amp;&amp; mbd.isFactoryMethod(candidate)) &#123;<br>                    candidates.add(candidate);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建 Bean</span><br>        <span class="hljs-keyword">if</span> (candidates.size() == <span class="hljs-number">1</span> &amp;&amp; explicitArgs == <span class="hljs-literal">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">uniqueCandidate</span> <span class="hljs-operator">=</span> candidates.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="hljs-number">0</span>) &#123;<br>                mbd.factoryMethodToIntrospect = uniqueCandidate;<br>                <span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;<br>                    mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;<br>                    mbd.constructorArgumentsResolved = <span class="hljs-literal">true</span>;<br>                    mbd.resolvedConstructorArguments = EMPTY_ARGS;<br>                &#125;<br>                bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, uniqueCandidate, EMPTY_ARGS));<br>                <span class="hljs-keyword">return</span> bw;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 排序构造函数</span><br>        <span class="hljs-comment">// public 构造函数优先参数数量降序，非 public 构造函数参数数量降序</span><br>        <span class="hljs-keyword">if</span> (candidates.size() &gt; <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// explicitly skip immutable singletonList</span><br>            candidates.sort(AutowireUtils.EXECUTABLE_COMPARATOR);<br>        &#125;<br><br>        <span class="hljs-comment">// 用于承载解析后的构造函数参数的值</span><br>        <span class="hljs-type">ConstructorArgumentValues</span> <span class="hljs-variable">resolvedValues</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autowiring</span> <span class="hljs-operator">=</span> (mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minTypeDiffWeight</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        Set&lt;Method&gt; ambiguousFactoryMethods = <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">int</span> minNrOfArgs;<br>        <span class="hljs-keyword">if</span> (explicitArgs != <span class="hljs-literal">null</span>) &#123;<br>            minNrOfArgs = explicitArgs.length;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// &lt;2.3&gt; getBean() 没有传递参数，则需要解析保存在 BeanDefinition 构造函数中指定的参数</span><br>            <span class="hljs-keyword">if</span> (mbd.hasConstructorArgumentValues()) &#123;<br>                <span class="hljs-comment">// 构造函数的参数</span><br>                <span class="hljs-type">ConstructorArgumentValues</span> <span class="hljs-variable">cargs</span> <span class="hljs-operator">=</span> mbd.getConstructorArgumentValues();<br>                resolvedValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstructorArgumentValues</span>();<br>                <span class="hljs-comment">// 解析构造函数的参数</span><br>                <span class="hljs-comment">// 将该 bean 的构造函数参数解析为 resolvedValues 对象，其中会涉及到其他 bean</span><br>                minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                minNrOfArgs = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br><br>        Deque&lt;UnsatisfiedDependencyException&gt; causes = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 记录 UnsatisfiedDependencyException 异常的集合</span><br><br>        <span class="hljs-comment">// 遍历 candidates 数组</span><br>        <span class="hljs-keyword">for</span> (Method candidate : candidates) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">parameterCount</span> <span class="hljs-operator">=</span> candidate.getParameterCount();<br><br>            <span class="hljs-keyword">if</span> (parameterCount &gt;= minNrOfArgs) &#123;<br>                <span class="hljs-comment">// 保存参数的对象</span><br>                ArgumentsHolder argsHolder;<br><br>                <span class="hljs-comment">// 方法体的参数</span><br>                Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();<br>                <span class="hljs-comment">// #getBean(...) 传递了参数</span><br>                <span class="hljs-keyword">if</span> (explicitArgs != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 显示给定参数，参数长度必须完全匹配</span><br>                    <span class="hljs-keyword">if</span> (paramTypes.length != explicitArgs.length) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 根据参数创建参数持有者 ArgumentsHolder 对象</span><br>                    argsHolder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArgumentsHolder</span>(explicitArgs);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 为提供参数，解析构造参数</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        String[] paramNames = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-comment">// 获取 ParameterNameDiscoverer 对象</span><br>                        <span class="hljs-comment">// ParameterNameDiscoverer 是用于解析方法和构造函数的参数名称的接口，为参数名称探测器</span><br>                        <span class="hljs-type">ParameterNameDiscoverer</span> <span class="hljs-variable">pnd</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.beanFactory.getParameterNameDiscoverer();<br>                        <span class="hljs-comment">// 获取指定构造函数的参数名称</span><br>                        <span class="hljs-keyword">if</span> (pnd != <span class="hljs-literal">null</span>) &#123;<br>                            paramNames = pnd.getParameterNames(candidate);<br>                        &#125;<br>                        <span class="hljs-comment">// 在已经解析的构造函数参数值的情况下，创建一个参数持有者 ArgumentsHolder 对象</span><br>                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw,<br>                                                         paramTypes, paramNames, candidate, autowiring, candidates.size() == <span class="hljs-number">1</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;<br>                        <span class="hljs-comment">// 若发生 UnsatisfiedDependencyException 异常，添加到 causes 中。</span><br>                        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                            logger.trace(<span class="hljs-string">&quot;Ignoring factory method [&quot;</span> + candidate + <span class="hljs-string">&quot;] of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;: &quot;</span> + ex);<br>                        &#125;<br>                        <span class="hljs-comment">// Swallow and try next overloaded factory method.</span><br>                        <span class="hljs-keyword">if</span> (causes == <span class="hljs-literal">null</span>) &#123;<br>                            causes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(<span class="hljs-number">1</span>);<br>                        &#125;<br>                        causes.add(ex);<br>                        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// continue ，继续执行</span><br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// isLenientConstructorResolution 判断解析构造函数的时候是否以宽松模式还是严格模式</span><br>                <span class="hljs-comment">// 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常</span><br>                <span class="hljs-comment">// 宽松模式：使用具有&quot;最接近的模式&quot;进行匹配</span><br>                <span class="hljs-comment">// typeDiffWeight：类型差异权重</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">typeDiffWeight</span> <span class="hljs-operator">=</span> (mbd.isLenientConstructorResolution() ?<br>                                      argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));<br>                <span class="hljs-comment">// Choose this factory method if it represents the closest match.</span><br>                <span class="hljs-comment">// 代表最接近的类型匹配，则选择作为构造函数</span><br>                <span class="hljs-keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;<br>                    factoryMethodToUse = candidate;<br>                    argsHolderToUse = argsHolder;<br>                    argsToUse = argsHolder.arguments;<br>                    minTypeDiffWeight = typeDiffWeight;<br>                    ambiguousFactoryMethods = <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-comment">// 如果具有相同参数数量的方法具有相同的类型差异权重，则收集此类型选项</span><br>                <span class="hljs-comment">// 但是，仅在非宽松构造函数解析模式下执行该检查，并显式忽略重写方法（具有相同的参数签名）</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (factoryMethodToUse != <span class="hljs-literal">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight &amp;&amp;<br>                         !mbd.isLenientConstructorResolution() &amp;&amp;<br>                         paramTypes.length == factoryMethodToUse.getParameterCount() &amp;&amp;<br>                         !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) &#123;<br>                    <span class="hljs-comment">// 查找到多个可匹配的方法</span><br>                    <span class="hljs-keyword">if</span> (ambiguousFactoryMethods == <span class="hljs-literal">null</span>) &#123;<br>                        ambiguousFactoryMethods = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>                        ambiguousFactoryMethods.add(factoryMethodToUse);<br>                    &#125;<br>                    ambiguousFactoryMethods.add(candidate);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 没有可执行的工厂方法，抛出异常</span><br>        <span class="hljs-keyword">if</span> (factoryMethodToUse == <span class="hljs-literal">null</span> || argsToUse == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (causes != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">UnsatisfiedDependencyException</span> <span class="hljs-variable">ex</span> <span class="hljs-operator">=</span> causes.removeLast();<br>                <span class="hljs-keyword">for</span> (Exception cause : causes) &#123;<br>                    <span class="hljs-built_in">this</span>.beanFactory.onSuppressedException(cause);<br>                &#125;<br>                <span class="hljs-keyword">throw</span> ex;<br>            &#125;<br>            List&lt;String&gt; argTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(minNrOfArgs);<br>            <span class="hljs-keyword">if</span> (explicitArgs != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">for</span> (Object arg : explicitArgs) &#123;<br>                    argTypes.add(arg != <span class="hljs-literal">null</span> ? arg.getClass().getSimpleName() : <span class="hljs-string">&quot;null&quot;</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (resolvedValues != <span class="hljs-literal">null</span>) &#123;<br>                Set&lt;ValueHolder&gt; valueHolders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(resolvedValues.getArgumentCount());<br>                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());<br>                valueHolders.addAll(resolvedValues.getGenericArgumentValues());<br>                <span class="hljs-keyword">for</span> (ValueHolder value : valueHolders) &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">argType</span> <span class="hljs-operator">=</span> (value.getType() != <span class="hljs-literal">null</span> ? ClassUtils.getShortName(value.getType()) :<br>                                      (value.getValue() != <span class="hljs-literal">null</span> ? value.getValue().getClass().getSimpleName() : <span class="hljs-string">&quot;null&quot;</span>));<br>                    argTypes.add(argType);<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">argDesc</span> <span class="hljs-operator">=</span> StringUtils.collectionToCommaDelimitedString(argTypes);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                                            <span class="hljs-string">&quot;No matching factory method found: &quot;</span> +<br>                                            (mbd.getFactoryBeanName() != <span class="hljs-literal">null</span> ?<br>                                             <span class="hljs-string">&quot;factory bean &#x27;&quot;</span> + mbd.getFactoryBeanName() + <span class="hljs-string">&quot;&#x27;; &quot;</span> : <span class="hljs-string">&quot;&quot;</span>) +<br>                                            <span class="hljs-string">&quot;factory method &#x27;&quot;</span> + mbd.getFactoryMethodName() + <span class="hljs-string">&quot;(&quot;</span> + argDesc + <span class="hljs-string">&quot;)&#x27;. &quot;</span> +<br>                                            <span class="hljs-string">&quot;Check that a method with the specified name &quot;</span> +<br>                                            (minNrOfArgs &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;and arguments &quot;</span> : <span class="hljs-string">&quot;&quot;</span>) +<br>                                            <span class="hljs-string">&quot;exists and that it is &quot;</span> +<br>                                            (isStatic ? <span class="hljs-string">&quot;static&quot;</span> : <span class="hljs-string">&quot;non-static&quot;</span>) + <span class="hljs-string">&quot;.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">void</span>.class == factoryMethodToUse.getReturnType()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                                            <span class="hljs-string">&quot;Invalid factory method &#x27;&quot;</span> + mbd.getFactoryMethodName() +<br>                                            <span class="hljs-string">&quot;&#x27;: needs to have a non-void return type!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ambiguousFactoryMethods != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                                            <span class="hljs-string">&quot;Ambiguous factory method matches found in bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; &quot;</span> +<br>                                            <span class="hljs-string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot;</span> +<br>                                            ambiguousFactoryMethods);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (explicitArgs == <span class="hljs-literal">null</span> &amp;&amp; argsHolderToUse != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 将解析的构造函数加入缓存</span><br>            mbd.factoryMethodToIntrospect = factoryMethodToUse;<br>            argsHolderToUse.storeCache(mbd, factoryMethodToUse);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建 Bean 对象，并设置到 bw 中</span><br>    bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, factoryMethodToUse, argsToUse));<br>    <span class="hljs-keyword">return</span> bw;<br>&#125;<br><br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">instantiate</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd,</span><br><span class="hljs-params">   <span class="hljs-meta">@Nullable</span> Object factoryBean, Method factoryMethod, Object[] args)</span> &#123;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;<br>                                            <span class="hljs-built_in">this</span>.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, <span class="hljs-built_in">this</span>.beanFactory, factoryBean, factoryMethod, args),                                      <span class="hljs-built_in">this</span>.beanFactory.getAccessControlContext());<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.beanFactory.getInstantiationStrategy().instantiate(<br>                mbd, beanName, <span class="hljs-built_in">this</span>.beanFactory, factoryBean, factoryMethod, args);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                                        <span class="hljs-string">&quot;Bean instantiation via factory method failed&quot;</span>, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上该方法：<strong>确定工厂对象，然后获取构造函数和构造参数，最后调用 InstantiationStrategy 对象的 <code>instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner, Constructor ctor, Object... args)</code> 方法，来创建 Bean 实例</strong>。</p><ul><li><p><strong>一、&lt;1&gt;确定工厂对象</strong></p><p>首先获取工厂方法名：</p><ul><li>若工厂方法名不为空，则调用 <code>AbstractAutowireCapableBeanFactory.getBean(String name)</code> 方法，获取工厂对象，</li><li>若为空，则可能为一个静态工厂，对于静态工厂则必须提供工厂类的全类名，同时设置 <code>factoryBean = null</code> 。</li></ul></li><li><p><strong>二、&lt;2&gt;构造参数确认</strong></p><p>工厂对象确定后，则是确认构造参数。构造参数的确认主要分为<strong>三种</strong>情况：</p><ul><li><p><code>explicitArgs</code> 参数</p></li><li><p>缓存中获取</p></li><li><p>配置文件中解析</p><p>&lt;2.1&gt;explicitArgs 参数</p><p><code>explicitArgs</code> 参数，是我们调用 <code>getBean(...)</code> 方法时传递进来的。一般该参数，该参数就是用于初始化 Bean 时所传递的参数。如果该参数不为空，则可以确定构造函数的参数就是它了。</p><p>&lt;2.2&gt;缓存中获取</p><p>在该方法的最后，我们会发现这样一段 <code>argsHolderToUse.storeCache(mbd, factoryMethodToUse)</code> 代码。这段代码主要是将构造函数、构造参数保存到缓存中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConstructorResolver.ArgumentsHolder.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">storeCache</span><span class="hljs-params">(RootBeanDefinition mbd, Executable constructorOrFactoryMethod)</span> &#123;<br><span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;<br>mbd.resolvedConstructorOrFactoryMethod = constructorOrFactoryMethod;<br>mbd.constructorArgumentsResolved = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.resolveNecessary) &#123;<br>mbd.preparedConstructorArguments = <span class="hljs-built_in">this</span>.preparedArguments;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mbd.resolvedConstructorArguments = <span class="hljs-built_in">this</span>.arguments;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// RootBeanDefinition.java</span><br><span class="hljs-comment">// 构造函数的缓存锁</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">constructorArgumentLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-comment">// 缓存已经解析的构造函数或者工厂方法</span><br><span class="hljs-meta">@Nullable</span><br>Executable resolvedConstructorOrFactoryMethod;<br><br><span class="hljs-comment">// 标记字段，标记构造函数、参数已经解析了。默认为 `false`</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">constructorArgumentsResolved</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 缓存已经解析的构造函数参数，包可见字段。</span><br><span class="hljs-meta">@Nullable</span><br>Object[] resolvedConstructorArguments;<br></code></pre></td></tr></table></figure><p>从缓存中获取就是提取以上几个参数的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConstructorResolver.java</span><br><br><span class="hljs-comment">// 没有指定，则尝试从配置文件中解析</span><br>Object[] argsToResolve = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// &lt;2.2&gt; 首先尝试从缓存中获取</span><br><span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;<br>    <span class="hljs-comment">// 获取缓存中的构造函数或者工厂方法</span><br>    factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;<br>    <span class="hljs-keyword">if</span> (factoryMethodToUse != <span class="hljs-literal">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;<br>        <span class="hljs-comment">// Found a cached factory method...</span><br>        <span class="hljs-comment">// 获取缓存中的构造参数</span><br>        argsToUse = mbd.resolvedConstructorArguments;<br>        <span class="hljs-keyword">if</span> (argsToUse == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 获取缓存中的构造函数参数的包可见字段</span><br>            argsToResolve = mbd.preparedConstructorArguments;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 缓存中存在,则解析存储在 BeanDefinition 中的参数</span><br><span class="hljs-comment">// 如给定方法的构造函数 A(int ,int )，则通过此方法后就会把配置文件中的(&quot;1&quot;,&quot;1&quot;)转换为 (1,1)</span><br><span class="hljs-comment">// 缓存中的值可能是原始值也有可能是最终值</span><br><span class="hljs-keyword">if</span> (argsToResolve != <span class="hljs-literal">null</span>) &#123;<br>    argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果缓存中存在构造参数，则需要调用<code>resolvePreparedArguments(String beanName, RootBeanDefinition mbd, BeanWrapper bw, Executable executable, Object[] argsToResolve, boolean fallback)</code>方法，进行转换。</li><li>因为缓存中的值有可能是最终值，<strong>也有可能不是最终值</strong>。比如我们构造函数中的类型为 Integer 类型的 1 ，但是原始的参数类型有可能是 String 类型的 <code>&quot;1&quot;</code> ，所以即便是从缓存中得到了构造参数，也<strong>需要经过一番的类型转换确保参数类型完全对应</strong>。</li></ul><p>&lt;2.3&gt;配置文件中解析</p><p>即没有通过传递参数的方式传递构造参数，缓存中也没有，那就只能通过解析配置文件获取构造参数了。在 bean 解析类的博文中我们了解了，配置文件中的信息都会转换到 BeanDefinition 实例对象中，所以配置文件中的参数可以直接通过 BeanDefinition 对象获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><br><span class="hljs-comment">// &lt;2.3&gt; getBean() 没有传递参数，则需要解析保存在 BeanDefinition 构造函数中指定的参数</span><br><span class="hljs-keyword">if</span> (mbd.hasConstructorArgumentValues()) &#123;<br>    <span class="hljs-comment">// &lt;2.3.1&gt; 构造函数的参数</span><br>    <span class="hljs-type">ConstructorArgumentValues</span> <span class="hljs-variable">cargs</span> <span class="hljs-operator">=</span> mbd.getConstructorArgumentValues();<br>    resolvedValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstructorArgumentValues</span>();<br>    <span class="hljs-comment">// &lt;2.3.2&gt; 解析构造函数的参数</span><br>    <span class="hljs-comment">// 将该 bean 的构造函数参数解析为 resolvedValues 对象，其中会涉及到其他 bean</span><br>    minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>&lt;2.3.1&gt;</code> ，通过 BeanDefinition 的 <code>getConstructorArgumentValues()</code> 方法，就可以获取构造信息了。</li><li><code>&lt;2.3.2&gt;</code> ，有了构造信息就可以获取相关的参数值信息了，获取的参数信息包括直接值和引用，这一步骤的处理交由 <code>resolveConstructorArguments(String beanName, RootBeanDefinition mbd, BeanWrapper bw, ConstructorArgumentValues cargs, ConstructorArgumentValues resolvedValues)</code> 方法来完成。该方法会将构造参数信息解析为 <code>resolvedValues</code> 对象 并返回解析到的参数个数 <code>minNrOfArgs</code> 。</li></ul></li></ul></li><li><p>&lt;3&gt;<strong>构造函数</strong></p><p>确定构造参数后，下一步则是确定构造函数。</p><ul><li>第一步，是通过 <code>getCandidateMethods()</code> 方法，获取所有的构造方法，同时对构造方法进行刷选。</li><li>然后，在对其进行排序处理（<code>candidates.sort(AutowireUtils.EXECUTABLE_COMPARATOR)</code>）。排序的主要目的，是为了能够<strong>更加方便的</strong>找到匹配的构造函数，因为构造函数的确认是根据参数个数确认的。排序的规则是：先按照 <code>public</code> &#x2F; 非 <code>public</code> 构造函数<strong>升序</strong>，再按照构造参数数量<strong>降序</strong>。</li></ul><p>通过迭代 <code>candidates</code>（包含了所有要匹配的构造函数）的方式，依次比较其参数：</p><ul><li>如果显示提供了参数（<code>explicitArgs != null</code>），则直接比较两者<strong>长度</strong>是否相等，如果相等则表示找到了，否则继续比较。</li><li>如果没有显示提供参数，则需要获取 <code>org.springframework.core.ParameterNameDiscoverer</code> 对象。该对象为参数名称探测器，主要用于发现方法和构造函数的参数名称。</li></ul><p>将参数包装成 <code>ConstructorResolver.ArgumentsHolder</code> 对象。该对象用于保存参数，我们称之为参数持有者。当将对象包装成 ArgumentsHolder 对象后，我们就可以通过它来进行构造函数<strong>匹配</strong>。匹配分为严格模式和宽松模式：</p><ul><li>严格模式：解析构造函数时，必须所有参数都需要匹配，否则抛出异常。</li><li>宽松模式：使用具有”最接近的模式”进行匹配。</li></ul><p>判断的依据是根据 BeanDefinition 的 <code>isLenientConstructorResolution</code> 属性（该参数是我们在构造 AbstractBeanDefinition 对象是传递的）来获取类型差异权重（<code>typeDiffWeight</code>） 的。</p><ul><li>如果 <code>typeDiffWeight &lt; minTypeDiffWeight</code> ，则代表“最接近的模式”，选择其作为构造函数。</li><li>否则，只有两者具有相同的参数数量，且类型差异权重相等才会纳入考虑范围。</li></ul></li><li><p><strong>&lt;4&gt;创建Bean实例</strong></p><p>工厂对象、构造函数、构造参数都已经确认了，则最后一步就是调用 <code>org.springframework.beans.factory.support.InstantiationStrategy</code> 对象的 <code>.instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner, Object factoryBean, final Method factoryMethod, @Nullable Object... args)</code> 方法，来创建 bean 实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">instantiate</span><span class="hljs-params">(RootBeanDefinition bd, <span class="hljs-meta">@Nullable</span> String beanName, BeanFactory owner,<span class="hljs-meta">@Nullable</span> Object factoryBean, <span class="hljs-keyword">final</span> Method factoryMethod, Object... args)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 设置 Method 可访问</span><br>        <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;<br>                ReflectionUtils.makeAccessible(factoryMethod);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            ReflectionUtils.makeAccessible(factoryMethod);<br>        &#125;<br><br>        <span class="hljs-comment">// 获得原 Method 对象</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">priorInvokedFactoryMethod</span> <span class="hljs-operator">=</span> currentlyInvokedFactoryMethod.get();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 设置新的 Method 对象，到 currentlyInvokedFactoryMethod 中</span><br>            currentlyInvokedFactoryMethod.set(factoryMethod);<br>            <span class="hljs-comment">// &lt;x&gt; 创建 Bean 对象</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> factoryMethod.invoke(factoryBean, args);<br>            <span class="hljs-comment">// 未创建，则创建 NullBean 对象</span><br>            <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>                result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullBean</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 设置老的 Method 对象，到 currentlyInvokedFactoryMethod 中</span><br>            <span class="hljs-keyword">if</span> (priorInvokedFactoryMethod != <span class="hljs-literal">null</span>) &#123;<br>                currentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                currentlyInvokedFactoryMethod.remove();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IllegalArgumentException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(factoryMethod,<br>                                             <span class="hljs-string">&quot;Illegal arguments to factory method &#x27;&quot;</span> + factoryMethod.getName() + <span class="hljs-string">&quot;&#x27;; &quot;</span> +<br>                                             <span class="hljs-string">&quot;args: &quot;</span> + StringUtils.arrayToCommaDelimitedString(args), ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IllegalAccessException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(factoryMethod,<br>                                             <span class="hljs-string">&quot;Cannot access factory method &#x27;&quot;</span> + factoryMethod.getName() + <span class="hljs-string">&quot;&#x27;; is it public?&quot;</span>, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (InvocationTargetException ex) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Factory method &#x27;&quot;</span> + factoryMethod.getName() + <span class="hljs-string">&quot;&#x27; threw exception&quot;</span>;<br>        <span class="hljs-keyword">if</span> (bd.getFactoryBeanName() != <span class="hljs-literal">null</span> &amp;&amp; owner <span class="hljs-keyword">instanceof</span> ConfigurableBeanFactory &amp;&amp;<br>            ((ConfigurableBeanFactory) owner).isCurrentlyInCreation(bd.getFactoryBeanName())) &#123;<br>            msg = <span class="hljs-string">&quot;Circular reference involving containing bean &#x27;&quot;</span> + bd.getFactoryBeanName() + <span class="hljs-string">&quot;&#x27; - consider &quot;</span> +<br>                <span class="hljs-string">&quot;declaring the factory method as static for independence from its containing instance. &quot;</span> + msg;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(factoryMethod, msg, ex.getTargetException());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心的部分，在于 <code>&lt;x&gt;</code> 处，利用 Java 反射执行工厂方法并返回创建好的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SimpleInstantiationStrategy.java</span><br><br><span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> factoryMethod.invoke(factoryBean, args);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二十、创建Bean之主流程</title>
    <link href="/2022/06/11/%E5%88%9B%E5%BB%BABean%E4%B9%8B%E4%B8%BB%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/06/11/%E5%88%9B%E5%BB%BABean%E4%B9%8B%E4%B8%BB%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">创建Bean之主流程</font></div><p>承接各个scope创建bean，不论那个scope，创建Bean都会以自己的方式执行<code>createBean()</code>方法。</p><h4 id="createBean-抽象方法"><a href="#createBean-抽象方法" class="headerlink" title="createBean()抽象方法"></a><code>createBean()</code>抽象方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span> <span class="hljs-keyword">throws</span> BeanCreationException;<br></code></pre></td></tr></table></figure><ul><li>该方法定义在 AbstractBeanFactory 中，其含义是根据给定的 <code>BeanDefinition</code> 和 <code>args</code> 实例化一个 Bean 对象。</li><li>如果该 BeanDefinition 存在父类，则该 BeanDefinition 已经合并了父类的属性。</li><li>所有 Bean 实例的创建，都会委托给该方法实现。</li><li>该方法接受三个方法参数：<ul><li><code>beanName</code> ：bean 的名字。</li><li><code>mbd</code> ：已经合并了父类属性的（如果有的话）BeanDefinition 对象。</li><li><code>args</code> ：用于构造函数或者工厂方法创建 Bean 实例对象的参数。</li></ul></li></ul><h4 id="createBean-默认实现"><a href="#createBean-默认实现" class="headerlink" title="createBean()默认实现"></a><code>createBean()</code>默认实现</h4><p>该抽象方法的默认实现是在类 AbstractAutowireCapableBeanFactory 中实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span><br>    <span class="hljs-keyword">throws</span> BeanCreationException &#123;<br><br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>        logger.trace(<span class="hljs-string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbdToUse</span> <span class="hljs-operator">=</span> mbd;<br><br>    <span class="hljs-comment">// &lt;1&gt; 确保此时的 bean 已经被解析了</span><br>    <span class="hljs-comment">// 如果获取的class 属性不为null，则克隆该 BeanDefinition</span><br>    <span class="hljs-comment">// 主要是因为该动态解析的 class 无法保存到到共享的 BeanDefinition</span><br>    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);<br>    <span class="hljs-keyword">if</span> (resolvedClass != <span class="hljs-literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="hljs-literal">null</span>) &#123;<br>        mbdToUse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(mbd);<br>        mbdToUse.setBeanClass(resolvedClass);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;2&gt; 验证和准备覆盖方法</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        mbdToUse.prepareMethodOverrides();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),<br>                                               beanName, <span class="hljs-string">&quot;Validation of method overrides failed&quot;</span>, ex);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// &lt;3&gt; 实例化的前置处理</span><br>        <span class="hljs-comment">// 给 BeanPostProcessors 一个机会用来返回一个代理类而不是真正的类实例</span><br>        <span class="hljs-comment">// AOP 的功能就是基于这个地方</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);<br>        <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> bean;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,<br>                                        <span class="hljs-string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// &lt;4&gt; 创建 Bean 对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">beanInstance</span> <span class="hljs-operator">=</span> doCreateBean(beanName, mbdToUse, args);<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> beanInstance;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;<br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>            mbdToUse.getResourceDescription(), beanName, <span class="hljs-string">&quot;Unexpected exception during bean creation&quot;</span>, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>过程如下：</p><ul><li><code>&lt;1&gt;</code> 处，解析指定 BeanDefinition 的 class 属性。</li><li><code>&lt;2&gt;</code> 处，处理 <code>override</code> 属性。</li><li><code>&lt;3&gt;</code> 处，实例化的前置处理。</li><li><code>&lt;4&gt;</code> 处，创建 Bean 对象。</li></ul><h5 id="解析指定-BeanDefinition-的-class-属性"><a href="#解析指定-BeanDefinition-的-class-属性" class="headerlink" title="解析指定 BeanDefinition 的 class 属性"></a>解析指定 BeanDefinition 的 class 属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><br>Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);<br><span class="hljs-keyword">if</span> (resolvedClass != <span class="hljs-literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="hljs-literal">null</span>) &#123;<br>    mbdToUse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(mbd);<br>    mbdToUse.setBeanClass(resolvedClass);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>resolveBeanClass(final RootBeanDefinition mbd, String beanName, final Class... typesToMatch)</code> 方法，主要是解析 bean definition 的 class 类，并将已经解析的 Class 存储在 bean definition 中以供后面使用。</li><li>如果解析的 class 不为空，则会将该 BeanDefinition 进行设置到 <code>mbdToUse</code> 中。这样做的主要目的是，以为动态解析的 class 是无法保存到共享的 BeanDefinition 中。</li></ul><h5 id="处理override属性"><a href="#处理override属性" class="headerlink" title="处理override属性"></a>处理<code>override</code>属性</h5><p> <code>lookup-method</code> 和 <code>replace-method</code> 这两个标签的用法和解析过程之前有分析，这两个配置存放在 BeanDefinition 中的 <code>methodOverrides</code> 属性中。</p><p>我们知道在 bean 实例化的过程中如果检测到存在 <code>methodOverrides</code> ，则会动态地位为当前 bean 生成代理并使用对应的拦截器为 bean 做<strong>增强处理</strong>。</p><p>之后会做具体分析，此处先看<code> mbdToUse.prepareMethodOverrides();</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanDefinition.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareMethodOverrides</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeanDefinitionValidationException &#123;<br>    <span class="hljs-comment">// Check that lookup methods exist and determine their overloaded status.</span><br>    <span class="hljs-keyword">if</span> (hasMethodOverrides()) &#123;<br>        <span class="hljs-comment">// 循环，执行 prepareMethodOverride，之前版本执行forEach的时候会先synchronized加锁</span><br>        getMethodOverrides().getOverrides().forEach(<span class="hljs-built_in">this</span>::prepareMethodOverride);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> MethodOverrides <span class="hljs-title function_">getMethodOverrides</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.methodOverrides;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-type">MethodOverrides</span> <span class="hljs-variable">methodOverrides</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodOverrides</span>();<br><br><span class="hljs-comment">// MethodOverrides.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;MethodOverride&gt; overrides = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArraySet</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>如果存在 <code>methodOverrides</code> ，则获取所有的 override method ，然后通过迭代的方法一次调用 <code>prepareMethodOverride(MethodOverride mo)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareMethodOverride</span><span class="hljs-params">(MethodOverride mo)</span> <span class="hljs-keyword">throws</span> BeanDefinitionValidationException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());<br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionValidationException</span>(<br>            <span class="hljs-string">&quot;Invalid method override: no method with name &#x27;&quot;</span> + mo.getMethodName() +<br>            <span class="hljs-string">&quot;&#x27; on class [&quot;</span> + getBeanClassName() + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// Mark override as not overloaded, to avoid the overhead of arg type checking.</span><br>        mo.setOverloaded(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>根据方法名称，从 class 中获取该方法名的个数：<ul><li>如果个数为 0 ，则抛出 BeanDefinitionValidationException 异常。</li><li>如果个数为 1 ，则设置该重载方法<strong>没有被重载</strong>。</li></ul></li></ul><ul><li>若一个类中存在<strong>多个</strong>重载方法，则在方法调用的时候还需要根据参数类型来判断到底重载的是哪个方法。在设置重载的时候其实这里做了一个<strong>小小优化</strong>，那就是当 <code>count == 1</code> 时，设置 <code>overloaded = false</code> ，这样表示该方法没有重载。这样，在后续调用的时候，便可以直接找到方法而不需要进行方法参数的校验。</li></ul><h5 id="实例化的前置处理"><a href="#实例化的前置处理" class="headerlink" title="实例化的前置处理"></a>实例化的前置处理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanDefinition.java</span><br><span class="hljs-comment">// &lt;3&gt; 实例化的前置处理</span><br><span class="hljs-comment">// 给 BeanPostProcessors 一个机会用来返回一个代理类而不是真正的类实例</span><br><span class="hljs-comment">// AOP 的功能就是基于这个地方</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);<br><span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果代理对象不为空，则直接返回代理对象，这一步骤有非常重要的作用，Spring 后续实现 AOP 就是基于这个地方判断的。</p><p><code>resolveBeforeInstantiation()</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">resolveBeforeInstantiation</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;<br>        <span class="hljs-comment">// Make sure bean class is actually resolved at this point.</span><br>        <span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>            Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);<br>            <span class="hljs-keyword">if</span> (targetType != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//前置</span><br>                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);<br>                <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//后置</span><br>                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);<br>                &#125;<br>            &#125;<br>        &#125;<br>        mbd.beforeInstantiationResolved = (bean != <span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法核心就在于 <code>applyBeanPostProcessorsBeforeInstantiation()</code> 和 <code>applyBeanPostProcessorsAfterInitialization()</code> 两个方法，before 为实例化前的后处理器应用，after 为实例化后的后处理器应用。</p><h5 id="执行doCreateBean-创建Bean"><a href="#执行doCreateBean-创建Bean" class="headerlink" title="执行doCreateBean()创建Bean"></a>执行<code>doCreateBean()</code>创建Bean</h5><p>如果没有代理对象，就只能走常规的路线进行 bean 的创建了，该过程有 <code>doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)</code> 方法来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span> <span class="hljs-keyword">throws</span> BeanCreationException &#123;<br><br>    <span class="hljs-comment">// Instantiate the bean.</span><br>    <span class="hljs-comment">// BeanWrapper 是对 Bean 的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，获取被包装 bean 的属性描述器</span><br>    <span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// &lt;1&gt; 单例模型，则从未完成的 FactoryBean 缓存中删除</span><br>    <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>        instanceWrapper = <span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);<br>    &#125;<br>    <span class="hljs-comment">// &lt;2&gt; 使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化</span><br>    <span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>        instanceWrapper = createBeanInstance(beanName, mbd, args);<br>    &#125;<br>    <span class="hljs-comment">// 包装的实例对象</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> instanceWrapper.getWrappedInstance();<br>    <span class="hljs-comment">// 包装的实例对象的类型</span><br>    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();<br>    <span class="hljs-keyword">if</span> (beanType != NullBean.class) &#123;<br>        mbd.resolvedTargetType = beanType;<br>    &#125;<br><br>    <span class="hljs-comment">// Allow post-processors to modify the merged bean definition.</span><br>    <span class="hljs-comment">// &lt;3&gt; 判断是否有后置处理</span><br>    <span class="hljs-comment">// 如果有后置处理，则允许后置处理修改 BeanDefinition</span><br>    <span class="hljs-keyword">synchronized</span> (mbd.postProcessingLock) &#123;<br>        <span class="hljs-keyword">if</span> (!mbd.postProcessed) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 后置处理修改 BeanDefinition</span><br>                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                                                <span class="hljs-string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);<br>            &#125;<br>            mbd.postProcessed = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Eagerly cache singletons to be able to resolve circular references</span><br>    <span class="hljs-comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br>    <span class="hljs-comment">// &lt;4&gt; 解决单例模式的循环依赖</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">earlySingletonExposure</span> <span class="hljs-operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-comment">// 单例模式</span><br>                                      <span class="hljs-built_in">this</span>.allowCircularReferences &amp;&amp; <span class="hljs-comment">// 运行循环依赖</span><br>                                      isSingletonCurrentlyInCreation(beanName));<span class="hljs-comment">// 当前单例 bean 是否正在被创建</span><br>    <span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +<br>                         <span class="hljs-string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 提前将创建的 bean 实例加入到 singletonFactories 中</span><br>        <span class="hljs-comment">// 这里是为了后期避免循环依赖</span><br>        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br>    &#125;<br><br>    <span class="hljs-comment">// Initialize the bean instance.</span><br>    <span class="hljs-comment">// 开始初始化 bean 实例对象</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// &lt;5&gt; 对 bean 进行填充，将各个属性值注入，其中，可能存在依赖于其他 bean 的属性</span><br>        <span class="hljs-comment">// 则会递归初始依赖 bean</span><br>        populateBean(beanName, mbd, instanceWrapper);<br>        <span class="hljs-comment">// &lt;6&gt; 调用初始化方法</span><br>        exposedObject = initializeBean(beanName, exposedObject, mbd);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;<br>            <span class="hljs-keyword">throw</span> (BeanCreationException) ex;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>                mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Initialization of bean failed&quot;</span>, ex);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// &lt;7&gt; 循环依赖处理</span><br>    <span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>        <span class="hljs-comment">// 获取 earlySingletonReference</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">earlySingletonReference</span> <span class="hljs-operator">=</span> getSingleton(beanName, <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 只有在存在循环依赖的情况下，earlySingletonReference 才不会为空</span><br>        <span class="hljs-keyword">if</span> (earlySingletonReference != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果 exposedObject 没有在初始化方法中被改变，也就是没有被增强</span><br>            <span class="hljs-keyword">if</span> (exposedObject == bean) &#123;<br>                exposedObject = earlySingletonReference;<br>                <span class="hljs-comment">// 处理依赖</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;<br>                String[] dependentBeans = getDependentBeans(beanName);<br>                Set&lt;String&gt; actualDependentBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);<br>                <span class="hljs-keyword">for</span> (String dependentBean : dependentBeans) &#123;<br>                    <span class="hljs-keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;<br>                        actualDependentBeans.add(dependentBean);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName,<br>                                                               <span class="hljs-string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; has been injected into other beans [&quot;</span> +<br>                                                               StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +<br>                                                               <span class="hljs-string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +<br>                                                               <span class="hljs-string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +<br>                                                               <span class="hljs-string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +<br>                                                               <span class="hljs-string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Register bean as disposable.</span><br>    <span class="hljs-comment">// &lt;8&gt; 注册 bean</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        registerDisposableBeanIfNecessary(beanName, bean, mbd);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>            mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Invalid destruction signature&quot;</span>, ex);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>整体流程：</p><ul><li><code>&lt;1&gt;</code> 处，如果是单例模式，则清除缓存。</li><li><code>&lt;2&gt;</code> 处，调用 <code>createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args)</code> 方法，实例化 bean ，主要是将 BeanDefinition 转换为 <code>org.springframework.beans.BeanWrapper</code> 对象。</li><li><code>&lt;3&gt;</code> 处，MergedBeanDefinitionPostProcessor 的应用。</li><li><code>&lt;4&gt;</code> 处，单例模式的循环依赖处理。</li><li><code>&lt;5&gt;</code> 处，调用 <code>populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</code> 方法，进行属性填充。将所有属性填充至 bean 的实例中。</li><li><code>&lt;6&gt;</code> 处，调用 <code>initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd)</code> 方法，初始化 bean 。</li><li><code>&lt;7&gt;</code> 处，依赖检查。</li><li><code>&lt;8&gt;</code> 处，注册 DisposableBean 。</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二十五、创建Bean之初始化Bean</title>
    <link href="/2022/06/11/%E5%88%9B%E5%BB%BABean%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96Bean/"/>
    <url>/2022/06/11/%E5%88%9B%E5%BB%BABean%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96Bean/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">创建Bean之初始化Bean</font></div><p>一个 bean 经历了 <code>createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args)</code> 方法，被创建出来，然后又经过了一番属性注入，依赖处理，接下来执行最后一步就是<strong>初始化</strong>，即执行<code>initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd)</code> 方法，这也是<code>doCreateBean(...)</code> 方法的中最后一步：初始化 bean 对象。</p><h4 id="initializeBean-方法"><a href="#initializeBean-方法" class="headerlink" title="initializeBean()方法"></a><code>initializeBean()</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">initializeBean</span><span class="hljs-params">(String beanName, Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;<br>    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 安全模式</span><br>        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;<br>            <span class="hljs-comment">// &lt;1&gt; 激活 Aware 方法，对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware</span><br>            invokeAwareMethods(beanName, bean);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;, getAccessControlContext());<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// &lt;1&gt; 激活 Aware 方法，对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware</span><br>        invokeAwareMethods(beanName, bean);<br>    &#125;<br>    <span class="hljs-comment">// &lt;2&gt; 后置处理器，before</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">wrappedBean</span> <span class="hljs-operator">=</span> bean;<br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;3&gt; 激活用户自定义的 init 方法</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        invokeInitMethods(beanName, wrappedBean, mbd);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>            (mbd != <span class="hljs-literal">null</span> ? mbd.getResourceDescription() : <span class="hljs-literal">null</span>),<br>            beanName, <span class="hljs-string">&quot;Invocation of init method failed&quot;</span>, ex);<br>    &#125;<br>    <span class="hljs-comment">// &lt;2&gt; 后置处理器，after</span><br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> wrappedBean;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化 bean 的方法其实就是三个步骤的处理，而这三个步骤主要还是根据<strong>用户设定</strong>的来进行初始化，这三个过程为：</p><ul><li><code>&lt;1&gt;</code> 激活 Aware 方法。</li><li><code>&lt;3&gt;</code> 后置处理器的应用。</li><li><code>&lt;2&gt;</code> 激活自定义的 init 方法。</li></ul><h5 id="激活-Aware-方法"><a href="#激活-Aware-方法" class="headerlink" title="激活 Aware 方法"></a>激活 Aware 方法</h5><p>Spring 提供了诸多 Aware 接口，用于辅助 Spring Bean 以编程的方式调用 Spring 容器，通过实现这些接口，可以增强 Spring Bean 的功能。</p><p>Spring 提供了如下系列的 Aware 接口：</p><ul><li>LoadTimeWeaverAware：加载Spring Bean时织入第三方模块，如AspectJ</li><li>BeanClassLoaderAware：加载Spring Bean的类加载器</li><li>BootstrapContextAware：资源适配器BootstrapContext，如JCA,CCI</li><li>ResourceLoaderAware：底层访问资源的加载器</li><li>BeanFactoryAware：声明BeanFactory</li><li>PortletConfigAware：PortletConfig</li><li>PortletContextAware：PortletContext</li><li>ServletConfigAware：ServletConfig</li><li>ServletContextAware：ServletContext</li><li>MessageSourceAware：国际化</li><li>ApplicationEventPublisherAware：应用事件</li><li>NotificationPublisherAware：JMX通知</li><li>BeanNameAware：声明Spring Bean的名字</li></ul><p><code>invokeAwareMethods()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><br><span class="hljs-comment">//主要是处理 BeanNameAware、BeanClassLoaderAware、BeanFactoryAware 。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeAwareMethods</span><span class="hljs-params">(String beanName, Object bean)</span> &#123;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Aware) &#123;<br>        <span class="hljs-comment">// BeanNameAware</span><br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanNameAware) &#123;<br>            ((BeanNameAware) bean).setBeanName(beanName);<br>        &#125;<br>        <span class="hljs-comment">// BeanClassLoaderAware</span><br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanClassLoaderAware) &#123;<br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">bcl</span> <span class="hljs-operator">=</span> getBeanClassLoader();<br>            <span class="hljs-keyword">if</span> (bcl != <span class="hljs-literal">null</span>) &#123;<br>                ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// BeanFactoryAware</span><br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanFactoryAware) &#123;<br>            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="后置处理器的应用"><a href="#后置处理器的应用" class="headerlink" title="后置处理器的应用"></a>后置处理器的应用</h5><p>BeanPostProcessor 在前面介绍 bean 加载的过程已多次遇到。</p><p>BeanPostProcessor 的作用是：如果我们想要在 Spring 容器完成 Bean 的实例化，配置和其他的初始化后添加一些自己的逻辑处理，那么请使用该接口，这个接口给与了用户充足的权限去更改或者扩展 Spring，是我们对 Spring 进行扩展和增强处理一个必不可少的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">applyBeanPostProcessorsBeforeInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span><br>    <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> existingBean;<br>    <span class="hljs-comment">// 遍历 BeanPostProcessor 数组</span><br>    <span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;<br>        <span class="hljs-comment">// 处理</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> processor.postProcessBeforeInitialization(result, beanName);<br>        <span class="hljs-comment">// 返回空，则返回 result</span><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-comment">// 修改 result</span><br>        result = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">applyBeanPostProcessorsAfterInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span><br>    <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> existingBean;<br>    <span class="hljs-comment">// 遍历 BeanPostProcessor</span><br>    <span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;<br>        <span class="hljs-comment">// 处理</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> processor.postProcessAfterInitialization(result, beanName);<br>        <span class="hljs-comment">// 返回空，则返回 result</span><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        result = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实，逻辑就是通过 <code>getBeanPostProcessors()</code> 方法，获取定义的 BeanPostProcessor ，然后分别调用其 <code>postProcessBeforeInitialization(...)</code>、<code>postProcessAfterInitialization(...)</code> 方法，进行<strong>自定义</strong>的业务处理。</p><h5 id="激活自定义的-init-方法"><a href="#激活自定义的-init-方法" class="headerlink" title="激活自定义的 init 方法"></a>激活自定义的 init 方法</h5><p>spring配置文件中的<code>&lt;bean&gt;</code>标签，有一个属性<code>init-method</code>，该属性的方法值就是通过以下方法执行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeInitMethods</span><span class="hljs-params">(String beanName, Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span><br>    <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>    <span class="hljs-comment">// 首先会检查是否是 InitializingBean ，如果是的话需要调用 afterPropertiesSet()</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isInitializingBean</span> <span class="hljs-operator">=</span> (bean <span class="hljs-keyword">instanceof</span> InitializingBean);<br>    <span class="hljs-keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="hljs-literal">null</span> || !mbd.isExternallyManagedInitMethod(<span class="hljs-string">&quot;afterPropertiesSet&quot;</span>))) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 安全模式</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;<br>                    <span class="hljs-comment">// &lt;1&gt; 属性初始化的处理</span><br>                    ((InitializingBean) bean).afterPropertiesSet();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;, getAccessControlContext());<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (PrivilegedActionException pae) &#123;<br>                <span class="hljs-keyword">throw</span> pae.getException();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// &lt;1&gt; 属性初始化的处理</span><br>            ((InitializingBean) bean).afterPropertiesSet();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mbd != <span class="hljs-literal">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">initMethodName</span> <span class="hljs-operator">=</span> mbd.getInitMethodName();<br>        <span class="hljs-keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;<br>            !(isInitializingBean &amp;&amp; <span class="hljs-string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;<br>            !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;<br>            <span class="hljs-comment">// &lt;2&gt; 激活用户自定义的初始化方法</span><br>            invokeCustomInitMethod(beanName, bean, mbd);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先，检查是否为 InitializingBean 。如果<strong>是</strong>的话，需要执行 <code>afterPropertiesSet()</code> 方法，因为我们除了可以使用 <code>init-method</code> 来自定初始化方法外，还可以实现 InitializingBean 接口。接口仅有一个 <code>afterPropertiesSet()</code> 方法。</li><li>两者的执行先后顺序是先 <code>&lt;1&gt;</code> 的 <code>afterPropertiesSet()</code> 方法，后 <code>&lt;2&gt;</code> 的 <code>init-method</code> 对应的方法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五十音</title>
    <link href="/2022/06/11/%E4%BA%94%E5%8D%81%E9%9F%B3/"/>
    <url>/2022/06/11/%E4%BA%94%E5%8D%81%E9%9F%B3/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">五十音</font></div><h4 id="五十音记忆"><a href="#五十音记忆" class="headerlink" title="五十音记忆"></a>五十音记忆</h4><h5 id="联想记忆"><a href="#联想记忆" class="headerlink" title="联想记忆"></a>联想记忆</h5><p><code>い</code>理服人<code>イ</code>。</p><p>烟囱<code>ウ</code>放烟造成雾<code>u</code>霾，导致人弯腰咳嗽<code>う</code>。</p><p>爱<code>e</code>上了元<code>え</code>首的工<code>工</code>作。</p><p>大力<code>力</code>水手握拳<code>ka</code>、<code>か</code>响。</p><p>在夕阳下<code>ku</code>、<code>く</code>了好久，直到太阳落了山<code>ク</code>–和狠人、狼人一个梗。</p><p>浪客<code>ke</code>剑心举着刀<code>ケ</code>，是名真正的武士<code>け</code>。</p><p><code>こ</code>和<code>コ</code>是朝着不同方向张开的大口<code>ko</code>。</p><p><code>さ</code>、<code>サ</code>、<code>sa</code>想到了<code>ki</code>，但是<code>き</code>不知道怎么联想。</p><p>弯曲的<code>し</code>溪<code>shi</code>流溢满了水<code>シ</code>。</p><p>长着肚腩的人<code>す）</code>做起了俯卧撑<code>ス</code>，没有丝<code>su</code>毫懈怠。</p><p><code>そ</code>、<code>ソ</code>、<code>so</code>求指点。</p><p>他<code>ta</code>的晚年好比午后的太<code>た</code>阳—夕<code>タ</code>阳。</p><p>千<code>チ</code>年古<code>ち</code>器<code>chi</code>，或者5.7。</p><p>刺<code>tsu</code>猬慢慢蜷缩<code>ツ</code>，直到看不见腿<code>つ</code>—先藏了两只腿。</p><p>他太<code>te</code>喜欢荡单杠<code>て</code>和双杠<code>テ</code>了。</p><p>独角兽<code>と</code>从网上淘<code>to</code>了一根萝卜<code>ト</code>。</p><p>一个人拿<code>na</code>着剑<code>ナ</code>，骑着马<code>な</code>—右半部分一直看着像窝在地上的马，点是马头。</p><p>一个人用筷子<code>に </code>、<code>ニ</code>吃到了泥<code>ni</code>。</p><p><code>ぬ</code>、<code>nu</code>隶又<code>ヌ</code>失去了自由。</p><p>权<code>ね</code>利让我对这种事视<code>ネ</code>而不见，很无奈<code>ne</code>。</p><p><code>の</code>和<code>ノ</code>都是<code>no</code>，禁止的意思—-有种一个圈一个斜杠，例如禁止停车的感觉。</p><p>卓别林拄着拐杖<code>は</code>，走路外八<code>ハ</code>，让人哈<code>ha</code>大笑。</p><p>他拿着刀<code>ヒ</code>切肉，端着酒碗<code>ひ</code>，很<code>hi</code>是惬意。</p><p>他呼呼huhu–<code>fufu</code>地跑过去<code>ふ</code>抢猪耳朵<code>フ</code>吃—-自己想象一只猪头。</p><p><code>へ</code>和<code>ヘ</code>都是黑<code>he</code>色的胡子—-哈哈哈毛利小五郎。</p><p>不管什么样的马路<code>ほ</code>边都种了好<code>ho</code>多树木<code>ホ</code>—-笔直的路弯曲的路十字路丁字路。</p><p>少了一只腿<code>マ</code>的蚂<code>ma</code>蚁<code>ま</code>—-圆圈很像蚂蚁屁股。</p><p>端午有甜米<code>mi</code>粽和带有好多木桨<code>ミ</code>的龙舟<code>み</code>—-姑且看成船。</p><p>坐在地上的和服姑娘<code>む</code>在纺织，她的旁边站了头母<code>mu</code>牛<code>ム</code>。</p><p>标着记号<code>メ</code>的绵羊<code>め</code>咩咩<code>me</code>叫—-上边有羊角的感觉，左边羊脸，小羊肖恩，养牧场经常看到牲畜有标记。</p><p><code>も</code>像长满了毛<code>モ</code>的猫<code>mo</code>——猫的尾巴很灵活。</p><p>亚<code>ya</code>军也<code>や ヤ</code>行—注意和<code>se せ セ</code>区分。</p><p>第2<code>ユ</code>有点中<code>ゆ </code>庸<code>yu</code>—像2有点勉强，倒是像礼帽，庸谐音。</p><p>音乐<code>yo</code>、<code>よ</code>和梳子<code>ヨ</code>是歌妓必备—–音谱里的小蝌蚪。</p><p>眯着眼睛大声说<code>ラ</code>辣<code>ra</code>椒5<code>ら</code>元。</p><p>分离<code>ri</code>的人背对背离开<code>り リ</code>。</p><p>你是个歹<code>る</code>徒儿<code>ル</code>，6陆<code>ru</code>—-儿化音，哈哈哈。</p><p>我从机<code>れ</code>构<code>レ</code>回来<code>re</code>。</p><p>老<code>ro</code>3<code>ろ</code>的口<code>ロ</code>才真好。</p><p>挖<code>wa</code>土机<code>わ</code>、<code>ワ</code>—-很像挖土机的机械手臂。</p><p>我<code>wo</code>跨栏<code>を</code>就像张开翅膀在飞<code>ヲ</code>—-上边一个小人下边栏杆，火影里的中二跑法手臂向后。</p><p><code>n</code>嗯，大脑想象中：<code>ん</code>是普通的椅子，<code>ン</code>是电影院或者礼堂的折叠椅。</p><h5 id="成语记忆（涵盖浊音）"><a href="#成语记忆（涵盖浊音）" class="headerlink" title="成语记忆（涵盖浊音）"></a>成语记忆（涵盖浊音）</h5><table><thead><tr><th></th><th>あ段</th><th>い段</th><th>う段</th><th>え段</th><th>お段</th></tr></thead><tbody><tr><td>あ行</td><td>吴下あ蒙</td><td>掉い轻心</td><td>う合之众</td><td>え声叹气</td><td>おお待哺</td></tr><tr><td>か行</td><td>雀巢か啡</td><td>白手き家</td><td>痛く流涕</td><td>遍地け花</td><td>病从こ入</td></tr><tr><td>さ行</td><td>赶尽さ绝</td><td>一贫如し</td><td>一座す庙</td><td>せ翁失马</td><td>そ人墨客</td></tr><tr><td>た行</td><td>客死た乡</td><td>出ち制胜</td><td>理屈つ穷</td><td>不识て举</td><td>と塔天王</td></tr><tr><td>な行</td><td>摇旗な喊</td><td>我喜欢に</td><td>沦为ぬ隶</td><td>无可ね何</td><td>一の千金</td></tr><tr><td>は行</td><td>点头は腰</td><td>ひひ哈哈</td><td>出水ふ蓉</td><td>人山人へ</td><td>死去ほ来</td></tr><tr><td>ま行</td><td>婆婆まま</td><td>神み莫测</td><td>衣食父む</td><td>爱情め卖</td><td>不も之地</td></tr><tr><td>や行</td><td>咿や学语</td><td></td><td>尊老爱ゆ</td><td></td><td>无关紧よ</td></tr><tr><td>ら行</td><td>摧枯ら朽</td><td>见り忘义</td><td>看片る管</td><td>别れ无恙</td><td>滴水不ろ</td></tr><tr><td>わ行</td><td>开わ掘机</td><td></td><td></td><td></td><td>笑を江湖</td></tr></tbody></table><h4 id="音节声调"><a href="#音节声调" class="headerlink" title="音节声调"></a>音节声调</h4><h5 id="声调"><a href="#声调" class="headerlink" title="声调"></a>声调</h5><p>①型：单词不论是几个音节（最少是1个音节），从高音入手，第二拍下降，一直到读到最后<br>拍节也不上升。<br>②型：单词不论是几个音节（最少是2个音节），从低音入手，第二拍升高，第三拍下降读到<br>最后拍节也不上升。<br>③型：单词不论是几个音节（最少是3个音节），从低音入手，第二拍升高，第三拍保持，第<br>四拍下降，读到最后拍节也不上升。<br>④型：单词不论是几个音节（最少是4个音节），从低音入手，第二拍升高，保持到第四拍，<br>第五拍下降，读到最后拍节也不上升。<br>⑤型：单词不论是几个音节（最少是5个音节），从低音入手，第二拍升高，保持到第五拍，<br>第六拍下降，读到最后拍节也不上升。<br>⑥型：单词不论是几个音节（最少是6个音节），从低音入手，第二拍升高，保持到第六拍</p><h5 id="音节"><a href="#音节" class="headerlink" title="音节"></a>音节</h5><p>片假名用于名词、外来语、拟声拟态词。</p><p>送气音和不送气音。</p><p><code>か</code>行、<code>た</code>行、<code>ぱ</code>行：词头，送气词，正常读；词中或者词尾，不送气词。</p><h6 id="浊音：右上两点"><a href="#浊音：右上两点" class="headerlink" title="浊音：右上两点"></a><strong>浊音：</strong>右上两点</h6><p><code>が</code>行也有两种读法：词头－－正常读音，词中或者词尾－－正常读音或者鼻浊音（播音员、女性、老年人多用）。</p><p><code>k</code>－－<code>g</code>、<code>s</code>－－<code>z</code>、<code>t</code>－－<code>d</code>、<code>h</code>－－<code>b</code></p><h6 id="半浊音：右上○"><a href="#半浊音：右上○" class="headerlink" title="半浊音：右上○"></a><strong>半浊音：</strong>右上○</h6><p><code>h</code>－－<code>p</code></p><table><thead><tr><th></th><th>あ段</th><th>い段</th><th>う段</th><th>え段</th><th>お段</th></tr></thead><tbody><tr><td>が行</td><td>尴が无比</td><td>ぎ祀祖先</td><td>粉身碎ぐ</td><td>农田灌げ</td><td>奔走相ご</td></tr><tr><td>ざ行</td><td>安营ざ寨</td><td>劫富じ贫</td><td>汰ず洗衣</td><td>天ぜ人祸</td><td>自ぞ自受</td></tr><tr><td>だ行</td><td>博だ精深</td><td>偷ぢ摸狗</td><td>雄づ英发</td><td>で若木鸡</td><td>ど转星移</td></tr><tr><td>ば行</td><td>ば格牙路</td><td>***び的</td><td>真ぶ要脸</td><td>青天べ日</td><td>厚积ぼ发</td></tr><tr><td>ぱ行</td><td>噼里ぱ啦</td><td>鸡毛蒜ぴ</td><td>飞蛾ぷ火</td><td>ぺ案而起</td><td>牢不可ぽ</td></tr></tbody></table><p><code>水ざ</code>行和<code>だ</code>行中都有<code>ji</code>和<code>zu</code>。</p><p><code>ざ</code>行的<code>じ</code>和和<code>ず</code> ，使用频率高，打字直接使用<code>ji</code>和<code>zu</code>。</p><p><code>だ</code>行的<code>ぢ</code>和<code>づ</code>，使用频率低，打字使用<code>di</code>和<code>du</code>。</p><h6 id="拗音"><a href="#拗音" class="headerlink" title="拗音"></a>拗音</h6><p><code>拗音</code>是模仿中国古汉字的发音。</p><p><code>い</code>段（除<code>い</code>、<code>ぢ</code>外）＋　<code>や</code>、<code>ゆ</code>、<code>よ</code>（右下角小一号，类似于整个字的一部分）。</p><p><strong>注：</strong>是<u>段</u>不是<del>行</del>。</p><p>き、し、ち、に、ひ、み、り　　　ぎ、じ、び、ぴ</p><p><code>合拗音</code>是模仿西方外来语的发音，专门用于标记外来语，故只有片假名。</p><h5 id="特殊音节"><a href="#特殊音节" class="headerlink" title="特殊音节"></a>特殊音节</h5><h6 id="拨音"><a href="#拨音" class="headerlink" title="拨音"></a>拨音</h6><p><code>拨音</code>受其后音节影响。</p><p><strong>注：</strong>都是<u>段</u>不是<del>行</del>。</p><table><thead><tr><th>表记方式</th><th>发音</th></tr></thead><tbody><tr><td>あ段　＋　ん</td><td>ang</td></tr><tr><td>い段　＋　ん</td><td>in</td></tr><tr><td>う段　＋　ん</td><td>un</td></tr><tr><td>え段　＋　ん</td><td>en</td></tr><tr><td>お段　＋　ん</td><td>ong</td></tr></tbody></table><h6 id="促音"><a href="#促音" class="headerlink" title="促音"></a>促音</h6><p><strong>促音</strong>（日语：促音／そくおん <em>sokuon</em>）是在日语中用来表示停顿的符号，写法为っ、片假名ッ。</p><p>促音&#96;分为摩擦促音和阻塞促音，促音不可单独发音，占一个音拍，小一号（片假名和平假名）。</p><p>促音っ只出现在か行、さ行、た行、ぱ(半浊音)行前面。</p><p>阻塞促音：在促音っ后面连接か行（か、き、く、け、こ）的时候，以 k 的发音方法顿挫一拍（只做口型不出声）。</p><p>摩擦促音：促音位于<code>さ</code>行之前。</p><p><strong>注：</strong>都是<u>行</u>不是<del>段</del>。</p><p>在电脑打字时，若要单独输入促音“っ”，可输入xtsu、xtu、ltsu或ltu。</p><h6 id="长音"><a href="#长音" class="headerlink" title="长音"></a>长音</h6><p>例：<code>いい</code>发一个音，但是拉长，yi……，不是yiyi。</p><p><strong>注：</strong>都是<u>段</u>不是<del>行</del>。</p><table><thead><tr><th></th><th>表记方式</th></tr></thead><tbody><tr><td>平假名</td><td>あ段　＋　あ</td></tr><tr><td></td><td>い段　＋　い</td></tr><tr><td></td><td>う段　＋　う</td></tr><tr><td></td><td>え段　＋　う（多数）</td></tr><tr><td></td><td>え段　＋　え（少数）</td></tr><tr><td></td><td>お段　＋　う（多数）</td></tr><tr><td></td><td>お段　＋　お（少数）</td></tr><tr><td>片假名</td><td>一</td></tr></tbody></table><h6 id="拗长音"><a href="#拗长音" class="headerlink" title="拗长音"></a>拗长音</h6><p>在<code>拗音</code>后边加上<code>い</code>、<code>う</code>即可成为拗长音。外来语后加上<code>一</code>。</p><table><thead><tr><th></th><th>表记方式</th></tr></thead><tbody><tr><td>平假名</td><td>[い段　＋　や]　＋　い</td></tr><tr><td></td><td>[い段　＋　ゆ]　＋　う</td></tr><tr><td></td><td>[い段　＋　よ]　＋　う</td></tr><tr><td>片假名</td><td>一</td></tr></tbody></table><h6 id="外来语专用音节"><a href="#外来语专用音节" class="headerlink" title="外来语专用音节"></a>外来语专用音节</h6><table><thead><tr><th>ツァ　<strong>tsa</strong></th><th>ファ　<strong>fa</strong></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>ウィ　<strong>wi</strong></td><td>ティ　<strong>ti</strong></td><td>フィ　<strong>fi</strong></td><td>ディ　<strong>di</strong></td><td></td><td></td></tr><tr><td>トゥ　<strong>tu</strong></td><td>ドゥ　<strong>du</strong></td><td>デュ　<strong>dyu</strong></td><td></td><td></td><td></td></tr><tr><td>ウェ　<strong>we</strong></td><td>シェ　<strong>she</strong></td><td>チェ　<strong>che</strong></td><td>ツェ　<strong>tse</strong></td><td>フェ　<strong>fe</strong></td><td>ジェ　<strong>je</strong></td></tr><tr><td>ウォ　<strong>wo</strong></td><td>ツォ　<strong>tso</strong></td><td>フォ　<strong>fo</strong></td><td></td><td></td><td></td></tr></tbody></table><h4 id="五十音日语单词"><a href="#五十音日语单词" class="headerlink" title="五十音日语单词"></a>五十音日语单词</h4><table><thead><tr><th>日语</th><th>中文</th><th>日语</th><th>中文</th></tr></thead><tbody><tr><td>あい</td><td>爱</td><td>え</td><td>绘画</td></tr><tr><td>あおい</td><td>蓝色</td><td>うお</td><td>鱼</td></tr><tr><td>いか</td><td>乌贼</td><td>えき</td><td>车站</td></tr><tr><td>いけ</td><td>池塘</td><td>かく</td><td>书写</td></tr><tr><td>かお</td><td>脸</td><td>あき</td><td>秋天</td></tr><tr><td>すし</td><td>寿司</td><td>いす</td><td>椅子</td></tr><tr><td>さけ</td><td>酒</td><td>せかい</td><td>世界</td></tr><tr><td>あさ</td><td>早上</td><td>おかし</td><td>点心</td></tr><tr><td>はな</td><td>花</td><td>ひたい</td><td>额头</td></tr><tr><td>へた</td><td>不擅长</td><td>はし</td><td>桥</td></tr><tr><td>ほし</td><td>星星</td><td>ふさい</td><td>夫妻</td></tr><tr><td>まち</td><td>街道</td><td>あめ</td><td>雨</td></tr><tr><td>かいもの</td><td>购物</td><td>かみ</td><td>头发</td></tr><tr><td>やおや</td><td>果蔬店</td><td>おかゆ</td><td>粥</td></tr><tr><td>よなか</td><td>半夜</td><td>やすい（休）</td><td>休息</td></tr><tr><td>さくら（桜）</td><td>樱花</td><td>くすり（薬）</td><td>药</td></tr><tr><td>ホテル（hotel）</td><td>宾馆（外来语使用片假名）</td><td>ロシア（Russia）</td><td>俄罗斯（外来语）</td></tr><tr><td>かれし</td><td>男朋友</td><td>はしる</td><td>奔跑</td></tr><tr><td>にわ</td><td>院子</td><td>わらう</td><td>笑</td></tr><tr><td>お休み（なさい——敬语）</td><td>晚安</td><td>またね</td><td>再见</td></tr><tr><td>また明日（あした）</td><td>明天见</td><td>おねちよ</td><td>尿床</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>新标日</category>
      
      <category>上册</category>
      
      <category>单词</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十七、从单例缓存中获取Bean</title>
    <link href="/2022/06/11/%E4%BB%8E%E5%8D%95%E4%BE%8B%E7%BC%93%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96Bean/"/>
    <url>/2022/06/11/%E4%BB%8E%E5%8D%95%E4%BE%8B%E7%BC%93%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96Bean/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">从单例缓存中获取Bean</font></div><p><code>getBean()</code>的第一个过程，获取<code>beanName</code>上篇已经介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 如果容器中包含对应的bean则直接返回</span><br><span class="hljs-comment">* 如果 sharedInstance = null，则说明缓存里没有对应的实例，表明这个实例还没创建。</span><br><span class="hljs-comment">* BeanFactory 并不会在一开始就将所有的单例 bean 实例化好，而是在调用 getBean 获取</span><br><span class="hljs-comment">* bean 时再实例化，也就是懒加载。</span><br><span class="hljs-comment">* getBean 方法有很多重载，比如 getBean(String name, Object... args)，我们在首次获取</span><br><span class="hljs-comment">* 某个 bean 时，可以传入用于初始化 bean 的参数数组（args），BeanFactory 会根据这些参数</span><br><span class="hljs-comment">* 去匹配合适的构造方法构造 bean 实例。当然，如果单例 bean 早已创建好，这里的 args 就没有</span><br><span class="hljs-comment">* 用了，BeanFactory 不会多次实例化单例 bean。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-literal">null</span> &amp;&amp; args == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<span class="hljs-comment">//日志</span><br>        <span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            logger.trace(<span class="hljs-string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 如果 sharedInstance 是普通的单例 bean，下面的方法会直接返回。但如果</span><br><span class="hljs-comment">* sharedInstance 是 FactoryBean 类型的，则需调用 getObject 工厂方法获取真正的</span><br><span class="hljs-comment">* bean 实例。如果用户想获取 FactoryBean 本身，这里也不会做特别的处理，直接返回</span><br><span class="hljs-comment">* 即可。毕竟 FactoryBean 的实现类本身也是一种 bean，只不过具有一点特殊的功能而已。</span><br><span class="hljs-comment">*/</span><br>    beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getSingleton-方法"><a href="#getSingleton-方法" class="headerlink" title="getSingleton()方法"></a><code>getSingleton()</code>方法</h4><p>Spring 对单例模式的 bean 只会创建一次。后续，如果再获取该 Bean ，则是直接从单例缓存中获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultSingletonBeanRegistry.java</span><br><span class="hljs-comment">//singletonObjects 就是Spring内部用来存放单例Bean的对象池,key为beanName，value为Bean</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);<br><br><span class="hljs-comment">//singletonFactories 单例工厂的缓存,key为beanName,value 为ObjectFactory</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><br><span class="hljs-comment">// earlySingletonObjects 是早期单例Bean的缓存池,此时Bean已经被创建(newInstance),但是还没有完成初始化</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><br><span class="hljs-comment">// singletonsCurrentlyInCreation 存放了当前正在创建的bean的BeanName</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation =<br>    Collections.newSetFromMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>));<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-keyword">return</span> getSingleton(beanName, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-type">boolean</span> allowEarlyReference)</span> &#123;<br>    <span class="hljs-comment">// Quick check for existing instance without full singleton lock</span><br>    <span class="hljs-comment">// 从单例缓冲中加载 bean，//先从一级缓存拿</span><br>    <span class="hljs-comment">//singletonObjects 就是Spring内部用来存放单例Bean的对象池,key为beanName，value为Bean</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>    <span class="hljs-comment">// 缓存中的 bean 为空，且当前 bean 正在创建，属性还没有DI（依赖注入）</span><br>    <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<br>        <span class="hljs-comment">//从二级缓存中拿</span><br>        <span class="hljs-comment">// earlySingletonObjects 是早期单例Bean的缓存池,此时Bean已经被创建(newInstance),但是还没有完成初始化</span><br>        singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);<br>        <span class="hljs-comment">//如果还拿不到，并且允许bean提前引用（解决循环依赖）</span><br>        <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; allowEarlyReference) &#123;<br>            <span class="hljs-comment">// 加锁</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>                <span class="hljs-comment">// Consistent creation of early reference within full singleton lock</span><br>                singletonObject = <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>                <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;<br>                    singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);<br>                    <span class="hljs-keyword">if</span> (sing也letonObject == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">//从三级缓存中拿到对象工厂</span><br>                        <span class="hljs-comment">//singletonFactories 单例工厂的缓存,key为beanName,value 为ObjectFactory</span><br>                        ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-built_in">this</span>.singletonFactories.get(beanName);<br>                        <span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-literal">null</span>) &#123;<br>                            <span class="hljs-comment">//从工厂中拿到对象</span><br>                            singletonObject = singletonFactory.getObject();<br>                            <span class="hljs-comment">//升级到二级缓存</span><br>                            <span class="hljs-built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br>                            <span class="hljs-comment">// 从 singletonFactories 中移除对应的 ObjectFactory</span><br>                            <span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singletonObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>从缓存中获取单例Bean的流程：</p><ul><li>第一步，从<code>singletonObjects</code>中获取Bean对象</li><li>第二步，如果获取不到且Bean正在创建中，从<code>earlySingletonObjects</code>获取Bean对象</li><li>第三步，如果获取不到且允许提前创建,从<code>singletonFactories</code>获取FactoryBean</li><li>第四步，如果不为null，则通过<code>FactoryBean.getObject()</code>获取Bean，然后将其加入到 <code>earlySingletonObjects</code> ，并且从 <code>singletonFactories</code> 删除，两者是互斥的，主要用来解决循环依赖的问题</li><li>总结就是：从这三个Map依次去取，取不到就取下一个Map</li></ul><h4 id="getObjectForBeanInstance-方法"><a href="#getObjectForBeanInstance-方法" class="headerlink" title="getObjectForBeanInstance()方法"></a><code>getObjectForBeanInstance()</code>方法</h4><p>执行完<code>getSingleton()</code>如果<code>sharedInstance != null</code>然后会执行该方法获取真正的实例Bean，执行该方法是因为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">如果 sharedInstance 是普通的单例 bean，该方法会直接返回。但如果sharedInstance 是 FactoryBean 类型的，则需调用 getObject 工厂方法获取真正的bean 实例。如果用户想获取 FactoryBean 本身，这里也不会做特别的处理，直接返回即可。毕竟 FactoryBean 的实现类本身也是一种 bean，只不过具有一点特殊的功能而已。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getObjectForBeanInstance</span><span class="hljs-params">(</span><br><span class="hljs-params">    Object beanInstance, String name, String beanName, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;<br>    <span class="hljs-comment">// 判断是否为工厂类引用（name 以 &amp; 开头）</span><br>    <span class="hljs-keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;<br>        <span class="hljs-comment">// 如果是 NullBean，则直接返回</span><br>        <span class="hljs-keyword">if</span> (beanInstance <span class="hljs-keyword">instanceof</span> NullBean) &#123;<br>            <span class="hljs-keyword">return</span> beanInstance;<br>        &#125;<br>        <span class="hljs-comment">// 如果 beanInstance 不是 FactoryBean 类型，则抛出异常</span><br>        <span class="hljs-keyword">if</span> (!(beanInstance <span class="hljs-keyword">instanceof</span> FactoryBean)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanIsNotAFactoryException</span>(beanName, beanInstance.getClass());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mbd != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//doGetBean中调用默认为null</span><br>            mbd.isFactoryBean = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> beanInstance;<br>    &#125;<br> <br>    <span class="hljs-keyword">if</span> (!(beanInstance <span class="hljs-keyword">instanceof</span> FactoryBean)) &#123;<br>        <span class="hljs-keyword">return</span> beanInstance;<br>    &#125;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (mbd != <span class="hljs-literal">null</span>) &#123;<br>        mbd.isFactoryBean = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 尝试从缓存中加载bean</span><br>        object = getCachedObjectForFactoryBean(beanName);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (object == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 若 object 依然为空，则可以确认，beanInstance 一定是 FactoryBean 。从而，使用 FactoryBean 获得 Bean 对象</span><br>        <span class="hljs-comment">// Return bean instance from factory.</span><br>        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance; <br>        <span class="hljs-comment">// containsBeanDefinition 检测 beanDefinitionMap 中也就是在所有已经加载的类中</span><br>        <span class="hljs-comment">// 检测是否定义 beanName</span><br>        <span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;<br>            <span class="hljs-comment">// 将存储 XML 配置文件的 GenericBeanDefinition 转换为 RootBeanDefinition，</span><br>            <span class="hljs-comment">// 如果指定 BeanName 是子 Bean 的话同时会合并父类的相关属性</span><br>            mbd = getMergedLocalBeanDefinition(beanName);<br>        &#125;<br>        <span class="hljs-comment">// 是否是用户定义的，而不是应用程序本身定义的</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">synthetic</span> <span class="hljs-operator">=</span> (mbd != <span class="hljs-literal">null</span> &amp;&amp; mbd.isSynthetic());<br>        <span class="hljs-comment">// 核心处理方法，使用 FactoryBean 获得 Bean 对象</span><br>        object = getObjectFromFactoryBean(factory, beanName, !synthetic);<br>    &#125;<br>    <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="getObjectFromFactoryBean-方法"><a href="#getObjectFromFactoryBean-方法" class="headerlink" title="getObjectFromFactoryBean()方法"></a><code>getObjectFromFactoryBean()</code>方法</h5><p>从上面可以看出， <code>getObjectForBeanInstance(Object beanInstance, String name, String beanName,RootBeanDefinition mbd)</code> 方法，分成两种情况：</p><ul><li>第一种，当该实例对象为<strong>非 FactoryBean 类型</strong>，<strong>直接</strong>返回给定的 Bean 实例对象 <code>beanInstance</code> 。</li><li>第二种，当该实例对象为<strong>FactoryBean 类型</strong>，从 FactoryBean ( <code>beanInstance</code> ) 中，获取 Bean 实例对象，即通过<code>getObjectFromFactoryBean()</code>来获取。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//缓存 FactoryBean 创建的单例 Bean 对象的映射</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; factoryBeanObjectCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getObjectFromFactoryBean</span><span class="hljs-params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="hljs-type">boolean</span> shouldPostProcess)</span> &#123;<br>    <span class="hljs-comment">// &lt;1&gt; 为单例模式且缓存中存在</span><br>    <span class="hljs-keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;<br>        <span class="hljs-keyword">synchronized</span> (getSingletonMutex()) &#123;<br>            <span class="hljs-comment">// &lt;1.2&gt; 从缓存中获取指定的 factoryBean</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.factoryBeanObjectCache.get(beanName);<br>            <span class="hljs-keyword">if</span> (object == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 为空，则从 FactoryBean 中获取对象</span><br>                object = doGetObjectFromFactoryBean(factory, beanName);<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">alreadyThere</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.factoryBeanObjectCache.get(beanName);<br>                <span class="hljs-keyword">if</span> (alreadyThere != <span class="hljs-literal">null</span>) &#123;<br>                    object = alreadyThere;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// &lt;1.3&gt; 需要后续处理</span><br>                    <span class="hljs-keyword">if</span> (shouldPostProcess) &#123;<br>                        <span class="hljs-comment">// 若该 Bean 处于创建中，则返回非处理对象，而不是存储它</span><br>                        <span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;<br>                            <span class="hljs-keyword">return</span> object;<br>                        &#125;<br>                        <span class="hljs-comment">// 单例 Bean 的前置处理</span><br>                        beforeSingletonCreation(beanName);<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">// 对从 FactoryBean 获取的对象进行后处理</span><br>                            <span class="hljs-comment">// 生成的对象将暴露给 bean 引用</span><br>                            object = postProcessObjectFromFactoryBean(object, beanName);<br>                        &#125;<br>                        <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(beanName,<br>                                                            <span class="hljs-string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);<br>                        &#125;<br>                        <span class="hljs-keyword">finally</span> &#123;<br>                            <span class="hljs-comment">// 单例 Bean 的后置处理</span><br>                            afterSingletonCreation(beanName);<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// &lt;1.4&gt; 添加到 factoryBeanObjectCache 中，进行缓存</span><br>                    <span class="hljs-keyword">if</span> (containsSingleton(beanName)) &#123;<br>                        <span class="hljs-built_in">this</span>.factoryBeanObjectCache.put(beanName, object);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> object;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 为空，则从 FactoryBean 中获取对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> doGetObjectFromFactoryBean(factory, beanName);<br>        <span class="hljs-comment">// 需要后续处理</span><br>        <span class="hljs-keyword">if</span> (shouldPostProcess) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 对从 FactoryBean 获取的对象进行后处理</span><br>                <span class="hljs-comment">// 生成的对象将暴露给 bean 引用</span><br>                object = postProcessObjectFromFactoryBean(object, beanName);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(beanName, <span class="hljs-string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要流程如下：</p><ul><li>若为单例且单例 Bean 缓存中存在 <code>beanName</code> ，进行后续处理，否则直接调用<code>doGetObjectFromFactoryBean()</code>从 FactoryBean 中获取 Bean 实例对象。</li><li>若为单例且单例 Bean 缓存中存在 <code>beanName</code> ，进行后续处理：第一步，获取锁。其实我们可以发现大量的同步锁，锁住的对象都是 <code>this.singletonObjects</code>，主要是因为在单例模式中必须要<strong>保证全局唯一</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DefaultSingletonBeanRegistry.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">getSingletonMutex</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.singletonObjects;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第二步，从 <code>factoryBeanObjectCache</code> 缓存中获取实例对象 <code>object</code> 。若 <code>object</code> 为空，则调用 <code>doGetObjectFromFactoryBean()</code> 方法，从 FactoryBean 获取 Bean 实例对象，底层是调用 <code>FactoryBean.getObject()</code> 方法，获取 Bean 对象。。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">doGetObjectFromFactoryBean</span><span class="hljs-params">(FactoryBean&lt;?&gt; factory, String beanName)</span> <span class="hljs-keyword">throws</span> BeanCreationException &#123;<br>    Object object;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 需要权限验证</span><br>        <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">AccessControlContext</span> <span class="hljs-variable">acc</span> <span class="hljs-operator">=</span> getAccessControlContext();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// &lt;x&gt; 从 FactoryBean 中，获得 Bean 对象</span><br>                object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (PrivilegedActionException pae) &#123;<br>                <span class="hljs-keyword">throw</span> pae.getException();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// &lt;x&gt; 从 FactoryBean 中，获得 Bean 对象</span><br>            object = factory.getObject();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName, ex.toString());<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(beanName, <span class="hljs-string">&quot;FactoryBean threw exception on object creation&quot;</span>, ex);<br>    &#125;<br><br>    <span class="hljs-comment">// Do not accept a null value for a FactoryBean that&#x27;s not fully</span><br>    <span class="hljs-comment">// initialized yet: Many FactoryBeans just return null then.</span><br>    <span class="hljs-keyword">if</span> (object == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(<br>                beanName, <span class="hljs-string">&quot;FactoryBean which is currently in creation returned null from getObject&quot;</span>);<br>        &#125;<br>        object = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullBean</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第三步，如果需要后续处理( <code>shouldPostProcess = true</code> )，则进行进一步处理，步骤如下：<ul><li>若该 Bean 处于创建中（<code>isSingletonCurrentlyInCreation(String beanName)</code> 方法返回 <code>true</code> ），则返回<strong>非处理的 Bean 对象</strong>，而不是存储它。</li><li>调用 <code>beforeSingletonCreation(String beanName)</code> 方法，进行创建之前的处理。默认实现将该 Bean 标志为当前创建的。</li><li>调用 <code>postProcessObjectFromFactoryBean(Object object, String beanName)</code> 方法，对从 FactoryBean 获取的 Bean 实例对象进行后置处理。</li><li>调用 <code>afterSingletonCreation(String beanName)</code> 方法，进行创建 Bean 之后的处理，默认实现是将该 bean 标记为不在创建中。</li></ul></li><li>第四步，加入到 <code>factoryBeanObjectCache</code> 缓存中。</li></ul><h5 id="isSingletonCurrentlyInCreation-方法"><a href="#isSingletonCurrentlyInCreation-方法" class="headerlink" title="isSingletonCurrentlyInCreation()方法"></a><code>isSingletonCurrentlyInCreation()</code>方法</h5><p>该方法是用于检测当前 Bean 是否处于创建之中。</p><ul><li><code>beforeSingletonCreation(String beanName)</code> 方法，用于添加标志，当前 bean <strong>正处于</strong>创建中</li><li><code>afterSingletonCreation(String beanName)</code> 方法，用于移除标记，当前 Bean <strong>不处于</strong>创建中。</li></ul><p>以上两个方法<strong>记录了 Bean 的加载状态，是检测当前 Bean 是否处于创建中的关键之处，对解决 Bean 循环依赖起着关键作用</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultSingletonBeanRegistry.java</span><br><span class="hljs-comment">// singletonsCurrentlyInCreation 存放了当前正在创建的bean的BeanName</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation =<br>    Collections.newSetFromMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>));<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingletonCurrentlyInCreation</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.singletonsCurrentlyInCreation.contains(beanName);<br>&#125;<br></code></pre></td></tr></table></figure><p>该集合的元素是通过<code>beforeSingletonCreation(String beanName)</code> 方法添加的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultSingletonBeanRegistry.java</span><br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeSingletonCreation</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="hljs-built_in">this</span>.singletonsCurrentlyInCreation.add(beanName)) &#123;<span class="hljs-comment">// 添加</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName);<span class="hljs-comment">// 如果添加失败，则抛出 BeanCurrentlyInCreationException 异常。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该集合的元素是通过<code>afterSingletonCreation(String beanName)</code> 方法移除的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultSingletonBeanRegistry.java</span><br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterSingletonCreation</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="hljs-built_in">this</span>.singletonsCurrentlyInCreation.remove(beanName)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Singleton &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; isn&#x27;t currently in creation&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="postProcessObjectFromFactoryBean-方法"><a href="#postProcessObjectFromFactoryBean-方法" class="headerlink" title="postProcessObjectFromFactoryBean()方法"></a><code>postProcessObjectFromFactoryBean()</code>方法</h5><p><code>postProcessObjectFromFactoryBean(Object object, String beanName)</code> 方法，对从 FactoryBean 处获取的 Bean 实例对象进行后置处理。其默认实现是直接返回 object 对象，不做任何处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultSingletonBeanRegistry.java</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*机翻注释：对从FactoryBean获得的给定对象进行后处理。结果对象将暴露给bean引用。</span><br><span class="hljs-comment">* 默认实现只是按原样返回给定的对象。子类可以覆盖它，例如，以应用后处理器。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">postProcessObjectFromFactoryBean</span><span class="hljs-params">(Object object, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法注释里提到了<strong>应用后处理器</strong><code>AbstractAutowireCapableBeanFactory.java</code>。</p><p>该类就覆盖了上边的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstractAutowireCapableBeanFactory.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">postProcessObjectFromFactoryBean</span><span class="hljs-params">(Object object, String beanName)</span> &#123;<br>    <span class="hljs-keyword">return</span> applyBeanPostProcessorsAfterInitialization(object, beanName);<br>&#125;<br></code></pre></td></tr></table></figure><p>尽可能保证所有 bean 初始化后都会调用注册的 <code>BeanPostProcessor.postProcessAfterInitialization(Object bean, String beanName)</code> 方法进行处理，在实际开发过程中大可以针对此特性设计自己的业务逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper集群</title>
    <link href="/2022/06/11/%E4%BC%AA%E9%9B%86%E7%BE%A4%E7%89%88Zookeeper%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/06/11/%E4%BC%AA%E9%9B%86%E7%BE%A4%E7%89%88Zookeeper%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">zookeeper集群</font></div><p>懒得配置更多虚拟机，直接一台机子开启多个zookeeper实现<code>伪集群</code>，和<code>redis</code>伪集群一样，修改个端口号即可，就可以一台服务器跑多个zookeeper。</p><h4 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h4><p>下载解压配置和单机的一样，只不过多了一些额外配置。</p><h5 id="新建一个文件夹，专门放多台zookeeper。"><a href="#新建一个文件夹，专门放多台zookeeper。" class="headerlink" title="新建一个文件夹，专门放多台zookeeper。"></a>新建一个文件夹，专门放多台zookeeper。</h5><p>喜欢的路径创建一个<code>zookeepercluster</code>目录，解压三份zookeeper的<code>-bin.tar.gz</code>包到该目录。</p><p><img src="/images/zookeeper/%E4%BC%AA%E9%9B%86%E7%BE%A4%E7%9B%AE%E5%BD%95.png" alt="伪集群目录"></p><h5 id="按个配置每个zookeeper"><a href="#按个配置每个zookeeper" class="headerlink" title="按个配置每个zookeeper"></a>按个配置每个zookeeper</h5><p>创建<code>data</code>目录，并在<code>data</code>目录下创建<code>myid</code>文件</p><p><img src="/images/zookeeper/%E4%BC%AA%E9%9B%86%E7%BE%A4%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE1.png" alt="伪集群修改配置1"></p><p>里边分别添加内容1、2、3。这个文件就是记录每个服务器的ID。</p><h5 id="按个修改配置文件。"><a href="#按个修改配置文件。" class="headerlink" title="按个修改配置文件。"></a>按个修改配置文件。</h5><p>主要修改两个：数据存放路径和端口号</p><p><strong>切记切记</strong>：<em><strong>路径别有中文</strong></em>，不然一直提示找不到<code>myid</code>文件（虽然确实data目录创建并配置了）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">the directory <span class="hljs-built_in">where</span> the snapshot is stored.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">do</span> not use /tmp <span class="hljs-keyword">for</span> storage, /tmp here is just</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">example sakes.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">切记切记不能有中文，大坑</span><br>dataDir=/home/muzili/文档/apps/zookeepercluster/zookeeper3/apache-zookeeper-3.6.2-bin/data<br><span class="hljs-meta prompt_"># </span><span class="language-bash">the port at <span class="hljs-built_in">which</span> the clients will connect</span><br>clientPort=2183<br></code></pre></td></tr></table></figure><h5 id="每个配置文件配置客户端访问端口（clientPort）和集群服务器IP列表。"><a href="#每个配置文件配置客户端访问端口（clientPort）和集群服务器IP列表。" class="headerlink" title="每个配置文件配置客户端访问端口（clientPort）和集群服务器IP列表。"></a>每个配置文件配置客户端访问端口（clientPort）和集群服务器IP列表。</h5><p>末尾都添加如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">server.1=192.168.13.128:2881:3881<br>server.2=192.168.13.128:2882:3882<br>server.3=192.168.13.128:2883:3883<br><span class="hljs-meta prompt_">#</span><span class="language-bash">server.服务器ID=服务器IP地址：服务器之间通信端口：服务器之间投票选举端口</span><br></code></pre></td></tr></table></figure><p>配置以上即可。启动验证</p><p>启动成功，状态会如下：</p><p><img src="/images/zookeeper/2181%E7%8A%B6%E6%80%81.png" alt="2181状态"></p><p><img src="/images/zookeeper/2182%E7%8A%B6%E6%80%81.png" alt="2182状态"></p><p><img src="/images/zookeeper/2383%E7%8A%B6%E6%80%81.png" alt="2383状态"></p><p>没问题的话，唯一的不美观就是，三个服务器，其第一或者第二个，由于其他的服务还没启动，日志里会报***拒绝连接，第三个服务没毛病。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h5 id="切记路径不能有中文，单机zookeeper可能没什么，集群的就有问题了。"><a href="#切记路径不能有中文，单机zookeeper可能没什么，集群的就有问题了。" class="headerlink" title="切记路径不能有中文，单机zookeeper可能没什么，集群的就有问题了。"></a>切记路径不能有中文，单机zookeeper可能没什么，集群的就有问题了。</h5><p>即便正确配置了路径，也配置了<code>myid</code>，里边<code>id</code>也唯一。但会一直提示：</p><p><img src="/images/zookeeper/myid-miss.png" alt="myid-miss"></p><h5 id="可以正常启动，但是查看状态时，提示如下："><a href="#可以正常启动，但是查看状态时，提示如下：" class="headerlink" title="可以正常启动，但是查看状态时，提示如下："></a>可以正常启动，但是查看状态时，提示如下：</h5><p><img src="/images/zookeeper/status%E6%8A%A5%E9%94%99.png" alt="status报错"></p><p>权限问题，启动后，查看之前创建的<code>data</code>目录，除了自己创建的<code>myid</code>，还会有一个<code>version-2</code>的目录，里边有三个文件，省事直接修改所有权限即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">此处图了方便自己，所以自己直接设置了777，看自己需要</span><br>chmod -R 777 version-2<br></code></pre></td></tr></table></figure><h5 id="8080端口已经被占用："><a href="#8080端口已经被占用：" class="headerlink" title="8080端口已经被占用："></a>8080端口已经被占用：</h5><p><img src="/images/zookeeper/AdminServer%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A88080%E7%AB%AF%E5%8F%A3.png" alt="AdminServer默认使用8080端口"></p><p>原因，zookeeper3.5之后，Zookeeper AdminServer，默认使用8080端口。</p><p>配置文件添加如下内容修改为其他未被使用的端口即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">admin.serverPort=8888<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis安装配置</title>
    <link href="/2022/06/11/redis%E5%AE%89%E8%A3%85/"/>
    <url>/2022/06/11/redis%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">redis安装配置</font></div><h4 id="redis应用场景"><a href="#redis应用场景" class="headerlink" title="redis应用场景"></a>redis应用场景</h4><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>合理的使用 缓存 能够明显加快访问的速度，同时降低数据源的压力。这也是 Redis 最常用的功能。Redis 提供了 键值过期时间（EXPIRE key seconds）设置，并且也提供了灵活控制 <strong>最大内存</strong> 和 内存溢出 后的 <strong>淘汰策略</strong>。</p><h5 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h5><p>Redis 提供了 <strong>列表（list）</strong>和 <strong>有序集合（zset）</strong>数据结构，合理的使用这些数据结构，可以很方便的构建各种排行榜系统。</p><h5 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h5><p>例如：点赞数加 1，浏览数 加 1。还有常用的 限流操作，限制每个用户每秒 访问系统的次数 等等。Redis 支持 <strong>计数功能（INCR key）</strong>，而且计数的 性能 也非常好，计数的同时也可以设置 超时时间，这样就可以 实现限流。</p><h5 id="社交网络"><a href="#社交网络" class="headerlink" title="社交网络"></a>社交网络</h5><p>赞&#x2F;踩，粉丝，共同好友&#x2F;喜好，推送，下拉刷新等是社交网站必备的功能。</p><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><p>Redis 提供的 发布订阅（PUB&#x2F;SUB）和 阻塞队列 的功能，虽然和专业的消息队列比，还 不够强大，但对于一般的消息队列功能基本满足。</p><h4 id="redis的安装"><a href="#redis的安装" class="headerlink" title="redis的安装"></a>redis的安装</h4><h5 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/<br>wget http://download.redis.io/releases/redis-4.0.11.tar.gz<br>tar -zxvf redis-4.0.2.tar.gz<br></code></pre></td></tr></table></figure><h5 id="编译并安装"><a href="#编译并安装" class="headerlink" title="编译并安装"></a>编译并安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/redis-4.0.11<br>make install PREFIX=/usr/local/redis<br></code></pre></td></tr></table></figure><p>安装完成时，&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin 目录下会生成的几个可执行的文件。</p><pre><code class="hljs">    | 可执行文件 | 作用 |    |-----------|-------|    | redis-server | 启动 redis 服务 |    | redis-cli redis | 命令行客户端 |    | redis-benchmark | redis 基准测试工具 |    | redis-check-aof | redis AOF 持久化文件检测和修复工具 |    | redis-check-dump | redis RDB 持久化文件检测和修复工具 |    | redis-sentinel | 启动 redis sentinel |</code></pre><p>复制 Redis 相关命令到 &#x2F;usr&#x2F;local&#x2F;bin 目录下，这样就可以直接执行这些命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/redis/bin/<br>sudo cp redis-cli redis-server redis-sentinel /usr/local/bin<br></code></pre></td></tr></table></figure><h5 id="修改Redis配置文件"><a href="#修改Redis配置文件" class="headerlink" title="修改Redis配置文件"></a>修改Redis配置文件</h5><p>安装完成之后将 Redis 配置文件拷贝到 &#x2F;usr&#x2F;local 下，redis.conf 是 Redis 的配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp /usr/local/redis-4.0.11/redis.conf /usr/local/<br></code></pre></td></tr></table></figure><p>redis 配置文件主要参数解析参考：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">redis进程是否以守护进程的方式运行，<span class="hljs-built_in">yes</span>为是，no为否(不以守护进程的方式运行会占用一个终端)。</span><br>daemonize no<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定redis进程的PID文件存放位置</span><br>pidfile /var/run/redis.pid<br><span class="hljs-meta prompt_"># </span><span class="language-bash">redis进程的端口号</span><br>port 6379<br><span class="hljs-meta prompt_"># </span><span class="language-bash">绑定的主机地址</span><br>bind 127.0.0.1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">客户端闲置多长时间后关闭连接，默认此参数为0即关闭此功能</span><br>timeout 300<br><span class="hljs-meta prompt_"># </span><span class="language-bash">redis日志级别，可用的级别有debug.verbose.notice.warning</span><br>loglevel verbose<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">log</span>文件输出位置，如果进程以守护进程的方式运行，此处又将输出文件设置为stdout的话，就会将日志信息输出到/dev/null里面去了</span><br>logfile stdout<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置数据库的数量，默认为0可以使用select &lt;dbid&gt;命令在连接上指定数据库<span class="hljs-built_in">id</span></span><br>databases 16<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定在多少时间内刷新次数达到多少的时候会将数据同步到数据文件</span><br>save &lt;seconds&gt; &lt;changes&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定存储至本地数据库时是否压缩文件，默认为<span class="hljs-built_in">yes</span>即启用存储</span><br>rdbcompression yes<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定本地数据库文件名</span><br>dbfilename dump.db<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定本地数据问就按存放位置</span><br>dir ./<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定当本机为slave服务时，设置master服务的IP地址及端口，在redis启动的时候他会自动跟master进行数据同步</span><br>slaveof &lt;masterip&gt; &lt;masterport&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">当master设置了密码保护时，slave服务连接master的密码</span><br>masterauth &lt;master-password&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置redis连接密码，如果配置了连接密码，客户端在连接redis是需要通过AUTH&lt;password&gt;命令提供密码，默认关闭</span><br>requirepass footbared<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置同一时间最大客户连接数，默认无限制。redis可以同时连接的客户端数为redis程序可以打开的最大文件描述符，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回 max number of clients reached 错误信息</span><br>maxclients 128<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key。当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span><br>maxmemory&lt;bytes&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no。</span><br>appendonly no<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定跟新日志文件名默认为appendonly.aof</span><br>appendfilename appendonly.aof<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定更新日志的条件，有三个可选参数 - no：表示等操作系统进行数据缓存同步到磁盘(快)，always：表示每次更新操作后手动调用fsync()将数据写到磁盘(慢，安全)， everysec：表示每秒同步一次(折衷，默认值)；</span><br>appendfsync everysec<br></code></pre></td></tr></table></figure><p>设置后台启动<br>由于 Redis 默认是 前台启动，不建议使用。修改 Redis 配置文件，把 daemonize no 改为 daemonize yes。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">daemonize yes<br></code></pre></td></tr></table></figure><p>设置远程访问<br>Redis 默认只允许 本机访问，把 bind 修改为 bind 0.0.0.0 此设置会变成 允许所有远程访问。如果想指定限制访问，可设置对应的 IP。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bind 0.0.0.0<br></code></pre></td></tr></table></figure><p>配置 Redis 日志记录<br>默认是：logfile “”，改为自定义日志文件路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">logfile /var/log/redis_6379.log<br></code></pre></td></tr></table></figure><p>设置 Redis 请求密码，修改后重启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">requirepass &quot;123456&quot;<br></code></pre></td></tr></table></figure><p>有了密码之后，进入客户端，就得这样访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -h 127.0.0.1 -p 6379 -a 123456<br></code></pre></td></tr></table></figure><h5 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h5><p>新建一个 redis 环境变量文件并写入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/profile.d/redis.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加如下内容</span><br>PATH=$PATH:/usr/local/redis/bin<br>export PATH<br></code></pre></td></tr></table></figure><p>使配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure><p>然后可以运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-server -v<br><span class="hljs-meta prompt_">#</span><span class="language-bash">输出可看到</span><br>Redis server v=4.0.11 sha=00000000:0 malloc=jemalloc-4.0.3 bits=64 build=243d9be1bcedcd4b<br></code></pre></td></tr></table></figure><h5 id="注册Redis为系统服务"><a href="#注册Redis为系统服务" class="headerlink" title="注册Redis为系统服务"></a>注册Redis为系统服务</h5><p>新建redis服务文件并编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">新建并编辑</span><br>vim /usr/lib/systemd/system/redis.service<br></code></pre></td></tr></table></figure><p>添加内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit]<br>Description=Redis persistent key-value database<br>After=network.target<br>[Service]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">注意自己redis-server和redis.conf的存放路径</span><br>ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis.conf --supervised systemd<br><span class="hljs-meta prompt_">#</span><span class="language-bash">下边会创建redis-shutdown</span><br>ExecStop=/usr/local/redis/libexec/redis-shutdown<br>Type=notify<br>User=muzili<br>Group=muzili<br>RuntimeDirectory=redis<br>RuntimeDirectoryMode=0755<br>LimitNOFILE=65536<br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p><em><strong>注</strong></em>：不添加<code>LimitNOFILE=65536</code>启动可能会提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">1894:M 17 Nov 14:16:46.645 # You requested maxclients of 10000 requiring at least 10032 max file descriptors.<br>1894:M 17 Nov 14:16:46.645 # Server can&#x27;t set maximum open files to 10032 because of OS error: Operation not permitted.<br>1894:M 17 Nov 14:16:46.645 # Current maximum open files is 4096. maxclients has been reduced to 4064 to compensate for low ulimit. If you need higher maxclients increase &#x27;ulimit -n&#x27;.<br></code></pre></td></tr></table></figure><p>重新加载systemctll配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload<br></code></pre></td></tr></table></figure><p>新建redis关闭文件并编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /usr/local/redis/libexec<br>touch /usr/local/redis/libexec/redis-shutdown<br>chmod 755 /usr/local/redis/libexec/redis-shutdown<br>vim /usr/local/redis/libexec/redis-shutdown<br></code></pre></td></tr></table></figure><p>添加内容，# 去掉[[:\blank:]]中的\</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Wrapper to close properly redis and sentinel</span></span><br>test x&quot;$REDIS_DEBUG&quot; != x &amp;&amp; set -x<br><span class="hljs-meta prompt_"># </span><span class="language-bash">确定好自己redic-cli的目录</span><br>REDIS_CLI=/usr/local/bin/redis-cli<br><span class="hljs-meta prompt_"># </span><span class="language-bash">redis.conf的名字</span><br>SERVICE_NAME=&quot;$1&quot;<br>if [ -z &quot;$SERVICE_NAME&quot; ]; then<br>   SERVICE_NAME=redis<br>fi<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Get the proper config file based on service name</span><br>CONFIG_FILE=&quot;/usr/local/$SERVICE_NAME.conf&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Use awk to retrieve host, port from config file</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">去掉[[:\blank:]]中的\</span><br><span class="language-bash">HOST=`awk <span class="hljs-string">&#x27;/^[[:\blank:]]*bind/ &#123; print $2 &#125;&#x27;</span> <span class="hljs-variable">$CONFIG_FILE</span> | <span class="hljs-built_in">tail</span> -n1`</span><br>PORT=`awk &#x27;/^[[:\blank:]]*port/ &#123; print $2 &#125;&#x27; $CONFIG_FILE | tail -n1`<br>PASS=`awk &#x27;/^[[:\blank:]]*requirepass/ &#123; print $2 &#125;&#x27; $CONFIG_FILE | tail -n1`<br>SOCK=`awk &#x27;/^[[:\blank:]]*unixsocket\s/ &#123; print $2 &#125;&#x27; $CONFIG_FILE | tail -n1`<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Just <span class="hljs-keyword">in</span> <span class="hljs-keyword">case</span>, use default host, port</span><br>HOST=$&#123;HOST:-0.0.0.0&#125;<br>if [ &quot;$SERVICE_NAME&quot; = redis ]; then<br>    PORT=$&#123;PORT:-6379&#125;<br>else<br>    PORT=$&#123;PORT:-26739&#125;<br>fi<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Setup additional parameters</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">e.g password-protected redis instances</span><br>[ -z &quot;$PASS&quot;  ] || ADDITIONAL_PARAMS=&quot;-a $PASS&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">shutdown the service properly</span><br>if [ -e &quot;$SOCK&quot; ] ; then<br>        $REDIS_CLI -s $SOCK $ADDITIONAL_PARAMS shutdown<br>else<br>        $REDIS_CLI -h $HOST -p $PORT $ADDITIONAL_PARAMS shutdown<br>fi<br></code></pre></td></tr></table></figure><h5 id="可以启动关闭服务查看新加脚本是否成功"><a href="#可以启动关闭服务查看新加脚本是否成功" class="headerlink" title="可以启动关闭服务查看新加脚本是否成功"></a>可以启动关闭服务查看新加脚本是否成功</h5><p>启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start redis  或者 service redis start<br></code></pre></td></tr></table></figure><p>关闭服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop redis  或者 service redis stop<br></code></pre></td></tr></table></figure><p>服务状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl status redis  或者 service redis status<br></code></pre></td></tr></table></figure><h5 id="启动问题"><a href="#启动问题" class="headerlink" title="启动问题"></a>启动问题</h5><p>a.提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.<br></code></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">执行如下命令</span><br>echo &quot;net.core.somaxconn = 1024&quot; &gt;&gt; /etc/sysctl.d/99-sysctl.conf<br><span class="hljs-meta prompt_">#</span><span class="language-bash">接着执行如下命令使其生效</span><br>sysctl -p<br></code></pre></td></tr></table></figure><p>b.提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.<br></code></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">执行如下命令</span><br>echo &quot;vm.overcommit_memory = 1&quot;  &gt;&gt; /etc/sysctl.d/99-sysctl.conf<br><span class="hljs-meta prompt_">#</span><span class="language-bash">接着执行如下命令使其生效</span><br>sysctl -p<br></code></pre></td></tr></table></figure><p>c.提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#x27;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&#x27; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.<br></code></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">在/etc/rc.d/rc.local 文件里添加</span><br>if test -f /sys/kernel/mm/transparent_hugepage/enabled; then<br>    echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled<br>fi<br><span class="hljs-meta prompt_">#</span><span class="language-bash">保存执行</span><br>chmod +x /etc/rc.d/rc.local<br></code></pre></td></tr></table></figure><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p><em><strong>注意：</strong></em>配从不配主</p><h5 id="先查看防火墙设置，假如防火墙开启，开放redis端口"><a href="#先查看防火墙设置，假如防火墙开启，开放redis端口" class="headerlink" title="先查看防火墙设置，假如防火墙开启，开放redis端口"></a>先查看防火墙设置，假如防火墙开启，开放redis端口</h5><p>查看开放的端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo firewall-cmd --list-ports<br></code></pre></td></tr></table></figure><p>开放自己想开放的端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo firewall-cmd --zone=public --add-port=6379/tcp --permanent<br></code></pre></td></tr></table></figure><h5 id="进入从服务器-的-redis-cli-模式"><a href="#进入从服务器-的-redis-cli-模式" class="headerlink" title="进入从服务器 的 redis-cli 模式"></a>进入从服务器 的 redis-cli 模式</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -p 6379<br></code></pre></td></tr></table></figure><p>从服务器配置主服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">slaveof 192.168.31.44 6379<br></code></pre></td></tr></table></figure><p>分别查看主、从服务器的配置情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">命令</span><br>info replication<br><span class="hljs-meta prompt_">#</span><span class="language-bash">主服务器返回信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Replication</span><br>role:master<br>connected_slaves:1<br>slave0:ip=192.168.31.134,port=6379,state=online,offset=1862,lag=0<br>master_replid:a45b5866dd55b1551ddbaa9d6741af1f2d4e6979<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:1862<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:1862<br><span class="hljs-meta prompt_">#</span><span class="language-bash">从服务器返回信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Replication</span><br>role:slave<br>master_host:192.168.31.44<br>master_port:6379<br>master_link_status:up###如果为down，1.查看防火墙状态，是否开放了端口。2.主服务器是否有密码，从服务器配置了主服务器的密码吗<br>master_last_io_seconds_ago:10<br>master_sync_in_progress:0<br>slave_repl_offset:966<br>slave_priority:100<br>slave_read_only:1<br>connected_slaves:0<br>master_replid:a45b5866dd55b1551ddbaa9d6741af1f2d4e6979<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:966<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:953<br>repl_backlog_histlen:14<br></code></pre></td></tr></table></figure><p>以上配置缺点：<br>假如从机挂了，就需要重新配置连接，主机挂了，从机待机，主机恢复自动连接<br>假如从机挂了不想再配置，那就直接配置redis.conf配置文件（配从不配主）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">找到slaveof &lt;masterip&gt; &lt;masterport&gt;去掉注释</span><br>slaveof 192.168.31.44 6379<br><span class="hljs-meta prompt_">#</span><span class="language-bash">主机配置了密码，从机配置主机设置的密码，找到masterauth &lt;master-password&gt;去掉注释</span><br>masterauth 123456<br></code></pre></td></tr></table></figure><p>配置完重启。<br>从机变为主机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">slaveof no one<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springcloud使用nacos配置中心未从nacos读取配置</title>
    <link href="/2022/06/11/springcloud%E4%BD%BF%E7%94%A8nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%9C%AA%E4%BB%8Enacos%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/06/11/springcloud%E4%BD%BF%E7%94%A8nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%9C%AA%E4%BB%8Enacos%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">springcloud使用nacos配置中心未从nacos读取配置</font></div><p>原因是最新版本<kbd>2021.0.1.0</kbd>移除了 <kbd>spring-cloud-starter-bootstrap</kbd>的支持，改用 <kbd>spring.config.import</kbd>。</p><p>自己学习谷粒商城按照如下方式解决。</p><h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">2021.0</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>    &lt;!-- 排除 bootstrap, 未来版本 spring-cloud-alibaba 应该在 spring boot &gt;= <span class="hljs-number">2.4</span><span class="hljs-number">.0</span> 时将该依赖设置为 optional --&gt;<br>    &lt;exclusions&gt;<br>        &lt;exclusion&gt;<br>            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;<br>        &lt;/exclusion&gt;<br>    &lt;/exclusions&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"># application.yml (不能是bootstrap.yml或者bootstrap.properties)<br>spring:<br>  cloud:<br>    nacos:<br>      config:<br>        group: DEFAULT_GROUP<br>        server-addr: localhost:<span class="hljs-number">8848</span><br>  config:<br>    <span class="hljs-keyword">import</span>:<br>      - optional:nacos:test.yml  # 监听 DEFAULT_GROUP:test.yml<br>      - optional:nacos:test01.yml?group=group_01 # 覆盖默认 group, 监听 group_01:test01.yml<br>      - optional:nacos:test02.yml?group=group_02&amp;refreshEnabled=<span class="hljs-literal">false</span> # 不开启动态刷新<br>      - nacos:test03.yml # 在拉取nacos配置异常时会快速失败, 会导致 spring 容器启动失败<br></code></pre></td></tr></table></figure><p>等价于 (springboot 2.4.0 以下版本)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"># bootstrap.yml<br>spring:<br>  cloud:<br>    nacos:<br>      config:<br>        name: test.yml<br>        file-extension: yml<br>        group: DEFAULT_GROUP<br>        server-addr: localhost:<span class="hljs-number">8848</span><br>        extension-configs:<br>          - dataId: test01.yml<br>            group: group_01<br>          - dataId: test02.yml<br>            group: group_02<br>            refresh: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><ol><li>spring boot &gt;&#x3D; 2.4.0 默认不会启动 bootstrap 容器，不要将上述配置写在 bootstrap.yml(properties) 里。</li><li>dataId 不可缺省，不要使用相同 dataId。</li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>sprincloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper常用命令</title>
    <link href="/2022/06/11/zookeeper%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/06/11/zookeeper%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">zookeeper常用命令</font></div><p>进入<code>bin</code>目录，执行如下启动命令客户端。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./zkCli.sh<br></code></pre></td></tr></table></figure><h4 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h4><p>ls 命令用于查看某个路径下目录列表。后边必须跟路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls /<br></code></pre></td></tr></table></figure><p>ls2（3.6版本已经不支持了，需要ls -s）命令用于查看某个路径下目录列表，它比 ls 命令列出更多的详细信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -s /<br></code></pre></td></tr></table></figure><p><img src="/images/zookeeper/ls.png" alt="ls"></p><p>ls path [watch]可以对节点进行监听，但是不推荐使用了，推荐<code>ls -w path</code>替代。</p><p><img src="/images/zookeeper/%E7%9B%91%E5%90%AC.png" alt="监听"></p><p><strong>注意</strong>：监听效果就一次，比如我接着<code>delete /test</code>，那会直接删除，不会再有下边<code>WATCHER::</code>之类的话了，还想监听，那就重新设置一次。</p><h4 id="get命令"><a href="#get命令" class="headerlink" title="get命令"></a>get命令</h4><p>get 命令用于获取节点数据和状态信息。</p><p>可选参数[watch]对节点进行事件监听。已经过期，可以使用get [-w] path代替，和ls一样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">get /<br>get -s /<br></code></pre></td></tr></table></figure><h4 id="stat命令"><a href="#stat命令" class="headerlink" title="stat命令"></a>stat命令</h4><p>stat 命令用于查看节点状态信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">stat /<br></code></pre></td></tr></table></figure><h4 id="create命令"><a href="#create命令" class="headerlink" title="create命令"></a>create命令</h4><p>create 命令用于创建节点并赋值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">create [-s] [-e] path data acl<br>[-s] [-e]：-s 和 -e 都是可选的，-s 代表顺序节点， -e 代表临时节点，注意其中 -s 和 -e 可以同时使用的，并且临时节点不能再创建子节点。<br>path：指定要创建节点的路径，比如 /runoob。<br>data：要在此节点存储的数据。<br>act：访问权限相关，默认是 world，相当于全世界都能访问。<br></code></pre></td></tr></table></figure><h4 id="set命令"><a href="#set命令" class="headerlink" title="set命令"></a>set命令</h4><p>set 命令用于修改节点存储的数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set path value [version]<br></code></pre></td></tr></table></figure><h4 id="delete命令"><a href="#delete命令" class="headerlink" title="delete命令"></a>delete命令</h4><p>delete 命令用于删除某节点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">delete path [version]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>あすか栏目</title>
    <link href="/2022/06/11/%E3%81%82%E3%81%99%E3%81%8B%E6%A0%8F%E7%9B%AE/"/>
    <url>/2022/06/11/%E3%81%82%E3%81%99%E3%81%8B%E6%A0%8F%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">飛鳥栏目</font></div><h4 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h4><blockquote><p>わしのお釣りは？</p><p>我的找零呢？（映像研1，鸟）</p></blockquote><p>汉字假名：</p><ul><li>お釣り：おつり</li></ul><p>知识点：</p><ul><li><strong>「お釣り」</strong>是<strong>「找的零钱」</strong>的意思。</li><li><strong>「お金」</strong>是<strong>「钱」</strong>的意思。–おかね</li></ul><hr><blockquote><p>分かりません。不知道</p><p>分かるか。没理解</p></blockquote><p>汉字假名：</p><ul><li>分：わ</li></ul><hr><blockquote><p>ホントですか？</p><p>真的吗？</p></blockquote><p>知识点：</p><ul><li>「本当に」和「本当」要区分。</li></ul><hr><blockquote><p>どうしよう。</p><p>怎么办。</p></blockquote><hr><blockquote><p>お誕生日おめでとう。</p><p>生日快乐。</p></blockquote><p>汉字假名：</p><ul><li>誕生日：たんじょうび</li></ul><p>知识点：</p><ul><li>加「お」是比较郑重的说法。</li><li>「おめでとう」是「恭喜」的意思。</li></ul><hr><blockquote><p>楽「たの」しい：时间上是持续的，快乐不是短暂的。</p><p>嬉「うれ」しい：时间上是瞬间的，某刻的快乐。</p></blockquote><hr><blockquote><p>もういいよ。</p><p>真是够了。（小鸟情人节被三杀）</p></blockquote><blockquote><p>何「なん」だオマエ。</p><p>你怎么回事啊？（莲加不会接设乐的梗）</p></blockquote><blockquote><p>どうしよう。</p><p>怎么办？</p></blockquote><blockquote><p>かにうまい？</p><p>螃蟹好吃？</p><p>かにゅうまえに。</p><p>加入之前。</p><p>工事中这两个容易搞混</p></blockquote><h4 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h4><table><thead><tr><th>单词</th><th>词义</th></tr></thead><tbody><tr><td>自信満々「じしんまんまん」</td><td>自信满满，充满信心。</td></tr><tr><td>自信「じしん」</td><td></td></tr><tr><td>せーの</td><td>一般用在口语，大意1、2…开始。但和1、2…没一点关系（可以想象中文里比如抬一个很重的东西，大家：1、2…起）。</td></tr><tr><td>五時間「ごじかん」</td><td>五小时。</td></tr><tr><td>五時「ごじ」</td><td>五点。</td></tr><tr><td>財布「さいふ」</td><td>钱包。</td></tr><tr><td>おかゆ</td><td>粥。</td></tr><tr><td>プレゼント</td><td>礼物（present）。</td></tr><tr><td>漢字「かんじ」</td><td></td></tr><tr><td>大丈夫「だいじょうぶ」</td><td>不用担心；不需要；没什么大事。</td></tr><tr><td>怪我「けが」</td><td>身体上受伤。</td></tr><tr><td>勉強「べんきょう」</td><td>学习。</td></tr><tr><td>手紙「てがみ」</td><td>信。</td></tr><tr><td>経理「けいり」</td><td>做会计工作的人。</td></tr><tr><td>たこ焼き「たこやき」</td><td>章鱼烧。</td></tr><tr><td>お菓子「おかし」</td><td>零食。</td></tr><tr><td>好き「すき」</td><td>喜欢。</td></tr><tr><td>大好き「だいすき」</td><td>超喜欢；最喜欢。</td></tr><tr><td>嫌い「きらい」・キライ</td><td>讨厌，不喜欢。</td></tr><tr><td>怖い「こわい」</td><td>害怕；可怕的。</td></tr><tr><td>チョコレート</td><td>巧克力（chocolate）。</td></tr><tr><td>プレゼント</td><td>礼物（present）。</td></tr><tr><td>お嬢「じょう」様「さま」・お嬢</td><td>大小姐。</td></tr><tr><td>遅「おそ」いよ</td><td>太慢了。</td></tr><tr><td>もっと早「はや」く</td><td>快一点。</td></tr><tr><td>嫁「よめ」</td><td>老婆。</td></tr><tr><td>暑「あつ」い</td><td>好烫。</td></tr><tr><td>たぶん</td><td>大概。</td></tr></tbody></table><h4 id="同类型"><a href="#同类型" class="headerlink" title="同类型"></a>同类型</h4><h5 id="三餐"><a href="#三餐" class="headerlink" title="三餐"></a>三餐</h5><table><thead><tr><th></th><th>早饭</th><th>午饭</th><th>晚饭</th></tr></thead><tbody><tr><td>ご飯（ごはん）</td><td>朝ご飯（あさごはん）</td><td>昼ご飯（ひるごはん）</td><td>晩ご飯（ばんごはん）</td></tr><tr><td>食（しょく）</td><td>朝食（ちょうしょく）</td><td>昼食（ちゅうしょく）</td><td>夕食（ゆうしょく）</td></tr><tr><td>飯（めし）</td><td>朝飯（あさめし）</td><td>昼飯（ひるめし）</td><td>晩飯（ばんめし）</td></tr></tbody></table><h5 id="星期（曜日）"><a href="#星期（曜日）" class="headerlink" title="星期（曜日）"></a>星期（曜日）</h5><p>〜曜日（ようび）</p><table><thead><tr><th align="center">星期日（日）</th><th align="center">星期一（月）</th><th align="center">星期二（火）</th><th align="center">星期三（水）</th><th align="center">星期四（木）</th><th align="center">星期五（金）</th><th align="center">星期六（土）</th></tr></thead><tbody><tr><td align="center">にちようび「日曜日」</td><td align="center">げつようび「月曜日」</td><td align="center">かようび「火曜日」</td><td align="center">すいようび「水曜日」</td><td align="center">もくようび「木曜日」</td><td align="center">きんようび「金曜日」</td><td align="center">どようび「土曜日」</td></tr></tbody></table><h5 id="方位（ほうこう）"><a href="#方位（ほうこう）" class="headerlink" title="方位（ほうこう）"></a>方位（ほうこう）</h5><table><thead><tr><th align="center"><strong>上</strong></th><th align="center"><strong>下</strong></th><th align="center"><strong>里</strong></th><th align="center"><strong>外</strong></th><th align="center"><strong>前</strong></th><th align="center"><strong>后</strong></th></tr></thead><tbody><tr><td align="center">うえ「上」</td><td align="center">した「下」</td><td align="center">なか「中」</td><td align="center">そと「外」</td><td align="center">まえ「前」</td><td align="center">うしろ「後ろ」</td></tr><tr><td align="center"><strong>左</strong></td><td align="center"><strong>右</strong></td><td align="center"><strong>旁边</strong></td><td align="center"><strong>旁边</strong></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">ひだり「左」</td><td align="center">みぎ「右」</td><td align="center">ちかく「近く」</td><td align="center">となり「隣」</td><td align="center"></td><td align="center"></td></tr></tbody></table><h5 id="四季（しき）"><a href="#四季（しき）" class="headerlink" title="四季（しき）"></a>四季（しき）</h5><p>日语对应的汉字和假名</p><table><thead><tr><th>春</th><th>夏</th><th>秋</th><th>冬</th></tr></thead><tbody><tr><td>はる</td><td>なつ</td><td>あき</td><td>ふゆ</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>课外</category>
      
      <category>综艺影视</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx常用命令</title>
    <link href="/2022/06/11/nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/06/11/nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">nginx常用命令</font></div><p>之前已经配置了环境变量（参考安装部分末尾配置），所以可以任意地方使用<code>nginx</code>命令，否则切入nginx安装目录下使用（默认&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;）。</p><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><h5 id="查看版本号"><a href="#查看版本号" class="headerlink" title="查看版本号"></a>查看版本号</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -v<br><span class="hljs-meta prompt_">#</span><span class="language-bash">返回结果</span><br>nginx version: nginx/1.12.2<br></code></pre></td></tr></table></figure><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">直接输入以下回车</span><br>nginx<br></code></pre></td></tr></table></figure><h5 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">直接输入以下回车</span><br>nginx -s stop<br></code></pre></td></tr></table></figure><h5 id="重新加载nginx，重新加载配置文件"><a href="#重新加载nginx，重新加载配置文件" class="headerlink" title="重新加载nginx，重新加载配置文件"></a>重新加载nginx，重新加载配置文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -s reload<br></code></pre></td></tr></table></figure><h4 id="未配置环境变量"><a href="#未配置环境变量" class="headerlink" title="未配置环境变量"></a>未配置环境变量</h4><h5 id="查看版本号-1"><a href="#查看版本号-1" class="headerlink" title="查看版本号"></a>查看版本号</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">未配置环境变量</span><br>./nginx -v<br><span class="hljs-meta prompt_">#</span><span class="language-bash">返回结果</span><br>nginx version: nginx/1.12.2<br></code></pre></td></tr></table></figure><h5 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./nginx<br></code></pre></td></tr></table></figure><h5 id="停止-1"><a href="#停止-1" class="headerlink" title="停止"></a>停止</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./nginx -s stop<br></code></pre></td></tr></table></figure><p>可能会提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx: [error] open() &quot;/usr/local/nginx/logs/nginx.pid&quot; failed (2: No such file or directory)<br></code></pre></td></tr></table></figure><p>需要使用nginx -c的参数指定nginx.conf文件的位置，执行如下命令解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf<br></code></pre></td></tr></table></figure><h5 id="重新加载nginx"><a href="#重新加载nginx" class="headerlink" title="重新加载nginx"></a>重新加载nginx</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./nginx -s reload<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十八、parentBeanFactory和依赖处理</title>
    <link href="/2022/06/11/parentBeanFactory%E5%92%8C%E4%BE%9D%E8%B5%96%E5%A4%84%E7%90%86/"/>
    <url>/2022/06/11/parentBeanFactory%E5%92%8C%E4%BE%9D%E8%B5%96%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">parentBeanFactory和依赖处理</font></div><p>如果从单例缓存中没有获取到单例 Bean 对象，则说明两种两种情况：</p><ol><li>该 Bean 的 scope 不是 singleton</li><li>该 Bean 的 scope 是 singleton ，但是没有初始化完成。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><span class="hljs-comment">//protected &lt;T&gt; T doGetBean(final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)</span><br><br><span class="hljs-comment">// ... 省略很多代码</span><br><br><span class="hljs-comment">// &lt;3&gt; 因为 Spring 只解决单例模式下得循环依赖，在原型模式下如果存在循环依赖则会抛出异常。</span><br><span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName);<br>&#125;<br><br><span class="hljs-comment">// &lt;4&gt; 如果容器中没有找到，则从父类容器中加载</span><br><span class="hljs-type">BeanFactory</span> <span class="hljs-variable">parentBeanFactory</span> <span class="hljs-operator">=</span> getParentBeanFactory();<br><span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">nameToLookup</span> <span class="hljs-operator">=</span> originalBeanName(name);<br>    <span class="hljs-keyword">if</span> (parentBeanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory) &#123;<br>        <span class="hljs-keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(<br>                nameToLookup, requiredType, args, typeCheckOnly);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Delegation to parent with explicit args.</span><br>        <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// No args -&gt; delegate to standard getBean method.</span><br>        <span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// &lt;5&gt; 如果不是仅仅做类型检查则是创建bean，这里需要记录</span><br><span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;<br>    markBeanAsCreated(beanName);<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// &lt;6&gt; 从容器中获取 beanName 相应的 GenericBeanDefinition 对象，并将其转换为 RootBeanDefinition 对象</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br>    <span class="hljs-comment">// 检查给定的合并的 BeanDefinition</span><br>    checkMergedBeanDefinition(mbd, beanName, args);<br><br>    <span class="hljs-comment">// Guarantee initialization of beans that the current bean depends on.</span><br>    <span class="hljs-comment">// &lt;7&gt; 处理所依赖的 bean</span><br>    String[] dependsOn = mbd.getDependsOn();<br>    <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;<br>            <span class="hljs-comment">// 若给定的依赖 bean 已经注册为依赖给定的 bean</span><br>            <span class="hljs-comment">// 循环依赖的情况</span><br>            <span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                        <span class="hljs-string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 缓存依赖调用</span><br>            registerDependentBean(dep, beanName);<br>            <span class="hljs-keyword">try</span> &#123;<br>                getBean(dep);<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                        <span class="hljs-string">&quot;&#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ... 省略很多代码</span><br></code></pre></td></tr></table></figure><p>该段主要处理了：</p><p>1、检测，若当前 Bean 在创建，则抛出 BeanCurrentlyInCreationException 异常。</p><p>2、如果 beanDefinitionMap 中不存在 beanName 的 BeanDefinition（即在 Spring bean 初始化过程中没有加载），则尝试从 parentBeanFactory 中加载。</p><p>3、判断是否为类型检查。</p><p>4、从 <code>mergedBeanDefinitions</code> 中获取 <code>beanName</code> 对应的 RootBeanDefinition 对象。如果这个 BeanDefinition 是子 Bean 的话，则会合并父类的相关属性。</p><p>5、依赖处理。</p><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p>Spring 只解决单例模式下的循环依赖，对于原型模式的循环依赖则是抛出 BeanCurrentlyInCreationException 异常，所以首先检查该 <code>beanName</code> 是否处于原型模式下的循环依赖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><span class="hljs-comment">//正在创建的原型Bean</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Object&gt; prototypesCurrentlyInCreation =<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadLocal</span>&lt;&gt;(<span class="hljs-string">&quot;Prototype beans currently in creation&quot;</span>);<br><br><span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName);<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrototypeCurrentlyInCreation</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">curVal</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.prototypesCurrentlyInCreation.get();<br>    <span class="hljs-keyword">return</span> (curVal != <span class="hljs-literal">null</span> &amp;&amp;<br>            (curVal.equals(beanName) || (curVal <span class="hljs-keyword">instanceof</span> Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="检查父类BeanFactory"><a href="#检查父类BeanFactory" class="headerlink" title="检查父类BeanFactory"></a>检查父类<code>BeanFactory</code></h4><p>若 <code>containsBeanDefinition(String beanName)</code> 方法中不存在 <code>beanName</code> 相对应的 BeanDefinition 对象时，则从 <code>parentBeanFactory</code> 中获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><br><span class="hljs-comment">// 获取 parentBeanFactory</span><br><span class="hljs-type">BeanFactory</span> <span class="hljs-variable">parentBeanFactory</span> <span class="hljs-operator">=</span> getParentBeanFactory();<br><span class="hljs-comment">// parentBeanFactory 不为空且 beanDefinitionMap 中不存该 name 的 BeanDefinition</span><br><span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;<br>    <span class="hljs-comment">// 确定原始 beanName</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">nameToLookup</span> <span class="hljs-operator">=</span> originalBeanName(name);<br>    <span class="hljs-comment">// 若为 AbstractBeanFactory 类型，委托父类处理</span><br>    <span class="hljs-keyword">if</span> (parentBeanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory) &#123;<br>        <span class="hljs-keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(<br>                nameToLookup, requiredType, args, typeCheckOnly);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 委托给构造���数 getBean() 处理</span><br>        <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 没有 args，委托给标准的 getBean() 处理</span><br>        <span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在获取实例Bean之前，先通过<code>originalBeanName()</code>方法对<code>name</code>进行了处理用来获取原始BeanName。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><span class="hljs-keyword">protected</span> String <span class="hljs-title function_">originalBeanName</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> transformedBeanName(name);<br>    <span class="hljs-keyword">if</span> (name.startsWith(FACTORY_BEAN_PREFIX)) &#123;<br>        beanName = FACTORY_BEAN_PREFIX + beanName;<br>    &#125;<br>    <span class="hljs-keyword">return</span> beanName;<br>&#125;<br></code></pre></td></tr></table></figure><p>优先调用了<code>transformedBeanName()</code>方法（<code>doGetBean()</code>方法第一步就是调用了该方法），然后再对返回的beanname进行处理，因为上一步将<code>&amp;</code>去掉了。</p><h4 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h4><p>方法参数 <code>typeCheckOnly</code> ，是用来判断调用 <code>getBean(...)</code> 方法时，表示是否为<strong>仅仅</strong>进行类型检查获取 Bean 对象。如果不是仅仅做类型检查，而是创建 Bean 对象，则需要调用 <code>markBeanAsCreated(String beanName)</code> 方法，进行记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstractBeanFactory.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">return</span> doGetBean(name, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">protected</span> &lt;T&gt; T <span class="hljs-title function_">doGetBean</span><span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="hljs-meta">@Nullable</span> Object[] args, <span class="hljs-type">boolean</span> typeCheckOnly)</span><br><span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-comment">/********省略**********/</span><br>    <span class="hljs-comment">//标记当前bean正在创建中，alreadyCreated中</span><br>    <span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;<br>        markBeanAsCreated(beanName);<br>    &#125;<br>    <span class="hljs-comment">/********省略**********/</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">markBeanAsCreated</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-comment">// 没有创建</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.alreadyCreated.contains(beanName)) &#123;<br>        <span class="hljs-comment">// 加上全局锁</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.mergedBeanDefinitions) &#123;<br>            <span class="hljs-comment">// 再次检查一次：DCL 双检查模式</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.alreadyCreated.contains(beanName)) &#123;<br>                <span class="hljs-comment">// Let the bean definition get re-merged now that we&#x27;re actually creating</span><br>                <span class="hljs-comment">// the bean... just in case some of its metadata changed in the meantime.</span><br>                <span class="hljs-comment">// 从 mergedBeanDefinitions 中删除 beanName，并在下次访问时重新创建它。</span><br>                clearMergedBeanDefinition(beanName);<br>                <span class="hljs-comment">// 添加到已创建 bean 集合中</span><br>                <span class="hljs-built_in">this</span>.alreadyCreated.add(beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearMergedBeanDefinition</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mergedBeanDefinitions.get(beanName);<br>    <span class="hljs-keyword">if</span> (bd != <span class="hljs-literal">null</span>) &#123;<br>        bd.stale = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取RootBeanDefinition"><a href="#获取RootBeanDefinition" class="headerlink" title="获取RootBeanDefinition"></a>获取<code>RootBeanDefinition</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从容器中获取 beanName 相应的 GenericBeanDefinition 对象，并将其转换为 RootBeanDefinition 对象</span><br><span class="hljs-comment">// 因为从 XML 配置文件中读取到的 Bean 信息是存储在GenericBeanDefinition 中的。但是，所有的 Bean 后续处理都是针对于 RootBeanDefinition 的，所以这里需要进行一个转换。</span><br><span class="hljs-comment">// 转换的同时，如果父类 bean 不为空的话，则会一并合并父类的属性。</span><br><span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br><span class="hljs-comment">//检查是否为抽象类</span><br>checkMergedBeanDefinition(mbd, beanName, args);<br></code></pre></td></tr></table></figure><p>调用 <code>getMergedLocalBeanDefinition(String beanName)</code> 方法，获取相对应的 BeanDefinition 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> RootBeanDefinition <span class="hljs-title function_">getMergedLocalBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-comment">// Quick check on the concurrent map first, with minimal locking.</span><br>    <span class="hljs-comment">// 快速从缓存中获取，如果不为空，则直接返回</span><br>    <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbd</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mergedBeanDefinitions.get(beanName);<br>    <span class="hljs-keyword">if</span> (mbd != <span class="hljs-literal">null</span> &amp;&amp; !mbd.stale) &#123;<br>        <span class="hljs-keyword">return</span> mbd;<br>    &#125;<br>    <span class="hljs-comment">// 获取 RootBeanDefinition，</span><br>    <span class="hljs-comment">// 如果返回的 BeanDefinition 是子类 bean 的话，则合并父类相关属性</span><br>    <span class="hljs-keyword">return</span> getMergedBeanDefinition(beanName, getBeanDefinition(beanName));<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 <code>checkMergedBeanDefinition()</code> 方法，检查给定的合并的 BeanDefinition 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkMergedBeanDefinition</span><span class="hljs-params">(RootBeanDefinition mbd, String beanName, <span class="hljs-meta">@Nullable</span> Object[] args)</span><br>    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br><br>    <span class="hljs-keyword">if</span> (mbd.isAbstract()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanIsAbstractException</span>(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="处理依赖"><a href="#处理依赖" class="headerlink" title="处理依赖"></a>处理依赖</h4><p>如果一个 Bean 有依赖 Bean 的话，那么在初始化该 Bean 时是需要先初始化它所依赖的 Bean 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><br><span class="hljs-comment">// 处理所依赖的 bean</span><br>String[] dependsOn = mbd.getDependsOn();<br><span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;<br>        <span class="hljs-comment">// &lt;1&gt; 若给定的依赖 bean 已经注册为依赖给定的 bean</span><br>        <span class="hljs-comment">// 即循环依赖的情况，抛出 BeanCreationException 异常</span><br>        <span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                    <span class="hljs-string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// &lt;2&gt; 缓存依赖调用</span><br>        registerDependentBean(dep, beanName);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// &lt;3&gt; 递归处理依赖 Bean</span><br>            getBean(dep);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                    <span class="hljs-string">&quot;&#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过迭代的方式依次对依赖 bean 进行检测、校验。如果通过，则调用 <code>getBean(String beanName)</code> 方法，实例化<strong>依赖</strong>的 Bean 对象。</p><h5 id="getDependsOn"><a href="#getDependsOn" class="headerlink" title="getDependsOn()"></a><code>getDependsOn()</code></h5><p>获取所有依赖，<code>RootBeanDefinition</code>继承自<code>AbstractBeanDefinition</code>所以委托给了父类处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstractBeanDefinition.java</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> String[] dependsOn;<br><br><span class="hljs-keyword">public</span> String[] getDependsOn() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dependsOn;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="isDependent"><a href="#isDependent" class="headerlink" title="isDependent()"></a><code>isDependent()</code></h5><p>校验该依赖是否已经注册给当前 Bean 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultSingletonBeanRegistry.java</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDependent</span><span class="hljs-params">(String beanName, String dependentBeanName)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.dependentBeanMap) &#123;<br>        <span class="hljs-keyword">return</span> isDependent(beanName, dependentBeanName, <span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDependent</span><span class="hljs-params">(String beanName, String dependentBeanName, <span class="hljs-meta">@Nullable</span> Set&lt;String&gt; alreadySeen)</span> &#123;<br>    <span class="hljs-comment">// alreadySeen 已经检测的依赖 bean</span><br>    <span class="hljs-keyword">if</span> (alreadySeen != <span class="hljs-literal">null</span> &amp;&amp; alreadySeen.contains(beanName)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取原始 beanName</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">canonicalName</span> <span class="hljs-operator">=</span> canonicalName(beanName);<br>    <span class="hljs-comment">// 获取当前 beanName 的依赖集合</span><br>    Set&lt;String&gt; dependentBeans = <span class="hljs-built_in">this</span>.dependentBeanMap.get(canonicalName);<br>    <span class="hljs-keyword">if</span> (dependentBeans == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 存在，则证明存在已经注册的依赖</span><br>    <span class="hljs-keyword">if</span> (dependentBeans.contains(dependentBeanName)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 递归检测依赖</span><br>    <span class="hljs-keyword">for</span> (String transitiveDependency : dependentBeans) &#123;<br>        <span class="hljs-keyword">if</span> (alreadySeen == <span class="hljs-literal">null</span>) &#123;<br>            alreadySeen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        &#125;<br>        alreadySeen.add(beanName);<br>        <span class="hljs-comment">//递归</span><br>        <span class="hljs-keyword">if</span> (isDependent(transitiveDependency, dependentBeanName, alreadySeen)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="registerDependentBean-dep-beanName-方法"><a href="#registerDependentBean-dep-beanName-方法" class="headerlink" title="registerDependentBean(dep, beanName)方法;"></a><code>registerDependentBean(dep, beanName)方法;</code></h5><p>注册依赖记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerDependentBean</span><span class="hljs-params">(String beanName, String dependentBeanName)</span> &#123;<br>    <span class="hljs-comment">// 获取 beanName</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">canonicalName</span> <span class="hljs-operator">=</span> canonicalName(beanName);<br><br>    <span class="hljs-comment">// 添加 &lt;canonicalName, &lt;dependentBeanName&gt;&gt; 到 dependentBeanMap 中</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.dependentBeanMap) &#123;<br>        Set&lt;String&gt; dependentBeans =<br>            <span class="hljs-built_in">this</span>.dependentBeanMap.computeIfAbsent(canonicalName, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(<span class="hljs-number">8</span>));<br>        <span class="hljs-keyword">if</span> (!dependentBeans.add(dependentBeanName)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加 &lt;dependentBeanName, &lt;canonicalName&gt;&gt; 到 dependenciesForBeanMap 中</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.dependenciesForBeanMap) &#123;<br>        Set&lt;String&gt; dependenciesForBean =<br>            <span class="hljs-built_in">this</span>.dependenciesForBeanMap.computeIfAbsent(dependentBeanName, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(<span class="hljs-number">8</span>));<br>        dependenciesForBean.add(canonicalName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getBean-方法"><a href="#getBean-方法" class="headerlink" title="getBean()方法"></a><code>getBean()</code>方法</h4><p>最后调用 <code>getBean(String beanName)</code> 方法，实例化依赖 Bean 对象。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx负载均衡</title>
    <link href="/2022/06/11/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <url>/2022/06/11/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">nginx负载均衡</font></div><p>重点配置</p><h4 id="http根节点添加upstream节点"><a href="#http根节点添加upstream节点" class="headerlink" title="http根节点添加upstream节点"></a><code>http</code>根节点添加<code>upstream</code>节点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream myserver(自己命名)&#123;<br>    server IP:端口；<br>server IP:端口；<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="修改http根节点下server节点参数"><a href="#修改http根节点下server节点参数" class="headerlink" title="修改http根节点下server节点参数"></a>修改<code>http</code>根节点下<code>server</code>节点参数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">服务器IP和端口号</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">端口号默认</span><br>server_name serverIP；<br><span class="hljs-meta prompt_">#</span><span class="language-bash">映射http根节点配置的upstream节点</span><br>location / &#123;<br>    proxy_pass http://myserver;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="nginx分配服务器策略"><a href="#nginx分配服务器策略" class="headerlink" title="nginx分配服务器策略"></a>nginx分配服务器策略</h4><h5 id="轮询（默认的）"><a href="#轮询（默认的）" class="headerlink" title="轮询（默认的）"></a>轮询（默认的）</h5><p>每个请求按照时间顺序逐一分配到不同的服务器，如果服务器down掉，自动剔除。</p><h5 id="weight（权重）"><a href="#weight（权重）" class="headerlink" title="weight（权重）"></a>weight（权重）</h5><p>weight代表权重，默认为1，权重越高被分配的客户端越多</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream myserver(自己命名)&#123;<br>    server IP:端口 weight=num；<br>server IP:端口 weight=num；<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h5><p>每个请求按访问ip的hash结果分配，这样每个客户端固定访问一个服务器，可以解决session问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream myserver(自己命名)&#123;<br>    ip_hash;<br>    server IP:端口；<br>server IP:端口；<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="fair（第三方）"><a href="#fair（第三方）" class="headerlink" title="fair（第三方）"></a>fair（第三方）</h5><p>按服务器的响应时间来分配请求，响应时间短优先分配。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream myserver(自己命名)&#123;<br>    fair;<br>    server IP:端口；<br>server IP:端口；<br>...<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis Sentinel哨兵模式</title>
    <link href="/2022/06/11/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/06/11/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">Redis Sentinel哨兵模式</font></div><p>Redis 的 Sentinel 最小配置是 一主一从。</p><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ol><li>监控<br>Sentinel会不断的检查主服务器和从服务器是否正常运行。</li><li>通知<br>当被监控的某个Redis 服务器出现问题，Sentinel通过API脚本向管理员或者其他的应用程序发送通知。</li><li>自动故障转移<br>当主节点不能正常工作时，Sentinel会开始一次自动的故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并将其他从节点指向新的主节点。</li></ol><h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><p>默认情况下，每个Sentinel节点会以每秒一次的频率对Redis节点和其它的Sentinel节点发送PING命令，并通过节点的回复来判断该节点是否在线。</p><ol><li>主观下线<br><strong>每个 sentinel 节点对 redis 节点失败的“偏见”</strong>。<br>如果在<code>down-after-milliseconds</code>毫秒内，Sentinel没有收到目标节点的有效回复，则会判定该节点下线。</li><li>客观下线<br><strong>所有sentinel节点对master Redis节点失败“达成共识”</strong>。<br>Sentinel节点会通过<code>sentinel is-master-down-by-addr</code>命令，向其它Sentinel节点询问对该主节点的状态判断。如果超过<code>&lt;quorum&gt;</code>个数的节点判定该主节点不可达，则该Sentinel节点会判断该主节点下线。</li></ol><h4 id="哨兵模式设置"><a href="#哨兵模式设置" class="headerlink" title="哨兵模式设置"></a>哨兵模式设置</h4><p>一个稳健的 Redis Sentinel 集群，应该使用至少 三个 Sentinel 实例，并且保证讲这些实例放到 不同的机器 上，甚至不同的 物理区域。（没那么多服务器，只能自己本地跑了几台虚拟机，每台虚拟机一个redis数据节点，一个哨兵节点）<br>测试5个虚拟机<br>哨兵模式主要配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">port 26379<br><span class="hljs-meta prompt_">#</span><span class="language-bash">sentinel日志文件</span><br>logfile &quot;&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置成后台运行</span><br>daemonize yes<br><span class="hljs-meta prompt_"># </span><span class="language-bash">工作目录</span><br>dir /tmp<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里定义主库的IP和端口，还有最后的5表示要达到5台sentinel认同才认为主库已经挂掉（即客观失效），quorum 要配置成 sentinel 节点数的一半 + 1；</span><br>sentinel monitor mymaster 127.0.0.1 6379 5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">主库在30000毫秒（即30秒）内没有反应就认为主库挂掉（即主观失效）</span><br>sentinel down-after-milliseconds mymaster 30000<br><span class="hljs-meta prompt_"># </span><span class="language-bash">若新主库当选后，允许最大可以同时从新主库同步数据的从库数</span> <br>sentinel parallel-syncs mymaster 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">若在指定时间（即180000毫秒，即180秒）内没有实现故障转移，则会自动再发起一次</span><br>sentinel failover-timeout mymaster 180000<br>sentinel deny-scripts-reconfig yes<br></code></pre></td></tr></table></figure><p>主从复制依旧不变<br>哨兵模式配置结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">sentinel配置文件里的port</span><br>redis-cli -p 26379<br><span class="hljs-meta prompt_">#</span><span class="language-bash">然后使用如下命令查看</span><br>info sentinel<br></code></pre></td></tr></table></figure><p>成功结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Sentinel</span><br>sentinel_masters:1<br>sentinel_tilt:0<br>sentinel_running_scripts:0<br>sentinel_scripts_queue_length:0<br>sentinel_simulate_failure_flags:0<br>master0:name=mymaster,status=ok,address=192.168.31.44:6379,slaves=4,sentinels=5<br></code></pre></td></tr></table></figure><p>设置主服务器要在前边</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sentinel monitor mymaster 127.0.0.1 6379 5 #master相当于一个变量<br><span class="hljs-meta prompt_"># </span><span class="language-bash">主库在30000毫秒（即30秒）内没有反应就认为主库挂掉（即主观失效）</span><br>sentinel down-after-milliseconds mymaster 30000<br>...<br></code></pre></td></tr></table></figure><p>不然启动会报：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">No such master with specified name.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat源码运行</title>
    <link href="/2022/06/11/idea%E5%AF%BC%E5%85%A5tomcat%E6%BA%90%E7%A0%81%E5%B9%B6%E5%90%AF%E5%8A%A8/"/>
    <url>/2022/06/11/idea%E5%AF%BC%E5%85%A5tomcat%E6%BA%90%E7%A0%81%E5%B9%B6%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">Idea导入Tomcat源码并运行</font></div><ul><li><h4 id="下载Tomcat源码并解压"><a href="#下载Tomcat源码并解压" class="headerlink" title="下载Tomcat源码并解压"></a>下载Tomcat源码并解压</h4><p>下载地址：<a href="http://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.59/src/apache-tomcat-8.5.59-src.zip">http://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.59/src/apache-tomcat-8.5.59-src.zip</a></p><p>浏览器打开，或者终端直接执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget http://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.59/src/apache-tomcat-8.5.59-src.zip<br></code></pre></td></tr></table></figure><p>解压到想要存放的目录：</p><p>&#x2F;home&#x2F;jievhaha&#x2F;Documents&#x2F;workspace&#x2F;ideaworkspace&#x2F;apacheTomcat</p><p>解压得到：</p><p><img src="/images/tomcat/tomcat%E8%A7%A3%E5%8E%8B.png" alt="tomcat解压内容"></p></li><li><h4 id="Idea导入源码并配置"><a href="#Idea导入源码并配置" class="headerlink" title="Idea导入源码并配置"></a>Idea导入源码并配置</h4><ol><li><p><font style="color:rgb(69, 182, 247)">在源码根目录创建pom.xml（如上边截图）并添加如下内容：</font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-comment">&lt;!--suppress ALL --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Tomcat8.5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Tomcat8.5 src<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>Tomcat8.5<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sourceDirectory</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">sourceDirectory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ant<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ant<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ant<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ant-apache-log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ant<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ant-commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>wsdl4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>wsdl4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml.rpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.xml.rpc-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.eclipse.jdt.core.compiler<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ecj<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span> <br></code></pre></td></tr></table></figure></li><li><p><font style="color:rgb(69, 182, 247)">Idea导入项目并配置参数：</font></p><ul><li>导入项目后Run –&gt; Edit Configurations</li></ul><p><img src="/images/tomcat/EditConfig.png" alt="EditConfig"></p><ul><li><p>点击”+“，添加Application</p><p><img src="/images/tomcat/EditConfigParam.png" alt="EditConfigParam"></p><p>Name随意，然后配置Configuration –&gt; Main class，添加如下内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">org.apache.catalina.startup.Bootstrap<br></code></pre></td></tr></table></figure><p>配置VM options，添加如下内容（路径自己看着改，没有的文件夹可以自己创建，不影响）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">  -Dcatalina.home=/home/jievhaha/Documents/workspace/ideaworkspace/apacheTomcat<br>-Dcatalina.base=/home/jievhaha/Documents/workspace/ideaworkspace/apacheTomcat<br>  -Djava.endorsed.dirs=/home/jievhaha/Documents/workspace/ideaworkspace/apacheTomcat/endorsed<br>-Djava.io.tmpdir=/home/jievhaha/Documents/workspace/ideaworkspace/apacheTomcattemp<br>  -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager<br>-Djava.util.logging.config.file=/home/jievhaha/Documents/workspace/ideaworkspace/apacheTomcat/conf/logging.properties<br>  -Djava.protocol.handler.pkgs=org.apache.catalina.webresources<br>-Djdk.tls.ephemeralDHKeySize=2048<br></code></pre></td></tr></table></figure></li></ul></li><li><p><font style="color:rgb(69, 182, 247)">打开mvn compile编译项目：</font></p><p><img src="/images/tomcat/mvn%E7%BC%96%E8%AF%91.png" alt="mvn编译"></p></li><li><p><font style="color:rgb(69, 182, 247)">启动项目，访问localhost:8080</font></p><p><img src="/images/tomcat/startWeb.png" alt="startWeb"></p><p><img src="/images/tomcat/startsuccess.png" alt="startsuccess"></p></li></ol></li><li><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ol><li><p><font style="color:rgb(69, 182, 247)">启动Tomcat，Idea控制台乱码问题</font></p><p>具体原因记得是某个配置文件idea打开就是乱码，之后需要重新查看</p><p>修改tomcat源代码，在代码中获取到了值之后手动重新编码解码，添加如下内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value.getBytes(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>    e.printStackTrace();<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第一处</strong>：<kbd>org.apache.tomcat.util.res.StringManager</kbd>类中的<kbd>getString(final String key, final Object... args)</kbd>方法。</p><p><img src="/images/tomcat/StringManagerGetString.png" alt="StringManagerGetString"></p><p><strong>第二处</strong>：<kbd>org.apache.jasper.compiler.Localizer</kbd>类的<kbd>getMessage(String errCode)</kbd>方法。</p><p><img src="/images/tomcat/LocalizerGetMessage.png" alt="LocalizerGetMessage"></p></li><li><p><font style="color:rgb(69, 182, 247)">启动失败，打开localhost:8080报错，提示：无法为JSP编译类</font></p><p>解决办法：<kbd>org.apache.catalina.startup.ContextConfig.java</kbd>文件中<kbd>protected synchronized void configureStart() {}</kbd>中<kbd>webConfig();</kbd>下添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">context.addServletContainerInitializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JasperInitializer</span>(), <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p><img src="/images/tomcat/ContextConfig.png" alt="ContextConfig"></p></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>tomcat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interrupt、interrupted和isInterrupted的区别</title>
    <link href="/2022/06/11/intrrup%E3%80%81interrupted%E3%80%81isInterrupted/"/>
    <url>/2022/06/11/intrrup%E3%80%81interrupted%E3%80%81isInterrupted/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">interrupt()、interrupted()和isInterrupted()的直观区别</font></div><ol><li><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a><font style="color:rgb(69, 182, 247)">interrupt()</font></h4></li></ol><p>形式上中断一个线程，不会去真正意义上的打断一个正在运行的线程，而是<em><strong>修改当前线程的中断状态码</strong></em>。同时，对于处于sleep()、wait()和join()阻塞下的线程，该方法会使当前线程抛出一个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">( String[] args )</span><br>    &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 依旧在运行&quot;</span>);<br>            &#125;<br><br>        &#125;);<br>        thread.start();<br>        thread.interrupt();jieguo<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/images/JUC/jichu/interrupt.png" alt="interrupt测试结果"></p><ol start="2"><li><h4 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted()"></a><font style="color:rgb(69, 182, 247)">isInterrupted()</font></h4></li></ol><p>该方法会返回线程的中断标志位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">( String[] args )</span><br>    &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            &#125;<br><br>        &#125;);<br>        thread.start();<br>        System.out.println(<span class="hljs-string">&quot;中断前：&quot;</span> + thread.isInterrupted());<br>        thread.interrupt();<br>        System.out.println(<span class="hljs-string">&quot;中断后：&quot;</span> + thread.isInterrupted());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：调用某一个线程对象的<code>isInterrupted()</code>方法会返回该线程的中断状态码。调用<code>interrupt()</code>方法以后，会改变这个线程的中断状态码。</p><p><img src="/images/JUC/jichu/isInterrupted.png" alt="isInterrupted测试结果"></p><ol start="3"><li><h4 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a><font style="color:rgb(69, 182, 247)">interrupted()</font></h4></li></ol><p>该方法会返回<strong>当前</strong>线程的中断标志位，<em><strong>同时会重置中断标志位</strong></em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">( String[] args )</span><br>    &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">if</span>(Thread.interrupted())&#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程中断标志位为true&quot;</span>);<br>                &#125;<br>            &#125;<br><br>        &#125;);<br>        thread.start();<br>        System.out.println(<span class="hljs-string">&quot;中断前：&quot;</span> + thread.isInterrupted());<br>        thread.interrupt();<br>        System.out.println(<span class="hljs-string">&quot;中断后：&quot;</span> + thread.isInterrupted());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/images/JUC/jichu/interrupted.png" alt="interrupt测试结果"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>elasticsearch安装</title>
    <link href="/2022/06/11/elasticsearch%E5%AE%89%E8%A3%85/"/>
    <url>/2022/06/11/elasticsearch%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">elasticsearch安装</font></div><p>elasticsearch、kibana、分词器安装，同时设置elasticsearch、kibana账号密码。</p><h3 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h3><p>防止开启防火墙，安装完成后未设置端口导致访问异常，所以优先放开对应端口。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">firewall-cmd <span class="hljs-attribute">--zone</span>=public <span class="hljs-attribute">--add-port</span>=9200/tcp --permanent<br>firewall-cmd <span class="hljs-attribute">--zone</span>=public <span class="hljs-attribute">--add-port</span>=9300/tcp --permanent<br>firewall-cmd <span class="hljs-attribute">--zone</span>=public <span class="hljs-attribute">--add-port</span>=5601/tcp --permanent<br>firewall-cmd --list-ports<br><span class="hljs-comment"># 重新加载</span><br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><h3 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h3><h4 id="获取elasticsearch相关配置"><a href="#获取elasticsearch相关配置" class="headerlink" title="获取elasticsearch相关配置"></a>获取elasticsearch相关配置</h4><p>直接安装，未映射目录。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d --name elasticsearch -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> -p <span class="hljs-number">9300</span>:<span class="hljs-number">9300</span> -e ES_JAVA_OPTS=<span class="hljs-string">&quot;-Xms256m -Xmx256m&quot;</span> elasticsearch:<span class="hljs-number">7</span>.<span class="hljs-number">16</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>copy容器内的配置文件到本地指定文件夹（之后映射到docker内指定目录）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker cp elasticsearch:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>config<span class="hljs-regexp">/ /</span>etc<span class="hljs-regexp">/local/</span>docker<span class="hljs-regexp">/elasticsearch/</span>conf<br></code></pre></td></tr></table></figure><h4 id="编辑配置文件elasticsearch-yml"><a href="#编辑配置文件elasticsearch-yml" class="headerlink" title="编辑配置文件elasticsearch.yml"></a>编辑配置文件elasticsearch.yml</h4><p>进入配置文件目录，编辑elasticsearch.yml文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/etc/</span>local<span class="hljs-regexp">/docker/</span>elasticsearch/conf<br>vim elasticsearch.yml<br></code></pre></td></tr></table></figure><p>新增如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 添加下面两行允许跨域使用，等会使用elasticsearch-head要用到</span><br><span class="hljs-attr">http.cors.enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">http.cors.allow-origin:</span> <span class="hljs-string">&quot;*&quot;</span><br><span class="hljs-comment"># 配置需校验密码</span><br><span class="hljs-attr">http.cors.allow-headers:</span> <span class="hljs-string">Authorization</span><br><span class="hljs-attr">xpack.security.enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">xpack.security.transport.ssl.enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="给data和conf目录授权"><a href="#给data和conf目录授权" class="headerlink" title="给data和conf目录授权"></a>给data和conf目录授权</h4><p>当然data和conf都是先创建好的，不授权的话，安装启动的时候会因为没有权限导致异常，或者不安装在<kbd>etc</kbd>目录，安装在<kbd>mnt</kbd>目录。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">chmod <span class="hljs-number">777</span> <span class="hljs-regexp">/etc/</span>local<span class="hljs-regexp">/docker/</span>elasticsearch/data<br>chmod <span class="hljs-number">777</span> <span class="hljs-regexp">/etc/</span>local<span class="hljs-regexp">/docker/</span>elasticsearch/conf<br></code></pre></td></tr></table></figure><h4 id="重新安装elasticsearch"><a href="#重新安装elasticsearch" class="headerlink" title="重新安装elasticsearch"></a>重新安装elasticsearch</h4><p>先暂停之前的容器并删除。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker stop elasticsearch<br>docker rm elasticsearch<br></code></pre></td></tr></table></figure><p>重新安装，并映射elasticsearch的数据和配置目录。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -d --restart=always --name elasticsearch -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> -p <span class="hljs-number">9300</span>:<span class="hljs-number">9300</span> -v <span class="hljs-regexp">/etc/</span>localtime:<span class="hljs-regexp">/etc/</span>localtime -v <span class="hljs-regexp">/etc/</span>local<span class="hljs-regexp">/docker/</span>elasticsearch<span class="hljs-regexp">/conf/</span>:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>config<span class="hljs-regexp">/ -v /</span>etc<span class="hljs-regexp">/local/</span>docker<span class="hljs-regexp">/elasticsearch/</span>data:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>data -v <span class="hljs-regexp">/etc/</span>local<span class="hljs-regexp">/docker/</span>elasticsearch<span class="hljs-regexp">/plugins:/u</span>sr<span class="hljs-regexp">/share/</span>elasticsearch/plugins -e ES_JAVA_OPTS=<span class="hljs-string">&quot;-Xms256m -Xmx256m&quot;</span> elasticsearch:<span class="hljs-number">7.16</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><p>启动容器，并进入容器内部。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker restart elasticsearch <br>docker exec -<span class="hljs-keyword">it</span> elasticsearch bash<br></code></pre></td></tr></table></figure><p>进入bin目录，然后开始设置密码，设置会提示一段话，可以看到elasticsearch系列的所有账号都会一并设置密码，账号一定要记住（因为云服务器过小，已经开了好几个服务，再开一个es会导致服务器卡死，故未截图）。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">cd</span> bin<br>elastic<span class="hljs-built_in">search-setup</span><span class="hljs-literal">-passwords</span> interactive  直接y回车开始输入密码（elasticsearch账号elastic，kibana使用的是kibana_system），密码******<br></code></pre></td></tr></table></figure><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>直接浏览器打开<kbd>服务器域名或者IP:9200</kbd>，或者直接命令行<kbd>curl 服务器域名或者IP:9200</kbd>，看到版本信息就是安装成功。</p><h3 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h3><p>安装如上，优先获取初始化的配置（容器内部目录&#x2F;usr&#x2F;share&#x2F;kibana&#x2F;config&#x2F;），不做阐述。</p><p>假如没有相关目录，直接执行以下步骤。</p><h4 id="设置配置文件"><a href="#设置配置文件" class="headerlink" title="设置配置文件"></a>设置配置文件</h4><p>本地新建kibana的目录，并创建配置文件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir -p <span class="hljs-regexp">/etc/</span>local<span class="hljs-regexp">/docker/</span>kibana/conf<br>cd <span class="hljs-regexp">/etc/</span>local<span class="hljs-regexp">/docker/</span>kibana/conf<br>touch kibana.yml<br></code></pre></td></tr></table></figure><p>编辑kibana.yml并设置elasticsearch账号密码</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta">#</span><br><span class="hljs-meta"># ** THIS IS AN AUTO-GENERATED FILE **</span><br><span class="hljs-meta">#</span><br><br><span class="hljs-meta"># Default Kibana configuration for docker target</span><br><span class="hljs-meta"># 不配置的话浏览器打开kibana，右下角会提示警告未设置publicBaseUrl</span><br><span class="hljs-symbol">server.publicBaseUrl:</span> <span class="hljs-string">&quot;kibana请求的地址&quot;</span><br><span class="hljs-symbol">server.name:</span> kibana<br><span class="hljs-symbol">server.host:</span> <span class="hljs-string">&quot;0.0.0.0&quot;</span><br><span class="hljs-symbol">elasticsearch.hosts:</span> [ <span class="hljs-string">&quot;自己服务地址&quot;</span> ]<br><span class="hljs-symbol">monitoring.ui.container.elasticsearch.enabled:</span> true<br><span class="hljs-symbol">elasticsearch.username:</span> <span class="hljs-string">&quot;kibana_system&quot;</span><br><span class="hljs-symbol">elasticsearch.password:</span> <span class="hljs-string">&quot;******&quot;</span><br><span class="hljs-symbol">xpack.security.sessionTimeout:</span> <span class="hljs-number">600000</span><br><span class="hljs-meta"># 以下两个配置不设置启动也会有警告</span><br><span class="hljs-symbol">xpack.security.encryptionKey:</span> <span class="hljs-string">&quot;************************************&quot;</span>  <span class="hljs-meta">#任意32或者以上的字符串</span><br><span class="hljs-symbol">xpack.reporting.encryptionKey:</span> <span class="hljs-string">&quot;******&quot;</span><br><span class="hljs-symbol">i18n.locale:</span> <span class="hljs-string">&quot;zh-CN&quot;</span><br></code></pre></td></tr></table></figure><h4 id="安装kibana"><a href="#安装kibana" class="headerlink" title="安装kibana"></a>安装kibana</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -d --name=kibana --restart=always -p <span class="hljs-number">5601</span>:<span class="hljs-number">5601</span> -v <span class="hljs-regexp">/etc/</span>localtime:<span class="hljs-regexp">/etc/</span>localtime -v <span class="hljs-regexp">/etc/</span>local<span class="hljs-regexp">/docker/</span>kibana<span class="hljs-regexp">/conf:/u</span>sr<span class="hljs-regexp">/share/</span>kibana<span class="hljs-regexp">/config/</span> kibana:<span class="hljs-number">7.16</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><p>直接浏览器打开<kbd>服务器域名或者IP:5601</kbd>，会让输入账号密码。</p><h3 id="elasticsearch-analysis-ik"><a href="#elasticsearch-analysis-ik" class="headerlink" title="elasticsearch-analysis-ik"></a>elasticsearch-analysis-ik</h3><p>进入容器内部，切到elasticsearch的bin目录，然后执行如下命令（切换到自己需要的版本）:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">elasticsearch-plugin install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/medcl/</span>elasticsearch-analysis-ik<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/v7.16.1/</span>elasticsearch-analysis-ik-<span class="hljs-number">7.16</span>.<span class="hljs-number">1</span>.zip<br></code></pre></td></tr></table></figure><p>至此，elasticsearch、kibana、ik安装完毕，因为安装过程整理了笔记，但是没有截图，故没有验证过程和截图。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx动静分离</title>
    <link href="/2022/06/11/nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/"/>
    <url>/2022/06/11/nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">nginx动静分离</font></div><p>动静分离指的是把动态和静态请求分开，不能简单地理解为动态页面和静态页面物理层面的分开，可以理解为nginx处理静态页面，tomcat处理动态页面。<br>动静分离的实现目前大致分为两种：</p><ol><li>纯粹的把静态文件独立成单独的域名，放在独立的服务器上（主流方案）。</li><li>动静态文件混合发布，通过nginx分开。<br>通过<code>location</code>指定不同的后缀名实现不同的请求转发，通过<code>expires</code>参数设置浏览器缓存过期时间，减少与服务器之间的请求和流量。</li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>el-upload + 前端直传minio(通过签名地址)</title>
    <link href="/2022/06/11/el-upload%20+%20%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0minio/"/>
    <url>/2022/06/11/el-upload%20+%20%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0minio/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">el-upload + 前端直传minio(通过签名地址)</font></div><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>前端请求后端获取预签名url（其中包含了上传到AWS S3所需要的认证信息），然后通过该签名url将文件直传到minio服务器。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>minio签名url只支持put请求，使用其他请求会提示错误的请求方法：</p><p><img src="/images/minio/post%E8%AF%B7%E6%B1%82%E6%8A%A5%E9%94%99.png" alt="post请求报错"></p><p>前端使用el-upload，默认调用其内部action，通过查看源码，可以看到el-upload组件引用了upload组件，进入upload发现还引入了ajax组件，在ajax组件的upload方法内部，可以看到请求方式是<kbd>post</kbd>请求（vue不熟悉，具体原理不清楚，只是站在自己理解的角度）：</p><p><img src="/images/minio/ajax-post.png" alt="ajax-post请求"></p><p>故通过minio签名url直传方式不能成功。</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>最后为了使用el-upload，只好折中，引入axios，即<kbd>el-upload + axios + minio</kbd>上传方式。</p><h3 id="后端生成签名地址"><a href="#后端生成签名地址" class="headerlink" title="后端生成签名地址"></a>后端生成签名地址</h3><p>minio具体相关信息在yml文件配置，或者交给nacos管理，不做讨论。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jivehaha.gulimall.thirdparty.controller;<br><br><span class="hljs-keyword">import</span> com.jievhaha.common.utils.Constant;<br><span class="hljs-keyword">import</span> com.jievhaha.common.utils.R;<br><span class="hljs-keyword">import</span> io.minio.GetPresignedObjectUrlArgs;<br><span class="hljs-keyword">import</span> io.minio.MinioClient;<br><span class="hljs-keyword">import</span> io.minio.http.Method;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.UUID;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: jievhaha</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2022/5/20 8:56</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinioController</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;minio.endpoint&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String endpoint;<br>    <span class="hljs-meta">@Value(&quot;$&#123;minio.accessKey&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String accessKey;<br>    <span class="hljs-meta">@Value(&quot;$&#123;minio.secretKey&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String secretKey;<br>    <span class="hljs-meta">@Value(&quot;$&#123;minio.bucket&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String bucket;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/minio/policy&quot;)</span><br>    <span class="hljs-keyword">private</span> R <span class="hljs-title function_">policy</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;pic&quot;)</span>String pic)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span>  <span class="hljs-operator">=</span> UUID.randomUUID() + <span class="hljs-string">&quot;-&quot;</span> + pic; <span class="hljs-comment">// 修改文件名防止上传相同文件被覆盖</span><br>        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dateTimeFormatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> dateTimeFormatter.format(LocalDateTime.now());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> format; <span class="hljs-comment">// 用户上传文件时指定的前缀，即上传目录。</span><br>        pic = dir + <span class="hljs-string">&quot;/&quot;</span> + name;<span class="hljs-comment">// 文件上传目录+名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/&quot;</span> + bucket + <span class="hljs-string">&quot;/&quot;</span> +  pic;<span class="hljs-comment">// 该值暂没用到，前端不熟直接使用没用域名的图片地址不知道怎么处理</span><br><br>        Map&lt;String, String&gt; respMap=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-type">MinioClient</span> <span class="hljs-variable">minioClient</span> <span class="hljs-operator">=</span> MinioClient.builder().endpoint(endpoint)<br>                    .credentials(accessKey,secretKey).build();<br>            Map&lt;String, String&gt; reqParams = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            reqParams.put(<span class="hljs-string">&quot;response-content-type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>            url = minioClient.getPresignedObjectUrl(<br>                    GetPresignedObjectUrlArgs.builder()<br>                            .method(Method.PUT)<span class="hljs-comment">//这里必须是PUT，如果是GET的话就是文件访问地址了。如果是POST上传会报错.</span><br>                            .bucket(bucket)<br>                            .object(pic)<br>                            .expiry(<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>)<br>                            .extraQueryParams(reqParams)<br>                            .build());<br>            System.out.println(url); <span class="hljs-comment">// 前端直传需要的url地址</span><br>            respMap= <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>            respMap.put(<span class="hljs-string">&quot;name&quot;</span>, name);<br>            respMap.put(<span class="hljs-string">&quot;host&quot;</span>, url);<br>            respMap.put(<span class="hljs-string">&quot;path&quot;</span>, path);<br>            respMap.put(<span class="hljs-string">&quot;url&quot;</span>, Constant.MINIO_URL + path);<span class="hljs-comment">// Constant.MINIO_URL自己的minio服务器地址</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Error occurred: &quot;</span> + e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> R.ok().put(<span class="hljs-string">&quot;data&quot;</span>, respMap);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="el-upload-axios"><a href="#el-upload-axios" class="headerlink" title="el-upload + axios"></a>el-upload + axios</h3><h4 id="引入axios"><a href="#引入axios" class="headerlink" title="引入axios"></a>引入axios</h4><p>安装axios：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">npm install axios --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>在main.js引用axios</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">import axios from <span class="hljs-string">&#x27;axios&#x27;</span>;<br>Vue.prototype.<span class="hljs-variable">$axios</span> = axios <span class="hljs-regexp">//</span>全局注册，使用方法为:this.<span class="hljs-variable">$axios</span><br></code></pre></td></tr></table></figure><h4 id="前端获取签名url"><a href="#前端获取签名url" class="headerlink" title="前端获取签名url"></a>前端获取签名url</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/httpRequest.js&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">policy</span>(<span class="hljs-params">pic</span>) &#123;<br>   <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">http</span>(&#123;<br>            <span class="hljs-attr">url</span>: http.<span class="hljs-title function_">adornUrl</span>(<span class="hljs-string">&quot;/thirdparty/minio/policy&quot;</span>),<br>            <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;get&quot;</span>,<br>            <span class="hljs-attr">params</span>: http.<span class="hljs-title function_">adornParams</span>(&#123;pic&#125;)<br>        &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123; data &#125;</span>) =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(data);<br>        &#125;)<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="上传组件"><a href="#上传组件" class="headerlink" title="上传组件"></a>上传组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;el-upload<br>      action = &#x27;&#x27;<br>      list-type=&quot;picture&quot;<br>      :multiple=&quot;false&quot; :show-file-list=&quot;showFileList&quot;<br>      :file-list=&quot;fileList&quot;<br>      :before-upload=&quot;beforeUpload&quot;<br>      :on-remove=&quot;handleRemove&quot;<br>      :on-success=&quot;handleUploadSuccess&quot;<br>      :on-preview=&quot;handlePreview&quot;&gt;<br>      &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt;<br>      &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过10MB&lt;/div&gt;<br>    &lt;/el-upload&gt;<br>    &lt;el-dialog :visible.sync=&quot;dialogVisible&quot;&gt;<br>      &lt;img width=&quot;100%&quot; :src=&quot;fileList[0].url&quot; alt=&quot;&quot;&gt;<br>    &lt;/el-dialog&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>   import &#123;policy&#125; from &#x27;./policy_minio&#x27;<br>  export default &#123;<br>    name: &#x27;singleUpload&#x27;,<br>    props: &#123;<br>      value: String<br>    &#125;,<br>    computed: &#123;<br>      imageUrl() &#123;<br>        return this.value;<br>      &#125;,<br>      imageName() &#123;<br>        if (this.value != null &amp;&amp; this.value !== &#x27;&#x27;) &#123;<br>          return this.value.substring(this.value.lastIndexOf(&quot;/&quot;) + 1);<br>        &#125; else &#123;<br>          return null;<br>        &#125;<br>      &#125;,<br>      fileList() &#123;<br>        return [&#123;<br>          name: this.imageName,<br>          url: this.imageUrl<br>        &#125;]<br>      &#125;,<br>      showFileList: &#123;<br>        get: function () &#123;<br>          return this.value !== null &amp;&amp; this.value !== &#x27;&#x27;&amp;&amp; this.value!==undefined;<br>        &#125;,<br>        set: function (newValue) &#123;<br>        &#125;<br>      &#125;<br>    &#125;,<br>    data() &#123;<br>      return &#123;<br>        dialogVisible: false<br>      &#125;;<br>    &#125;,<br>    methods: &#123;<br>      emitInput(val) &#123;<br>        this.$emit(&#x27;input&#x27;, val)<br>      &#125;,<br>      handleRemove(file, fileList) &#123;<br>        this.emitInput(&#x27;&#x27;);<br>      &#125;,<br>      handlePreview(file) &#123;<br>        this.dialogVisible = true;<br>      &#125;,<br>      beforeUpload(file) <br>        // 上传之前先调用policy_minio组件的policy方法获取签名url<br>        return new Promise((resolve, reject) =&gt; &#123;<br>          policy(file.name).then(response =&gt; &#123;<br>            let url = response.data.url;<br>            //将文件名改为后台返回的（原文件名前拼了段uuid），不然同名文件会覆盖<br>            let newFileName = response.data.name;<br>            let imageType = &quot;image/&quot; + newFileName.substring(newFileName.lastIndexOf(&quot;.&quot;) + 1);<br>            let newFile = new File([file], response.data.name,&#123;type:imageType&#125;);<br>            this.$axios.request(&#123;<br>              url: response.data.host,<br>              method: &#x27;put&#x27;,<br>              data: newFile<br>            &#125;).then((res)=&gt; &#123;<br>              this.showFileList = true;<br>              this.fileList.pop();<br>              this.fileList.push(&#123;name: file.name, url: url&#125;);<br>              this.emitInput(this.fileList[0].url);<br>            &#125;).catch(()=&gt; &#123;<br>              console.log(&quot;响应数据:上传失败&quot;);<br>            &#125;)<br><br>          &#125;).catch(err =&gt; &#123;<br>            console.log(JSON.stringify(err));<br>            reject(false)<br>          &#125;)<br>        &#125;)<br>      &#125;,<br>      handleUploadSuccess(res, file) &#123;<br>      &#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br>&lt;style&gt;<br><br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>着重点在<kbd>beforeUpload</kbd>方法，上传之前先调用policy_minio组件的policy方法获取签名url，然后再通过axios组件上传（假如使用FormData对象传递，最后会发现上传成功后，文件大小改变，且打开失败，故直接上传文件对象）。</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>通过组件上传，上传成功预览。</p><p><img src="/images/minio/%E4%B8%8A%E4%BC%A0.png" alt="上传并预览"></p><p>上传成功后服务器文件。</p><p><img src="/images/minio/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E4%BC%A0%E6%88%90%E5%8A%9F.png" alt="服务器上传成功"></p><p>注意：需要正常展示下载文件需要修改对应bucket权限，否则直接通过文件在服务器的路径访问，会直接进入文件夹，新增<kbd>read and write</kbd>权限。</p><p><img src="/images/minio/bucket%E6%9D%83%E9%99%90.png" alt="bucket权限"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>minio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>minio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Volatile简介</title>
    <link href="/2022/06/11/Volatile/"/>
    <url>/2022/06/11/Volatile/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">Volatile</font></div><h4 id="Volatile是什么"><a href="#Volatile是什么" class="headerlink" title="Volatile是什么"></a>Volatile是什么</h4><p>Java虚拟机提供的轻量级的同步机制，特性：</p><ol><li>保证可见性。</li><li>禁止指令排序。</li><li>不保证原子性。（例：i++，解决原子性，JUC下的Atomic…，底层原理CAS、Unsafe类）</li></ol><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>涉及到了<code>JMM</code>（Java内存模型），是一种抽象的概念，是一种规范，通过这种规范定义了程序中各个变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式。</p><p><strong>JMM的三大特性</strong>：原子性、可见性、有序性（编译器和处理器会进行指令重排）。</p><p>有序性：单线程环境里边确保程序最终执行结果和代码顺序执行的结果一致。处理器在进行重排序时必须要考虑指令间的数据依赖性。</p><p>同步规定：</p><ol><li>线程解锁前，必须把共享变量立刻刷回主内存。</li><li>线程加锁前，必须读取主内存中的最新值到工作内存中。</li><li>加锁解锁是同一把锁。</li></ol><p>内存屏障</p><p>单例模式：DCL</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>JUC</category>
      
      <category>基础原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unsafe简介</title>
    <link href="/2022/06/11/Unsafe/"/>
    <url>/2022/06/11/Unsafe/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">Unsafe简介</font></div><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Unsafe类为<strong>单例</strong>实现，提供静态方法getUnsafe获取Unsafe实例，当且仅当调用getUnsafe方法的类为<strong>引导类加载器</strong>所加载时才合法，否则抛出SecurityException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe theUnsafe;<br><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">getUnsafe</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Class</span> <span class="hljs-variable">var0</span> <span class="hljs-operator">=</span> Reflection.getCallerClass();<br>    <span class="hljs-keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityException</span>(<span class="hljs-string">&quot;Unsafe&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> theUnsafe;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那如若想使用这个类，该如何获取其实例？有如下两个可行方案。</p><p>其一，从<code>getUnsafe</code>方法的使用限制条件出发，通过Java命令行命令<code>-Xbootclasspath/a</code>把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过<code>Unsafe.getUnsafe</code>方法安全的获取Unsafe实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java -Xbootclasspath/a: $&#123;path&#125;   <span class="hljs-comment">// 其中path为调用Unsafe相关方法的类所在jar包路径 </span><br></code></pre></td></tr></table></figure><p>其二，通过反射获取单例对象theUnsafe。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">reflectGetUnsafe</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>      field.setAccessible(<span class="hljs-literal">true</span>);<br>      <span class="hljs-keyword">return</span> (Unsafe) field.get(<span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      log.error(e.getMessage(), e);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h4><p><img src="/images/JUC/Unsafe/%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD.png" alt="主要功能"></p><h4 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h4><p>这部分主要包含<strong>堆外内存</strong>的分配、拷贝、释放、给定地址值操作等方法。</p><p>通常，我们在Java中创建的对象都处于堆内内存（heap）中，堆内内存是由JVM所管控的Java进程内存，并且它们遵循JVM的内存管理机制，JVM会采用垃圾回收机制统一管理堆内存。与之相对的是堆外内存，存在于JVM管控之外的内存区域，Java中对堆外内存的操作，依赖于Unsafe提供的操作堆外内存的native方法。</p><h5 id="使用堆外内存的原因"><a href="#使用堆外内存的原因" class="headerlink" title="使用堆外内存的原因"></a>使用堆外内存的原因</h5><ul><li>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在GC时减少回收停顿对于应用的影响。</li><li>提升程序I&#x2F;O操作的性能。通常在I&#x2F;O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li></ul><h5 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h5><p><code>DirectByteBuffer</code>是Java用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在Netty、MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。</p><h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>这部分，包括线程挂起、恢复、锁机制等方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//取消阻塞线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Object thread)</span>;<br><span class="hljs-comment">//阻塞线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isAbsolute, <span class="hljs-type">long</span> time)</span>;<br><span class="hljs-comment">//获得对象锁（可重入锁）</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitorEnter</span><span class="hljs-params">(Object o)</span>;<br><span class="hljs-comment">//释放对象锁</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitorExit</span><span class="hljs-params">(Object o)</span>;<br><span class="hljs-comment">//尝试获取对象锁</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryMonitorEnter</span><span class="hljs-params">(Object o)</span>;<br></code></pre></td></tr></table></figure><h5 id="典型应用-1"><a href="#典型应用-1" class="headerlink" title="典型应用"></a>典型应用</h5><p>Java锁和同步器框架的核心类AbstractQueuedSynchronizer，就是通过调用<code>LockSupport.park()</code>和<code>LockSupport.unpark()</code>实现线程的阻塞和唤醒的，而LockSupport的park、unpark方法实际是调用Unsafe的park、unpark方式来实现。</p><h4 id="Class相关"><a href="#Class相关" class="headerlink" title="Class相关"></a>Class相关</h4><p>此部分主要提供Class和它的静态字段的操作相关方法，包含静态字段内存定位、定义类、定义匿名类、检验&amp;确保初始化等。</p><h4 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h4><p>此部分主要包含对象成员属性相关操作及非常规的对象实例化方式等相关方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回对象成员属性在内存地址相对于此对象的内存地址的偏移量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">objectFieldOffset</span><span class="hljs-params">(Field f)</span>;<br><span class="hljs-comment">//获得给定对象的指定地址偏移量的值，与此类似操作还有：getInt，getDouble，getLong，getChar等</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset)</span>;<br><span class="hljs-comment">//给定对象的指定地址偏移量设值，与此类似操作还有：putInt，putDouble，putLong，putChar等</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putObject</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, Object x)</span>;<br><span class="hljs-comment">//从对象的指定偏移量处获取变量的引用，使用volatile的加载语义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">getObjectVolatile</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset)</span>;<br><span class="hljs-comment">//存储变量的引用到对象的指定的偏移量处，使用volatile的存储语义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putObjectVolatile</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, Object x)</span>;<br><span class="hljs-comment">//有序、延迟版本的putObjectVolatile方法，不保证值的改变被其他线程立即看到。只有在field被volatile修饰符修饰时有效</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putOrderedObject</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, Object x)</span>;<br><span class="hljs-comment">//绕过构造方法、初始化代码来创建对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">allocateInstance</span><span class="hljs-params">(Class&lt;?&gt; cls)</span> <span class="hljs-keyword">throws</span> InstantiationException;<br></code></pre></td></tr></table></figure><h5 id="典型应用-2"><a href="#典型应用-2" class="headerlink" title="典型应用"></a>典型应用</h5><ul><li><strong>非常规的实例化方式</strong>：而Unsafe中提供allocateInstance方法，仅通过Class对���就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM安全检查等。它抑制修饰符检测，也就是即使构造器是private修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance在java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。</li></ul><h4 id="数组相关"><a href="#数组相关" class="headerlink" title="数组相关"></a>数组相关</h4><p>这部分主要介绍与数据操作相关的arrayBaseOffset与arrayIndexScale这两个方法，两者配合起来使用，即可定位数组中每个元素在内存中的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回数组中第一个元素的偏移地址</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">arrayBaseOffset</span><span class="hljs-params">(Class&lt;?&gt; arrayClass)</span>;<br><span class="hljs-comment">//返回数组中一个元素占用的大小</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">arrayIndexScale</span><span class="hljs-params">(Class&lt;?&gt; arrayClass)</span>;<br></code></pre></td></tr></table></figure><h5 id="典型应用-3"><a href="#典型应用-3" class="headerlink" title="典型应用"></a>典型应用</h5><p>这两个与数据操作相关的方法，在java.util.concurrent.atomic 包下的AtomicIntegerArray（可以实现对Integer数组中每个元素的原子性操作）中有典型的应用。</p><h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>在Java 8中引入，用于定义内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadFence</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">storeFence</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//内存屏障，禁止load、store操作重排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fullFence</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h4 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h4><p>这部分包含两个获取系统相关信息的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addressSize</span><span class="hljs-params">()</span>;  <br><span class="hljs-comment">//内存页的大小，此值为2的幂次方。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pageSize</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>JUC</category>
      
      <category>基础原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池原理</title>
    <link href="/2022/06/11/ThreadPoolExecutor/"/>
    <url>/2022/06/11/ThreadPoolExecutor/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">线程池原理</font></div><h4 id="线程池是什么"><a href="#线程池是什么" class="headerlink" title="线程池是什么"></a>线程池是什么</h4><p>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。<br>线程池（Thread Pool）是一种基于池化思想管理线程的工具，线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li><li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li><li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li><li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li></ul><h4 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h4><ol><li>使用Executors提供的一些工厂方法来快速创建ThreadPoolExecutor实例。但是不推荐，各个都有缺点。<br>使用Executors.newCachedThreadPool可以快速创建一个拥有自动回收线程功能且没有限制的线程池。<br>使用Executors.newFixedThreadPool可以用来创建一个固定线程大小的线程池。<br>使用Executors.newSingleThreadExecutor可以用来创建一个单线程的执行器。</li><li>通过构造参数创建ThreadPoolExecutor实例。（推荐，可以设置合理的核心线程数，最大线程数，队列，也可以熟悉线程池的原理）。<br>除了通过构造参数设置这几个线程池参数之外我们还可以在运行时设置。<br>ThreadPoolExecutor提供了这几个参数的<code>get</code>、<code>set</code>方法。</li></ol><p>ThreadPoolExecutor还提供了protected类型得可以被覆盖的方法，允许用户在任务执行之前或执行之后做一些事情。我们可以通过它来实现比如初始化ThreadLocal、收集统计信息、如记录日志等操作，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* Extension hooks */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> &#123; &#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>另外还有一个Hook可以用来在任务被执行完的时候让用户插入逻辑:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">terminated</span><span class="hljs-params">()</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="线程池核心设计与实现"><a href="#线程池核心设计与实现" class="headerlink" title="线程池核心设计与实现"></a>线程池核心设计与实现</h4><h5 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h5><p>Java中的线程池核心实现类是ThreadPoolExecutor<br>![ThreadPoolExecutor UML类图](&#x2F;images&#x2F;JUC&#x2F;ThreadPoolExecutor&#x2F;ThreadPoolExecutor UML类图.png)<br>ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。其运行机制如下图所示：<br><img src="/images/JUC/ThreadPoolExecutor/ThreadPoolExecutor%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="ThreadPoolExecutor运行流程"><br>线程池在内部实际上构建了一个<strong>生产者消费者模型</strong>，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><h6 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h6><p>线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。类似于读写锁<kbd>ReentrantReadWriteLock</kbd>维护读、写锁数量分别使用高16位（读）和低16位（写）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p><code>ctl</code>是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。<br>关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="hljs-comment">//计算当前运行状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;  <span class="hljs-comment">//计算当前线程数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123; <span class="hljs-keyword">return</span> rs | wc; &#125;   <span class="hljs-comment">//通过状态和线程数生成ctl</span><br></code></pre></td></tr></table></figure><p>ThreadPoolExecutor的运行状态有5种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//runState is stored in the high-order bits</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">//能接受新提交的任务，并且能处理阻���队列中的任务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">//关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">//不再接受新任务，也不处理队列中的任务，会中断正在处理任务的线程</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">//所有线程都已终止，workerCount（有效线程数）为0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">//在terminated()方法执行完后进入该状态</span><br></code></pre></td></tr></table></figure><p><img src="/images/JUC/ThreadPoolExecutor/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程池生命周期"></p><h6 id="任务执行机制"><a href="#任务执行机制" class="headerlink" title="任务执行机制"></a>任务执行机制</h6><ol><li>任务调度<br>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。<br>首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：<br>a. 首先检测线程池运行状态，如果不是<kbd>RUNNING</kbd>，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。&gt;RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。<br>b. 如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务。<br>c. 如果<code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。<br>d. 如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。<br>e. 如果<code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。<br><img src="/images/JUC/ThreadPoolExecutor/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.png" alt="任务调度流程"></li><li>任务缓冲<br>线程池的本质是对任务和线程的管理，在线程池中是以生产者消费者模式实现的，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。<br>使用不同的队列可以实现不一样的任务存取策略：<br> <img src="/images/JUC/ThreadPoolExecutor/%E5%90%84%E7%A7%8D%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AD%96%E7%95%A5.png" alt="各种队列实现的任务策略"></li><li>任务申请<br>根据线程调度可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。<br>线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由<code>getTask</code>方法实现。</li></ol><p><img src="/images/JUC/ThreadPoolExecutor/%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="获取任务流程图"></p><p>在不考虑异常的场景下，返回null，就表示退出循环，结束线程：</p><p>1、线程池的状态已经是STOP（1），TIDYING（2）, TERMINATED（3），或者是SHUTDOWN（0）且工作队列为空，<code>allowCoreThreadTimeOut</code>默认值是<code>false</code>，即核心线程不会超时不会被回收（可自行设置），所以线程池一直是<code>RUNNING</code>状态。</p><p>2、工作线程数已经大于最大线程数或者当前工作线程已超时，并且还有其他工作线程或任务队列为空.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br>      <span class="hljs-keyword">for</span> (;;) &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>          <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br>          <span class="hljs-comment">// 线程池的状态已经是STOP（1），TIDYING（2）, TERMINATED（3），或者是SHUTDOWN（0）且工作队列为空.</span><br>          <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>              decrementWorkerCount();<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>          &#125;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br>          <span class="hljs-comment">// allowCoreThreadTimeOut默认为false</span><br>          <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br>          <span class="hljs-comment">// 工作线程数已经大于最大线程数或者当前工作线程已超时，并且还有其他工作线程或任务队列为空</span><br>          <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>              &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>              <span class="hljs-comment">// 此处CAS保证了安全，比方allowCoreThreadTimeOut为false的情况下，多条空闲线程到这导致核心线程比定义的少。</span><br>              <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>              <span class="hljs-keyword">continue</span>;<br>          &#125;<br>          <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">//获取任务</span><br>              <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                  workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                  workQueue.take();<br>              <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                  <span class="hljs-keyword">return</span> r;<br>              timedOut = <span class="hljs-literal">true</span>;<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>              timedOut = <span class="hljs-literal">false</span>;<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>任务拒绝（拒绝策略）<br>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到<code>maximumPoolSize</code>时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。<br>拒绝策略是一个接口：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor executor)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>用户可以通过实现这个接口去定制拒绝策略，线程池本身提供了四种拒绝策略：<br><img src="/images/JUC/ThreadPoolExecutor/%E5%9B%9B%E7%A7%8D%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.png" alt="四种拒绝策略"></li></ol><h6 id="Worker线程管理"><a href="#Worker线程管理" class="headerlink" title="Worker线程管理"></a>Worker线程管理</h6><ol><li><p>Worker线程<br>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">final</span> Thread thread;<span class="hljs-comment">//Worker持有的线程</span><br>    Runnable firstTask;<span class="hljs-comment">//初始化的任务，可以为null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Worker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。<strong>如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。</strong><br><img src="/images/JUC/ThreadPoolExecutor/Worker%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1.png" alt="Worker执行任务"><br>线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张<code>Hash表</code>去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。<br>Worker是通过继承<code>AQS</code>实现独占锁这个功能，没有使用可重入锁ReentrantLock。使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。<br>a. lock方法一旦获取了独占锁，表示当前线程正在执行任务中。<br>b. 如果正在执行任务，则不应该中断线程。<br>c. 如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。<br>d. 线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</p></li><li><p>Worker线程增加<br>增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的（任务管理），该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。<br>addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize。<br><img src="/images/JUC/ThreadPoolExecutor/%E7%94%B3%E8%AF%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1.png" alt="申请线程执行任务"></p></li><li><p>Worker线程回收<br>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行<strong>轮询</strong>，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">//执行任务</span><br>  &#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  processWorkerExit(w, completedAbruptly);<span class="hljs-comment">//获取不到任务时，主动回收自己</span><br>&#125;<br></code></pre></td></tr></table></figure><p>事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。</p></li><li><p>Worker线程执行任务<br>在<code>Worker</code>类中的<code>run</code>方法调用了<code>runWorker</code>方法来执行任务，runWorker方法的执行过程如下：<br>a. while循环不断地通过getTask()方法获取任务。<br>b. getTask()方法从阻塞队列中取任务。<br>c. 如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。</p></li></ol><p>  d. 执行任务。</p><p>  e. 如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。<br>  <img src="/images/JUC/ThreadPoolExecutor/%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B.png" alt="执行任务流程"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>        w.firstTask = <span class="hljs-literal">null</span>;<br>        w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>                w.lock();<br>                <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                     (Thread.interrupted() &amp;&amp;<br>                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                    !wt.isInterrupted())<br>                    wt.interrupt();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    beforeExecute(wt, task);<br>                    <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        task.run();<br>                    &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> x;<br>                    &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> x;<br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        afterExecute(task, thrown);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                    w.completedTasks++;<br>                    w.unlock();<br>                &#125;<br>            &#125;<br>            completedAbruptly = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            processWorkerExit(w, completedAbruptly);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="业务应用"><a href="#业务应用" class="headerlink" title="业务应用"></a>业务应用</h4><p>线程池构造参数有7个，但是最核心的是3个：corePoolSize、maximumPoolSize，workQueue，它们最大程度地决定了线程池的任务分配和线程分配策略。考虑到在实际应用中我们获取并发性的场景主要是两种：（1）并行执行子任务，提高响应速度。这种情况下，应该使用<strong>同步</strong>队列，没有什么任务应该被缓存下来，而是应该立即执行。（2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用<strong>有界</strong>队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。</p><h4 id="动态设置"><a href="#动态设置" class="headerlink" title="动态设置"></a>动态设置</h4><h5 id="设置核心线程数"><a href="#设置核心线程数" class="headerlink" title="设置核心线程数"></a>设置核心线程数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCorePoolSize</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">delta</span> <span class="hljs-operator">=</span> corePoolSize - <span class="hljs-built_in">this</span>.corePoolSize;<br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)<br>        interruptIdleWorkers();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delta &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Math.min(delta, workQueue.size());<br>        <span class="hljs-keyword">while</span> (k-- &gt; <span class="hljs-number">0</span> &amp;&amp; addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (workQueue.isEmpty())<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在运行期线程池使用方调用此方法设置corePoolSize之后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的处理策略。</p><p>对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idel（闲置的，空闲的）的时候也会被回收；</p><p>对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务。</p><p><img src="/images/JUC/ThreadPoolExecutor/%E8%AE%BE%E7%BD%AE%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0.png" alt="设置核心线程数"></p><h5 id="设置最大线程数"><a href="#设置最大线程数" class="headerlink" title="设置最大线程数"></a>设置最大线程数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMaximumPoolSize</span><span class="hljs-params">(<span class="hljs-type">int</span> maximumPoolSize)</span> &#123;<br>    <span class="hljs-keyword">if</span> (maximumPoolSize &lt;= <span class="hljs-number">0</span> || maximumPoolSize &lt; corePoolSize)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-keyword">if</span> (workerCountOf(ctl.get()) &gt; maximumPoolSize)<br>        interruptIdleWorkers();<br>&#125;<br></code></pre></td></tr></table></figure><p>1.首先是参数合法性校验。</p><p>2.然后用传递进来的值，覆盖原来的值。</p><p>3.判断工作线程是否是大于最大线程数，如果大于，则对空闲线程发起中断请求。</p><ol start="3"><li><p>如何设置</p><p>设置核心线程数的时候，同时设置最大线程数即可。其实可以把二者设置为相同的值。</p><p>原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>        <span class="hljs-comment">// Are workers subject to culling?</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>        <span class="hljs-comment">//如果工作线程数大于最大线程数，则对工作线程数量进行减一操作，然后返回 null。</span><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>            workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个地方的实际流程应该是： 创建新的工作线程 worker，然后工作线程数进行加一操作。 运行创建的工作线程 worker，开始获取任务 task。 工作线程数量大于最大线程数，对工作线程数进行减一操作。 返回 null，即没有获取到 task。 清理该任务，流程结束。</p></li><li><p>如果调整之后把活动线程数设置的值太大了，岂不是业务低峰期我们还需要人工把值调的小一点？</p><p>答案是不存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">* <span class="hljs-meta">@param</span> corePoolSize the number of threads to keep in the pool, even<br>    *        <span class="hljs-keyword">if</span> they are idle, unless &#123;<span class="hljs-meta">@code</span> allowCoreThreadTimeOut&#125; is set<br></code></pre></td></tr></table></figure><p>当 <code>allowCoreThreadTimeOut </code>参数设置为 <code>true </code>的时候，核心线程在空闲了<code>keepAliveTime </code>的时间后也会被回收的，相当于线程池自动给你动态修改了。</p></li></ol><h5 id="动态设置队列长度（看的美团的线程池设置，他们用的队列是LinkedBlockingQueue）"><a href="#动态设置队列长度（看的美团的线程池设置，他们用的队列是LinkedBlockingQueue）" class="headerlink" title="动态设置队列长度（看的美团的线程池设置，他们用的队列是LinkedBlockingQueue）"></a>动态设置队列长度（看的美团的线程池设置，他们用的队列是LinkedBlockingQueue）</h5><p>并没有设置队列长度的 set 方法啊…源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//队列的 capacity 是被 final 修饰了</span><br><span class="hljs-comment">/** The capacity bound, or Integer.MAX_VALUE if none */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;<br></code></pre></td></tr></table></figure><p>想要设置可以自定义队列（比如：自定义队列内容完全和linkedBlockingQueue一样，只是Capacity的final给去掉，并提供get和set）</p><h5 id="其他问题："><a href="#其他问题：" class="headerlink" title="其他问题："></a>其他问题：</h5><p>a. 线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？</p><p>线程池被创建后如果没有任务过来，里面是不会有线程的。如果需要预热的话可以调用下面的两个方法：</p><p>全部启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Starts all core threads, causing them to idly wait for work. This</span><br><span class="hljs-comment">     * overrides the default policy of starting core threads only when</span><br><span class="hljs-comment">     * new tasks are executed.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the number of threads started</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prestartAllCoreThreads</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>))<br>        ++n;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Starts a core thread, causing it to idly wait for work. This</span><br><span class="hljs-comment">     * overrides the default policy of starting core threads only when</span><br><span class="hljs-comment">     * new tasks are executed. This method will return &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment">     * if all core threads have already been started.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if a thread was started</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">prestartCoreThread</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> workerCountOf(ctl.get()) &lt; corePoolSize &amp;&amp;<br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>b. 核心线程数会被回收吗？需要什么设置？</p><p>核心线程数默认是不会被回收的，如果需要回收核心线程数，需要调用下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * If false (default), core threads stay alive even when idle.</span><br><span class="hljs-comment">     * If true, core threads use keepAliveTime to time out waiting</span><br><span class="hljs-comment">     * for work.</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> allowCoreThreadTimeOut;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">allowCoreThreadTimeOut</span><span class="hljs-params">(<span class="hljs-type">boolean</span> value)</span> &#123;<br>    <span class="hljs-keyword">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Core threads must have nonzero keep alive times&quot;</span>);<br>    <span class="hljs-keyword">if</span> (value != allowCoreThreadTimeOut) &#123;<br>        allowCoreThreadTimeOut = value;<br>        <span class="hljs-keyword">if</span> (value)<br>            interruptIdleWorkers();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>JUC</category>
      
      <category>线程池</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot核心基础</title>
    <link href="/2022/06/11/Spring%20Boot%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/11/Spring%20Boot%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">Springboot核心基础</font></div><h1 id="一、Spring-Boot-入门"><a href="#一、Spring-Boot-入门" class="headerlink" title="一、Spring Boot 入门"></a><strong>一、</strong>Spring Boot 入门</h1><h2 id="1、Spring-Boot-简介"><a href="#1、Spring-Boot-简介" class="headerlink" title="1、Spring Boot 简介"></a>1、Spring Boot 简介</h2><blockquote><p>简化Spring应用开发的一个框架；</p><p>整个Spring技术栈的一个大整合；</p><p>J2EE开发的一站式解决方案；</p></blockquote><h2 id="2、微服务"><a href="#2、微服务" class="headerlink" title="2、微服务"></a>2、微服务</h2><p>2014，martin fowler</p><p>微服务：架构风格（服务微化）</p><p>一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；</p><p>单体应用：ALL IN ONE</p><p>微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p><p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa">详细参照微服务文档</a></p><h2 id="3、环境准备"><a href="#3、环境准备" class="headerlink" title="3、环境准备"></a>3、环境准备</h2><p><a href="http://www.gulixueyuan.com/">http://www.gulixueyuan.com/</a> 谷粒学院</p><p>环境约束</p><p>–jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112”</p><p>–maven3.x：maven 3.3以上版本；Apache Maven 3.3.9</p><p>–IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS</p><p>–SpringBoot 1.5.9.RELEASE：1.5.9；</p><p>统一环境；</p><h3 id="1、MAVEN设置；"><a href="#1、MAVEN设置；" class="headerlink" title="1、MAVEN设置；"></a>1、MAVEN设置；</h3><p>给maven 的settings.xml配置文件的profiles标签添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、IDEA设置"><a href="#2、IDEA设置" class="headerlink" title="2、IDEA设置"></a>2、IDEA设置</h3><p>整合maven进来；</p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180129151045.png" alt="idea设置"></p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180129151112.png" alt="images/"></p><h2 id="4、Spring-Boot-HelloWorld"><a href="#4、Spring-Boot-HelloWorld" class="headerlink" title="4、Spring Boot HelloWorld"></a>4、Spring Boot HelloWorld</h2><p>一个功能：</p><p>浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；</p><h3 id="1、创建一个maven工程；（jar）"><a href="#1、创建一个maven工程；（jar）" class="headerlink" title="1、创建一个maven工程；（jar）"></a>1、创建一个maven工程；（jar）</h3><h3 id="2、导入spring-boot相关的依赖"><a href="#2、导入spring-boot相关的依赖" class="headerlink" title="2、导入spring boot相关的依赖"></a>2、导入spring boot相关的依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3、编写一个主程序；启动Spring-Boot应用"><a href="#3、编写一个主程序；启动Spring-Boot应用" class="headerlink" title="3、编写一个主程序；启动Spring Boot应用"></a>3、编写一个主程序；启动Spring Boot应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldMainApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// Spring应用启动起来</span><br>        SpringApplication.run(HelloWorldMainApplication.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、编写相关的Controller、Service"><a href="#4、编写相关的Controller、Service" class="headerlink" title="4、编写相关的Controller、Service"></a>4、编写相关的Controller、Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="5、运行主程序测试"><a href="#5、运行主程序测试" class="headerlink" title="5、运行主程序测试"></a>5、运行主程序测试</h3><h3 id="6、简化部署"><a href="#6、简化部署" class="headerlink" title="6、简化部署"></a>6、简化部署</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将这个应用打成jar包，直接使用java -jar的命令进行执行；</p><h2 id="5、Hello-World探究"><a href="#5、Hello-World探究" class="headerlink" title="5、Hello World探究"></a>5、Hello World探究</h2><h3 id="1、POM文件"><a href="#1、POM文件" class="headerlink" title="1、POM文件"></a>1、POM文件</h3><h4 id="1、父项目"><a href="#1、父项目" class="headerlink" title="1、父项目"></a>1、父项目</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>他的父项目是<br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>他来真正管理Spring Boot应用里面的所有依赖版本；<br><br></code></pre></td></tr></table></figure><p>Spring Boot的版本仲裁中心；</p><p>以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）</p><h4 id="2、启动器"><a href="#2、启动器" class="headerlink" title="2、启动器"></a>2、启动器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>spring-boot-starter</strong>-&#x3D;&#x3D;web&#x3D;&#x3D;：</p><p>​spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；</p><p>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p><h3 id="2、主程序类，主入口类"><a href="#2、主程序类，主入口类" class="headerlink" title="2、主程序类，主入口类"></a>2、主程序类，主入口类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldMainApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// Spring应用启动起来</span><br>        SpringApplication.run(HelloWorldMainApplication.class,args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>@<strong>SpringBootApplication</strong>:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(excludeFilters = &#123;</span><br><span class="hljs-meta">      @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="hljs-meta">      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br></code></pre></td></tr></table></figure><p>@<strong>SpringBootConfiguration</strong>:Spring Boot的配置类；</p><p>​标注在某个类上，表示这是一个Spring Boot的配置类；</p><p>​@<strong>Configuration</strong>:配置类上来标注这个注解；</p><p>​配置类 —–  配置文件；配置类也是容器中的一个组件；@Component</p><p>@<strong>EnableAutoConfiguration</strong>：开启自动配置功能；</p><p>​以前我们需要配置的东西，Spring Boot帮我们自动配置；@<strong>EnableAutoConfiguration</strong>告诉SpringBoot开启自动配置功能；这样自动配置才能生效；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(EnableAutoConfigurationImportSelector.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br></code></pre></td></tr></table></figure><p>​      @<strong>AutoConfigurationPackage</strong>：自动配置包</p><p>​@<strong>Import</strong>(AutoConfigurationPackages.Registrar.class)：</p><p>​Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；</p><p>&#x3D;&#x3D;将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；&#x3D;&#x3D;</p><p>​@<strong>Import</strong>(EnableAutoConfigurationImportSelector.class)；</p><p>​给容器中导入组件？</p><p>​<strong>EnableAutoConfigurationImportSelector</strong>：导入哪些组件的选择器；</p><p>​将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；</p><p>​会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；<img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180129224104.png" alt="自动配置类"></p><p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；</p><p>​SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；</p><p>&#x3D;&#x3D;Spring Boot在启动的时候从类路径下的META-INF&#x2F;spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；&#x3D;&#x3D;以前我们需要自己配置的东西，自动配置类都帮我们；</p><p>J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；</p><p>​</p><p>&#x3D;&#x3D;Spring注解版（谷粒学院）&#x3D;&#x3D;</p><h2 id="6、使用Spring-Initializer快速创建Spring-Boot项目"><a href="#6、使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="6、使用Spring Initializer快速创建Spring Boot项目"></a>6、使用Spring Initializer快速创建Spring Boot项目</h2><h3 id="1、IDEA：使用-Spring-Initializer快速创建项目"><a href="#1、IDEA：使用-Spring-Initializer快速创建项目" class="headerlink" title="1、IDEA：使用 Spring Initializer快速创建项目"></a>1、IDEA：使用 Spring Initializer快速创建项目</h3><p>IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；</p><p>选择我们需要的模块；向导会联网创建Spring Boot项目；</p><p>默认生成的Spring Boot项目；</p><ul><li>主程序已经生成好了，我们只需要我们自己的逻辑</li><li>resources文件夹中目录结构<ul><li>static：保存所有的静态资源； js css  images；</li><li>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；</li><li>application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；</li></ul></li></ul><h3 id="2、STS使用-Spring-Starter-Project快速创建项目"><a href="#2、STS使用-Spring-Starter-Project快速创建项目" class="headerlink" title="2、STS使用 Spring Starter Project快速创建项目"></a>2、STS使用 Spring Starter Project快速创建项目</h3><hr><h1 id="二、配置文件"><a href="#二、配置文件" class="headerlink" title="二、配置文件"></a>二、配置文件</h1><h2 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h2><p>SpringBoot使用一个全局的配置文件，配置文件名是固定的；</p><p>•application.properties</p><p>•application.yml</p><p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；</p><p>YAML（YAML Ain’t Markup Language）</p><p>​YAML  A Markup Language：是一个标记语言</p><p>​YAML   isn’t Markup Language：不是一个标记语言；</p><p>标记语言：</p><p>​以前的配置文件；大多都使用的是  <strong>xxxx.xml</strong>文件；</p><p>​YAML：<strong>以数据为中心</strong>，比json、xml等更适合做配置文件；</p><p>​YAML：配置例子</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br></code></pre></td></tr></table></figure><p>​XML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8081<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2、YAML语法："><a href="#2、YAML语法：" class="headerlink" title="2、YAML语法："></a>2、YAML语法：</h2><h3 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><p>k:(空格)v：表示一对键值对（空格必须有）；</p><p>以<strong>空格</strong>的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/hello</span><br></code></pre></td></tr></table></figure><p>属性和值也是大小写敏感；</p><h3 id="2、值的写法"><a href="#2、值的写法" class="headerlink" title="2、值的写法"></a>2、值的写法</h3><h4 id="字面量：普通的值（数字，字符串，布尔）"><a href="#字面量：普通的值（数字，字符串，布尔）" class="headerlink" title="字面量：普通的值（数字，字符串，布尔）"></a>字面量：普通的值（数字，字符串，布尔）</h4><p>​k: v：字面直接来写；</p><p>​字符串默认不用加上单引号或者双引号；</p><p>​“”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p><p>​name:   “zhangsan \n lisi”：输出；zhangsan 换行  lisi</p><p>​‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p><p>​name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi</p><h4 id="对象、Map（属性和值）（键值对）："><a href="#对象、Map（属性和值）（键值对）：" class="headerlink" title="对象、Map（属性和值）（键值对）："></a>对象、Map（属性和值）（键值对）：</h4><p>​k: v：在下一行来写对象的属性和值的关系；注意缩进</p><p>​对象还是k: v的方式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">friends:</span><br><span class="hljs-attr">lastName:</span> <span class="hljs-string">zhangsan</span><br><span class="hljs-attr">age:</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>行内写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">friends:</span> &#123;<span class="hljs-attr">lastName:</span> <span class="hljs-string">zhangsan</span>,<span class="hljs-attr">age:</span> <span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="数组（List、Set）："><a href="#数组（List、Set）：" class="headerlink" title="数组（List、Set）："></a>数组（List、Set）：</h4><p>用- 值表示数组中的一个元素</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">pets:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">dog</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">pig</span><br></code></pre></td></tr></table></figure><p>行内写法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">pets:</span> [<span class="hljs-string">cat</span>,<span class="hljs-string">dog</span>,<span class="hljs-string">pig</span>]<br></code></pre></td></tr></table></figure><h2 id="3、配置文件值注入"><a href="#3、配置文件值注入" class="headerlink" title="3、配置文件值注入"></a>3、配置文件值注入</h2><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">person:</span><br>    <span class="hljs-attr">lastName:</span> <span class="hljs-string">hello</span><br>    <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br>    <span class="hljs-attr">boss:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">birth:</span> <span class="hljs-number">2017</span><span class="hljs-string">/12/12</span><br>    <span class="hljs-attr">maps:</span> &#123;<span class="hljs-attr">k1:</span> <span class="hljs-string">v1</span>,<span class="hljs-attr">k2:</span> <span class="hljs-number">12</span>&#125;<br>    <span class="hljs-attr">lists:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">lisi</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zhaoliu</span><br>    <span class="hljs-attr">dog:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">小狗</span><br>      <span class="hljs-attr">age:</span> <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>javaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span><br><span class="hljs-comment"> *      prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="hljs-doctag">@ConfigurationProperties</span>功能；</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String lastName;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Boolean boss;<br>    <span class="hljs-keyword">private</span> Date birth;<br><br>    <span class="hljs-keyword">private</span> Map&lt;String,Object&gt; maps;<br>    <span class="hljs-keyword">private</span> List&lt;Object&gt; lists;<br>    <span class="hljs-keyword">private</span> Dog dog;<br><br></code></pre></td></tr></table></figure><p>我们可以导入配置文件处理器，以后编写配置就有提示了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1、properties配置文件在idea中默认utf-8可能会乱码"><a href="#1、properties配置文件在idea中默认utf-8可能会乱码" class="headerlink" title="1、properties配置文件在idea中默认utf-8可能会乱码"></a>1、properties配置文件在idea中默认utf-8可能会乱码</h4><p>调整</p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180130161620.png" alt="idea配置乱码"></p><h4 id="2、-Value获取值和-ConfigurationProperties获取值比较"><a href="#2、-Value获取值和-ConfigurationProperties获取值比较" class="headerlink" title="2、@Value获取值和@ConfigurationProperties获取值比较"></a>2、@Value获取值和@ConfigurationProperties获取值比较</h4><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定（松散语法）</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><p>配置文件yml还是properties他们都能获取到值；</p><p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；</p><p>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p><h4 id="3、配置文件注入值数据校验"><a href="#3、配置文件注入值数据校验" class="headerlink" title="3、配置文件注入值数据校验"></a>3、配置文件注入值数据校验</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="hljs-meta">@Validated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &lt;bean class=&quot;Person&quot;&gt;</span><br><span class="hljs-comment">     *      &lt;property name=&quot;lastName&quot; value=&quot;字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="hljs-comment">     * &lt;bean/&gt;</span><br><span class="hljs-comment">     */</span><br><br>   <span class="hljs-comment">//lastName必须是邮箱格式</span><br>    <span class="hljs-meta">@Email</span><br>    <span class="hljs-comment">//@Value(&quot;$&#123;person.last-name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String lastName;<br>    <span class="hljs-comment">//@Value(&quot;#&#123;11*2&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-comment">//@Value(&quot;true&quot;)</span><br>    <span class="hljs-keyword">private</span> Boolean boss;<br><br>    <span class="hljs-keyword">private</span> Date birth;<br>    <span class="hljs-keyword">private</span> Map&lt;String,Object&gt; maps;<br>    <span class="hljs-keyword">private</span> List&lt;Object&gt; lists;<br>    <span class="hljs-keyword">private</span> Dog dog;<br></code></pre></td></tr></table></figure><h4 id="4、-PropertySource-amp-ImportResource-amp-Bean"><a href="#4、-PropertySource-amp-ImportResource-amp-Bean" class="headerlink" title="4、@PropertySource&amp;@ImportResource&amp;@Bean"></a>4、@PropertySource&amp;@ImportResource&amp;@Bean</h4><p>@<strong>PropertySource</strong>：加载指定的配置文件；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span><br><span class="hljs-comment"> *      prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="hljs-doctag">@ConfigurationProperties</span>功能；</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@ConfigurationProperties</span>(prefix = &quot;person&quot;)默认从全局配置文件中获取值；</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PropertySource(value = &#123;&quot;classpath:person.properties&quot;&#125;)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="hljs-comment">//@Validated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &lt;bean class=&quot;Person&quot;&gt;</span><br><span class="hljs-comment">     *      &lt;property name=&quot;lastName&quot; value=&quot;字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="hljs-comment">     * &lt;bean/&gt;</span><br><span class="hljs-comment">     */</span><br><br>   <span class="hljs-comment">//lastName必须是邮箱格式</span><br>   <span class="hljs-comment">// @Email</span><br>    <span class="hljs-comment">//@Value(&quot;$&#123;person.last-name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String lastName;<br>    <span class="hljs-comment">//@Value(&quot;#&#123;11*2&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-comment">//@Value(&quot;true&quot;)</span><br>    <span class="hljs-keyword">private</span> Boolean boss;<br><br></code></pre></td></tr></table></figure><p>@<strong>ImportResource</strong>：导入Spring的配置文件，让配置文件里面的内容生效；</p><p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；</p><p>想让Spring的配置文件生效，加载进来；@<strong>ImportResource</strong>标注在一个配置类上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ImportResource(locations = &#123;&quot;classpath:beans.xml&quot;&#125;)</span><br>导入Spring的配置文件让其生效<br></code></pre></td></tr></table></figure><p>不来编写Spring的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.springboot.service.HelloService&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式</p><p>1、配置类**@Configuration**——&gt;Spring配置文件</p><p>2、使用**@Bean**给容器中添加组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Configuration</span>：指明当前类是一个配置类；就是来替代之前的Spring配置文件</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAppConfig</span> &#123;<br><br>    <span class="hljs-comment">//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> HelloService <span class="hljs-title function_">helloService02</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;配置类@Bean给容器中添加组件了...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloService</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>##4、配置文件占位符</p><h3 id="1、随机数"><a href="#1、随机数" class="headerlink" title="1、随机数"></a>1、随机数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">$&#123;random.value&#125;、$&#123;random.<span class="hljs-type">int</span>&#125;、$&#123;random.<span class="hljs-type">long</span>&#125;<br>$&#123;random.<span class="hljs-type">int</span>(<span class="hljs-number">10</span>)&#125;、$&#123;random.<span class="hljs-type">int</span>[<span class="hljs-number">1024</span>,<span class="hljs-number">65536</span>]&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2、占位符获取之前配置的值，如果没有可以是用-指定默认值"><a href="#2、占位符获取之前配置的值，如果没有可以是用-指定默认值" class="headerlink" title="2、占位符获取之前配置的值，如果没有可以是用:指定默认值"></a>2、占位符获取之前配置的值，如果没有可以是用:指定默认值</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">person.last-name</span>=<span class="hljs-string">张三$&#123;random.uuid&#125;</span><br><span class="hljs-attr">person.age</span>=<span class="hljs-string">$&#123;random.int&#125;</span><br><span class="hljs-attr">person.birth</span>=<span class="hljs-string">2017/12/15</span><br><span class="hljs-attr">person.boss</span>=<span class="hljs-string">false</span><br><span class="hljs-attr">person.maps.k1</span>=<span class="hljs-string">v1</span><br><span class="hljs-attr">person.maps.k2</span>=<span class="hljs-string">14</span><br><span class="hljs-attr">person.lists</span>=<span class="hljs-string">a,b,c</span><br><span class="hljs-attr">person.dog.name</span>=<span class="hljs-string">$&#123;person.hello:hello&#125;_dog</span><br><span class="hljs-attr">person.dog.age</span>=<span class="hljs-string">15</span><br></code></pre></td></tr></table></figure><h2 id="5、Profile"><a href="#5、Profile" class="headerlink" title="5、Profile"></a>5、Profile</h2><h3 id="1、多Profile文件"><a href="#1、多Profile文件" class="headerlink" title="1、多Profile文件"></a>1、多Profile文件</h3><p>我们在主配置文件编写的时候，文件名可以是   application-{profile}.properties&#x2F;yml</p><p>默认使用application.properties的配置；</p><h3 id="2、yml支持多文档块方式"><a href="#2、yml支持多文档块方式" class="headerlink" title="2、yml支持多文档块方式"></a>2、yml支持多文档块方式</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yml"><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">prod</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8083</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span><br><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8084</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">prod</span>  <span class="hljs-comment">#指定属于哪个环境</span><br></code></pre></td></tr></table></figure><h3 id="3、激活指定profile"><a href="#3、激活指定profile" class="headerlink" title="3、激活指定profile"></a>3、激活指定profile</h3><p>​1、在配置文件中指定  spring.profiles.active&#x3D;dev</p><p>​2、命令行：</p><p>​java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active&#x3D;dev；</p><p>​可以直接在测试的时候，配置传入命令行参数</p><p>​3、虚拟机参数；</p><p>​-Dspring.profiles.active&#x3D;dev</p><h2 id="6、配置文件加载位置"><a href="#6、配置文件加载位置" class="headerlink" title="6、配置文件加载位置"></a>6、配置文件加载位置</h2><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p><p>–file:.&#x2F;config&#x2F;(即：直接在项目目录下创建config目录)</p><p>–file:.&#x2F;(即：直接在项目目录下创建文件)</p><p>–classpath:&#x2F;config&#x2F;(即：直接在resource目录下创建config目录)</p><p>–classpath:&#x2F;</p><p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p><p>SpringBoot会从这四个位置全部加载主配置文件；<strong>互补配置</strong>；</p><p><img src="/images/springboot/928953-20190613113659461-117207878.png" alt="928953-20190613113659461-117207878"></p><p>&#x3D;&#x3D;我们还可以通过spring.config.location来改变默认的配置文件位置&#x3D;&#x3D;</p><p><strong>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；</strong></p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location&#x3D;G:&#x2F;application.properties</p><h2 id="7、外部配置加载顺序"><a href="#7、外部配置加载顺序" class="headerlink" title="7、外部配置加载顺序"></a>7、外部配置加载顺序</h2><p><strong>&#x3D;&#x3D;SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置&#x3D;&#x3D;</strong></p><p><strong>1.命令行参数</strong></p><p>所有的配置都可以在命令行上进行指定</p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port&#x3D;8087  –server.servlet.context-path&#x3D;&#x2F;abc</p><p><strong>注意</strong>：springboot2之后已经弃用<code>server.context-path</code>，而是使用<code>server.servlet.context-path</code>。</p><p>多个配置用空格分开； –配置项&#x3D;值</p><p>2.来自java:comp&#x2F;env的JNDI属性</p><p>3.Java系统属性（System.getProperties()）</p><p>4.操作系统环境变量</p><p>5.RandomValuePropertySource配置的random.*属性值</p><p>&#x3D;&#x3D;<strong>由jar包外向jar包内进行寻找；</strong>&#x3D;&#x3D;</p><p>&#x3D;&#x3D;<strong>优先加载带profile</strong>&#x3D;&#x3D;</p><p><strong>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p><strong>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p>&#x3D;&#x3D;<strong>再来加载不带profile</strong>&#x3D;&#x3D;</p><p><strong>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p><strong>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p>10.@Configuration注解类上的@PropertySource</p><p>11.通过SpringApplication.setDefaultProperties指定的默认属性</p><p>所有支持的配置加载来源；</p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config">参考官方文档</a></p><h2 id="8、自动配置原理"><a href="#8、自动配置原理" class="headerlink" title="8、自动配置原理"></a>8、自动配置原理</h2><p>配置文件到底能写什么？怎么写？自动配置原理；</p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties">配置文件能配置的属性参照</a></p><h3 id="1、自动配置原理："><a href="#1、自动配置原理：" class="headerlink" title="1、自动配置原理："></a>1、<strong>自动配置原理：</strong></h3><p>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 &#x3D;&#x3D;@EnableAutoConfiguration&#x3D;&#x3D;</p><p><strong>2）、@EnableAutoConfiguration 作用：</strong></p><ul><li><p>利用EnableAutoConfigurationImportSelector给容器中导入一些组件？</p></li><li><p>可以查看selectImports()方法的内容；</p></li><li><p>selectImports()中的getAutoConfigurationEntry()方法；</p></li><li><p>List<String> configurations &#x3D; getCandidateConfigurations(annotationMetadata,      attributes);获取候选的配置</p><ul><li><p>&#96;&#96;&#96;java<br>SpringFactoriesLoader.loadFactoryNames()<br>扫描所有jar包类路径下  META-INF&#x2F;spring.factories<br>把扫描到的这些文件的内容包装成properties对象<br>从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><br>    <br><br>**==将 类路径下  META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；==**<br><br>```properties<br># Auto Configure<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.EnableAutoConfiguration=\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.admin.SpringApplicationAdminJmxAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.aop.AopAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.amqp.RabbitAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.batch.BatchAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.cache.CacheAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.cassandra.CassandraAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.cloud.CloudAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.context.ConfigurationPropertiesAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.context.MessageSourceAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.context.PropertyPlaceholderAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.couchbase.CouchbaseAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.dao.PersistenceExceptionTranslationAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.cassandra.CassandraDataAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.cassandra.CassandraRepositoriesAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.couchbase.CouchbaseDataAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.elasticsearch.ElasticsearchAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.jpa.JpaRepositoriesAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.ldap.LdapDataAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.ldap.LdapRepositoriesAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.mongo.MongoDataAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.mongo.MongoRepositoriesAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.neo4j.Neo4jDataAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.solr.SolrRepositoriesAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.redis.RedisAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.redis.RedisRepositoriesAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.rest.RepositoryRestMvcAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.web.SpringDataWebAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.elasticsearch.jest.JestAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.freemarker.FreeMarkerAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.gson.GsonAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.h2.H2ConsoleAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.hateoas.HypermediaAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.hazelcast.HazelcastAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.info.ProjectInfoAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.<span class="hljs-built_in">int</span>egration.IntegrationAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.jackson.JacksonAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.jdbc.DataSourceAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.jdbc.JdbcTemplateAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.jdbc.JndiDataSourceAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.jdbc.XADataSourceAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.jdbc.DataSourceTransactionManagerAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.jms.JmsAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.jmx.JmxAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.jms.JndiConnectionFactoryAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.jms.activemq.ActiveMQAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.jms.artemis.ArtemisAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.flyway.FlywayAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.groovy.template.GroovyTemplateAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.jersey.JerseyAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.jooq.JooqAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.kafka.KafkaAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.ldap.embedded.EmbeddedLdapAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.ldap.LdapAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.liquibase.LiquibaseAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.mail.MailSenderAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.mail.MailSenderValidatorAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.mobile.DeviceResolverAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.mobile.SitePreferenceAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.mongo.embedded.EmbeddedMongoAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.mongo.MongoAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.mustache.MustacheAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.orm.jpa.HibernateJpaAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.reactor.ReactorAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.security.SecurityAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.security.SecurityFilterAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.security.FallbackWebSecurityAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.security.oauth2.OAuth2AutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.sendgrid.SendGridAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.session.SessionAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.social.SocialWebAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.social.FacebookAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.social.LinkedInAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.social.TwitterAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.solr.SolrAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.thymeleaf.ThymeleafAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.transaction.TransactionAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.transaction.jta.JtaAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.validation.ValidationAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.web.DispatcherServletAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.web.EmbeddedServletContainerAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.web.ErrorMvcAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.web.HttpEncodingAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.web.HttpMessageConvertersAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.web.MultipartAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.web.ServerPropertiesAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.web.WebClientAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.web.WebMvcAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.websocket.WebSocketAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.websocket.WebSocketMessagingAutoConfiguration,\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.webservices.WebServicesAutoConfiguration<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p><p>3）、每一个自动配置类进行自动配置功能；</p><p>4）、以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>   <span class="hljs-comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span><br><span class="hljs-meta">@EnableConfigurationProperties(HttpEncodingProperties.class)</span>  <span class="hljs-comment">//启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中</span><br><br><span class="hljs-meta">@ConditionalOnWebApplication</span> <span class="hljs-comment">//Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是web应用，如果是，当前配置类生效</span><br><br><span class="hljs-meta">@ConditionalOnClass(CharacterEncodingFilter.class)</span>  <span class="hljs-comment">//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</span><br><br><span class="hljs-meta">@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true)</span>  <span class="hljs-comment">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span><br><span class="hljs-comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpEncodingAutoConfiguration</span> &#123;<br>  <br>  <span class="hljs-comment">//他已经和SpringBoot的配置文件映射了</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HttpEncodingProperties properties;<br>  <br>   <span class="hljs-comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">HttpEncodingAutoConfiguration</span><span class="hljs-params">(HttpEncodingProperties properties)</span> &#123;<br><span class="hljs-built_in">this</span>.properties = properties;<br>&#125;<br>  <br>    <span class="hljs-meta">@Bean</span>   <span class="hljs-comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span><br><span class="hljs-meta">@ConditionalOnMissingBean(CharacterEncodingFilter.class)</span> <span class="hljs-comment">//判断容器没有这个组件？</span><br><span class="hljs-keyword">public</span> CharacterEncodingFilter <span class="hljs-title function_">characterEncodingFilter</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">CharacterEncodingFilter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderedCharacterEncodingFilter</span>();<br>filter.setEncoding(<span class="hljs-built_in">this</span>.properties.getCharset().name());<br>filter.setForceRequestEncoding(<span class="hljs-built_in">this</span>.properties.shouldForce(Type.REQUEST));<br>filter.setForceResponseEncoding(<span class="hljs-built_in">this</span>.properties.shouldForce(Type.RESPONSE));<br><span class="hljs-keyword">return</span> filter;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据当前不同的条件判断，决定这个配置类是否生效？</p><p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p><p>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;)</span>  <span class="hljs-comment">//从配置文件中获取指定的值和bean的属性进行绑定</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpEncodingProperties</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Charset</span> <span class="hljs-variable">DEFAULT_CHARSET</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>精髓：</strong></p><p>​<strong>1）、SpringBoot启动会加载大量的自动配置类</strong></p><p>​<strong>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；</strong></p><p>​<strong>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</strong></p><p>​<strong>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</strong></p><p>xxxxAutoConfigurartion：自动配置类；</p><p>给容器中添加组件</p><p>xxxxProperties:封装配置文件中相关属性；</p><h3 id="2、细节"><a href="#2、细节" class="headerlink" title="2、细节"></a>2、细节</h3><h4 id="1、-Conditional派生注解（Spring注解版原生的-Conditional作用）"><a href="#1、-Conditional派生注解（Spring注解版原生的-Conditional作用）" class="headerlink" title="1、@Conditional派生注解（Spring注解版原生的@Conditional作用）"></a>1、@Conditional派生注解（Spring注解版原生的@Conditional作用）</h4><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p><table><thead><tr><th>@Conditional扩展注解</th><th>作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中存在指定Bean；</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中不存在指定Bean；</td></tr><tr><td>@ConditionalOnExpression</td><td>满足SpEL表达式指定</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr></tbody></table><p><strong>自动配置类必须在一定的条件下才能生效；</strong></p><p>我们怎么知道哪些自动配置类生效；</p><p>**&#x3D;&#x3D;我们可以通过启用  debug&#x3D;true属性；来让控制台打印自动配置报告&#x3D;&#x3D;**，这样我们就可以很方便的知道哪些自动配置类生效；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">=========================<br>AUTO-<span class="hljs-type">CONFIGURATION</span> <span class="hljs-variable">REPORT</span><br><span class="hljs-operator">=</span>========================<br><br><br>Positive matches:（自动配置类启用的）<br>-----------------<br><br>   DispatcherServletAutoConfiguration matched:<br>      - <span class="hljs-meta">@ConditionalOnClass</span> found required class <span class="hljs-string">&#x27;org.springframework.web.servlet.DispatcherServlet&#x27;</span>; <span class="hljs-meta">@ConditionalOnMissingClass</span> did not find unwanted <span class="hljs-title function_">class</span> <span class="hljs-params">(OnClassCondition)</span><br>      - <span class="hljs-meta">@ConditionalOnWebApplication</span> (required) found <span class="hljs-title function_">StandardServletEnvironment</span> <span class="hljs-params">(OnWebApplicationCondition)</span><br>        <br>    <br>Negative matches:（没有启动，没有匹配成功的自动配置类）<br>-----------------<br><br>   ActiveMQAutoConfiguration:<br>      Did not match:<br>         - <span class="hljs-meta">@ConditionalOnClass</span> did not find required classes <span class="hljs-string">&#x27;javax.jms.ConnectionFactory&#x27;</span>, <span class="hljs-string">&#x27;org.apache.activemq.ActiveMQConnectionFactory&#x27;</span> (OnClassCondition)<br><br>   AopAutoConfiguration:<br>      Did not match:<br>         - <span class="hljs-meta">@ConditionalOnClass</span> did not find required classes <span class="hljs-string">&#x27;org.aspectj.lang.annotation.Aspect&#x27;</span>, <span class="hljs-string">&#x27;org.aspectj.lang.reflect.Advice&#x27;</span> (OnClassCondition)<br>        <br></code></pre></td></tr></table></figure><h1 id="三、日志"><a href="#三、日志" class="headerlink" title="三、日志"></a>三、日志</h1><h2 id="1、日志框架"><a href="#1、日志框架" class="headerlink" title="1、日志框架"></a>1、日志框架</h2><p> 小张；开发一个大型系统；</p><p>​1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？</p><p>​2、框架来记录系统的一些运行时信息；日志框架 ；  zhanglogging.jar；</p><p>​3、高大上的几个功能？异步模式？自动归档？xxxx？  zhanglogging-good.jar？</p><p>​4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；</p><p>​5、JDBC—数据库驱动；</p><p>​写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；</p><p>​给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；</p><p><strong>市面上的日志框架；</strong></p><p>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j….</p><table><thead><tr><th>日志门面  （日志的抽象层）</th><th>日志实现</th></tr></thead><tbody><tr><td><del>JCL（Jakarta  Commons Logging）</del>    SLF4j（Simple  Logging Facade for Java）    <strong><del>jboss-logging</del></strong></td><td>Log4j  JUL（java.util.logging）  Log4j2  <strong>Logback</strong></td></tr></tbody></table><p>左边选一个门面（抽象层）、右边来选一个实现；</p><p>日志门面：  SLF4J；</p><p>日志实现：Logback；</p><p>SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘</p><p>​<strong>&#x3D;&#x3D;SpringBoot选用 SLF4j和logback；&#x3D;&#x3D;</strong></p><h2 id="2、SLF4j使用"><a href="#2、SLF4j使用" class="headerlink" title="2、SLF4j使用"></a>2、SLF4j使用</h2><h3 id="1、如何在系统中使用SLF4j-https-www-slf4j-org"><a href="#1、如何在系统中使用SLF4j-https-www-slf4j-org" class="headerlink" title="1、如何在系统中使用SLF4j   https://www.slf4j.org"></a>1、如何在系统中使用SLF4j   <a href="https://www.slf4j.org/">https://www.slf4j.org</a></h3><p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</p><p>给系统里面导入slf4j的jar和  logback的实现jar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(HelloWorld.class);<br>    logger.info(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>图示；</p><p><img src="/images/springboot/concrete-bindings.png" alt="images/concrete-bindings.png"></p><p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志实现框架自己本身的配置文件；</strong></p><h3 id="2、遗留问题"><a href="#2、遗留问题" class="headerlink" title="2、遗留问题"></a>2、遗留问题</h3><p>a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx</p><p>统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？</p><p><img src="/images/springboot/legacy.png"></p><p><strong>如何让系统中所有的日志都统一到slf4j；</strong></p><p>&#x3D;&#x3D;1、将系统中其他日志框架先排除出去；&#x3D;&#x3D;</p><p>&#x3D;&#x3D;2、用中间包来替换原有的日志框架；&#x3D;&#x3D;</p><p>&#x3D;&#x3D;3、我们导入slf4j其他的实现&#x3D;&#x3D;</p><h2 id="3、SpringBoot日志关系"><a href="#3、SpringBoot日志关系" class="headerlink" title="3、SpringBoot日志关系"></a>3、SpringBoot日志关系</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>SpringBoot使用它来做日志功能；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>底层依赖关系</p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180131220946.png"></p><p>总结：</p><p>​1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录</p><p>​2）、SpringBoot也把其他的日志都替换成了slf4j；</p><p>​3）、中间替换包？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogFactory</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j&quot;</span>;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">LogFactory</span> <span class="hljs-variable">logFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SLF4JLogFactory</span>();<br></code></pre></td></tr></table></figure><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180131221411.png"></p><p>​4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？</p><p>​Spring框架用的是commons-logging；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>&#x3D;&#x3D;SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；&#x3D;&#x3D;</strong></p><h2 id="4、日志使用；"><a href="#4、日志使用；" class="headerlink" title="4、日志使用；"></a>4、日志使用；</h2><h3 id="1、默认配置"><a href="#1、默认配置" class="headerlink" title="1、默认配置"></a>1、默认配置</h3><p>SpringBoot默认帮我们配置好了日志；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//记录器</span><br><span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(getClass());<br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//System.out.println();</span><br><br><span class="hljs-comment">//日志的级别；</span><br><span class="hljs-comment">//由低到高   trace&lt;debug&lt;info&lt;warn&lt;error</span><br><span class="hljs-comment">//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效</span><br>logger.trace(<span class="hljs-string">&quot;这是trace日志...&quot;</span>);<br>logger.debug(<span class="hljs-string">&quot;这是debug日志...&quot;</span>);<br><span class="hljs-comment">//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别</span><br>logger.info(<span class="hljs-string">&quot;这是info日志...&quot;</span>);<br>logger.warn(<span class="hljs-string">&quot;这是warn日志...&quot;</span>);<br>logger.error(<span class="hljs-string">&quot;这是error日志...&quot;</span>);<br><br><br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">    日志输出格式：        %d表示日期时间，        %thread表示线程名，        %-5level：级别从左显示5个字符宽度        %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。         %msg：日志消息，        %n是换行符    --&gt;    %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</code></pre><p>SpringBoot修改日志的默认配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">logging.level.com.atguigu</span>=<span class="hljs-string">trace</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#logging.path=</span><br><span class="hljs-comment"># 不指定路径在当前项目下生成springboot.log日志</span><br><span class="hljs-comment"># 可以指定完整的路径；</span><br><span class="hljs-comment">#logging.file=G:/springboot.log</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件</span><br><span class="hljs-attr">logging.path</span>=<span class="hljs-string">/spring/log</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#  在控制台输出的日志的格式</span><br><span class="hljs-attr">logging.pattern.console</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="hljs-comment"># 指定文件中日志输出的格式</span><br><span class="hljs-attr">logging.pattern.file</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>logging.file</th><th>logging.path</th><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>(none)</td><td>(none)</td><td></td><td>只在控制台输出</td></tr><tr><td>指定文件名</td><td>(none)</td><td>my.log</td><td>输出日志到my.log文件</td></tr><tr><td>(none)</td><td>指定目录</td><td>&#x2F;var&#x2F;log</td><td>输出到指定目录的 spring.log 文件中</td></tr></tbody></table><h3 id="2、指定配置"><a href="#2、指定配置" class="headerlink" title="2、指定配置"></a>2、指定配置</h3><p>给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了</p><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code> or <code>logback.groovy</code></td></tr><tr><td>Log4j2</td><td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td>JDK (Java Util Logging)</td><td><code>logging.properties</code></td></tr></tbody></table><p>logback.xml：直接就被日志框架识别了；</p><p><strong>logback-spring.xml</strong>：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;staging&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt;</span><br>  可以指定某段配置只在某个环境下生效<br><span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;stdout&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        日志输出格式：</span><br><span class="hljs-comment">%d表示日期时间，</span><br><span class="hljs-comment">%thread表示线程名，</span><br><span class="hljs-comment">%-5level：级别从左显示5个字符宽度</span><br><span class="hljs-comment">%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span><br><span class="hljs-comment">%msg：日志消息，</span><br><span class="hljs-comment">%n是换行符</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;!dev&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误</p><p> <code>no applicable action for [springProfile]</code></p><h2 id="5、切换日志框架"><a href="#5、切换日志框架" class="headerlink" title="5、切换日志框架"></a>5、切换日志框架</h2><p>可以按照slf4j的日志适配图，进行相关的切换；</p><p>slf4j+log4j的方式；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>切换为log4j2</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h1 id="四、Web开发"><a href="#四、Web开发" class="headerlink" title="四、Web开发"></a>四、Web开发</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>使用SpringBoot；</p><p><strong>1）、创建SpringBoot应用，选中我们需要的模块；</strong></p><p><strong>2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来</strong></p><p><strong>3）、自己编写业务代码；</strong></p><p><strong>自动配置原理？</strong></p><p>这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">xxxxAutoConfiguration：帮我们给容器中自动配置组件；<br><span class="hljs-symbol">xxxxProperties:</span>配置类来封装配置文件的内容；<br><br></code></pre></td></tr></table></figure><h2 id="2、SpringBoot对静态资源的映射规则；"><a href="#2、SpringBoot对静态资源的映射规则；" class="headerlink" title="2、SpringBoot对静态资源的映射规则；"></a>2、SpringBoot对静态资源的映射规则；</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceProperties</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ResourceLoaderAware</span> &#123;<br>  <span class="hljs-comment">//可以设置和静态资源有关的参数，缓存时间等</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java">WebMvcAuotConfiguration：<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.resourceProperties.isAddMappings()) &#123;<br>logger.debug(<span class="hljs-string">&quot;Default resource handling disabled&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">cachePeriod</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.resourceProperties.getCachePeriod();<br><span class="hljs-keyword">if</span> (!registry.hasMappingForPattern(<span class="hljs-string">&quot;/webjars/**&quot;</span>)) &#123;<br>customizeResourceHandlerRegistration(<br>registry.addResourceHandler(<span class="hljs-string">&quot;/webjars/**&quot;</span>)<br>.addResourceLocations(<br><span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>)<br>.setCachePeriod(cachePeriod));<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">staticPathPattern</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mvcProperties.getStaticPathPattern();<br>         <span class="hljs-comment">//静态资源文件夹映射</span><br><span class="hljs-keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;<br>customizeResourceHandlerRegistration(<br>registry.addResourceHandler(staticPathPattern)<br>.addResourceLocations(<br><span class="hljs-built_in">this</span>.resourceProperties.getStaticLocations())<br>.setCachePeriod(cachePeriod));<br>&#125;<br>&#125;<br><br>       <span class="hljs-comment">//配置欢迎页映射</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> WelcomePageHandlerMapping <span class="hljs-title function_">welcomePageHandlerMapping</span><span class="hljs-params">(</span><br><span class="hljs-params">ResourceProperties resourceProperties)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WelcomePageHandlerMapping</span>(resourceProperties.getWelcomePage(),<br><span class="hljs-built_in">this</span>.mvcProperties.getStaticPathPattern());<br>&#125;<br><br>      <span class="hljs-comment">//配置喜欢的图标</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnProperty(value = &quot;spring.mvc.favicon.enabled&quot;, matchIfMissing = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FaviconConfiguration</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ResourceProperties resourceProperties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FaviconConfiguration</span><span class="hljs-params">(ResourceProperties resourceProperties)</span> &#123;<br><span class="hljs-built_in">this</span>.resourceProperties = resourceProperties;<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> SimpleUrlHandlerMapping <span class="hljs-title function_">faviconHandlerMapping</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">SimpleUrlHandlerMapping</span> <span class="hljs-variable">mapping</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleUrlHandlerMapping</span>();<br>mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + <span class="hljs-number">1</span>);<br>             <span class="hljs-comment">//所有  **/favicon.ico </span><br>mapping.setUrlMap(Collections.singletonMap(<span class="hljs-string">&quot;**/favicon.ico&quot;</span>,<br>faviconRequestHandler()));<br><span class="hljs-keyword">return</span> mapping;<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> ResourceHttpRequestHandler <span class="hljs-title function_">faviconRequestHandler</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ResourceHttpRequestHandler</span> <span class="hljs-variable">requestHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceHttpRequestHandler</span>();<br>requestHandler<br>.setLocations(<span class="hljs-built_in">this</span>.resourceProperties.getFaviconLocations());<br><span class="hljs-keyword">return</span> requestHandler;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;1）、所有 &#x2F;webjars&#x2F;** ，都去 classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F; 找资源；&#x3D;&#x3D;</p><p>​webjars：以jar包的方式引入静态资源；</p><p><a href="http://www.webjars.org/">http://www.webjars.org/</a></p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180203181751.png"></p><p>localhost:8080&#x2F;webjars&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.js</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入jquery-webjar--&gt;</span>在访问的时候只需要写webjars下面资源的名称即可<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jquery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;2）、”&#x2F;**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射&#x3D;&#x3D;</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;classpath:/META-INF/resources/&quot;</span>, <br><span class="hljs-string">&quot;classpath:/resources/&quot;</span>,<br><span class="hljs-string">&quot;classpath:/static/&quot;</span>, <br><span class="hljs-string">&quot;classpath:/public/&quot;</span> <br><span class="hljs-string">&quot;/&quot;</span>：当前项目的根路径<br></code></pre></td></tr></table></figure><p>localhost:8080&#x2F;abc &#x3D;&#x3D;&#x3D;  去静态资源文件夹里面找abc</p><p>&#x3D;&#x3D;3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”&#x2F;**”映射；&#x3D;&#x3D;</p><p>​localhost:8080&#x2F;   找index页面</p><p>&#x3D;&#x3D;4）、所有的 **&#x2F;favicon.ico  都是在静态资源文件下找；&#x3D;&#x3D;</p><h2 id="3、模板引擎"><a href="#3、模板引擎" class="headerlink" title="3、模板引擎"></a>3、模板引擎</h2><p>JSP、Velocity、Freemarker、Thymeleaf</p><p><img src="/images/springboot/template-engine.png"></p><p>SpringBoot推荐的Thymeleaf；</p><p>语法更简单，功能更强大；</p><h3 id="1、引入thymeleaf；"><a href="#1、引入thymeleaf；" class="headerlink" title="1、引入thymeleaf；"></a>1、引入thymeleaf；</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          2.1.6<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>切换thymeleaf版本<br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">thymeleaf.version</span>&gt;</span>3.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">thymeleaf.version</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 --&gt;</span><br><span class="hljs-comment">&lt;!-- thymeleaf2   layout1--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">thymeleaf-layout-dialect.version</span>&gt;</span>2.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">thymeleaf-layout-dialect.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、Thymeleaf使用"><a href="#2、Thymeleaf使用" class="headerlink" title="2、Thymeleaf使用"></a>2、Thymeleaf使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThymeleafProperties</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Charset</span> <span class="hljs-variable">DEFAULT_ENCODING</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MimeType</span> <span class="hljs-variable">DEFAULT_CONTENT_TYPE</span> <span class="hljs-operator">=</span> MimeType.valueOf(<span class="hljs-string">&quot;text/html&quot;</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;classpath:/templates/&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.html&quot;</span>;<br>  <span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>只要我们把HTML页面放在classpath:&#x2F;templates&#x2F;，thymeleaf就能自动渲染；</p><p>使用：</p><p>1、导入thymeleaf的名称空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、使用thymeleaf语法；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>成功！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--th:text 将div里面的文本内容设置为 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;hello&#125;&quot;</span>&gt;</span>这是显示欢迎信息<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3、语法规则"><a href="#3、语法规则" class="headerlink" title="3、语法规则"></a>3、语法规则</h3><p>1）、th:text；改变当前元素里面的文本内容；</p><p>​th：任意html属性；来替换原生属性的值</p><p><img src="/images/springboot/2018-02-04_123955.png"></p><p>2）、表达式？</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">Simple</span> <span class="hljs-string">expressions:（表达式语法）</span><br>    <span class="hljs-attr">Variable</span> <span class="hljs-string">Expressions: $&#123;...&#125;：获取变量值；OGNL；</span><br>    <span class="hljs-attr">1）、获取对象的属性、调用方法</span><br>    <span class="hljs-attr">2）、使用内置的基本对象：</span><br><span class="hljs-comment">    #ctx : the context object.</span><br><span class="hljs-comment">    #vars: the context variables.</span><br><span class="hljs-comment">                #locale : the context locale.</span><br><span class="hljs-comment">                #request : (only in Web Contexts) the HttpServletRequest object.</span><br><span class="hljs-comment">                #response : (only in Web Contexts) the HttpServletResponse object.</span><br><span class="hljs-comment">                #session : (only in Web Contexts) the HttpSession object.</span><br><span class="hljs-comment">                #servletContext : (only in Web Contexts) the ServletContext object.</span><br>                <br>                <span class="hljs-attr">$&#123;session.foo&#125;</span><br>            <span class="hljs-attr">3）、内置的一些工具对象：</span><br><span class="hljs-comment">#execInfo : information about the template being processed.</span><br><span class="hljs-comment">#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.</span><br><span class="hljs-comment">#uris : methods for escaping parts of URLs/URIs</span><br><span class="hljs-comment">#conversions : methods for executing the configured conversion service (if any).</span><br><span class="hljs-comment">#dates : methods for java.util.Date objects: formatting, component extraction, etc.</span><br><span class="hljs-comment">#calendars : analogous to #dates , but for java.util.Calendar objects.</span><br><span class="hljs-comment">#numbers : methods for formatting numeric objects.</span><br><span class="hljs-comment">#strings : methods for String objects: contains, startsWith, prepending/appending, etc.</span><br><span class="hljs-comment">#objects : methods for objects in general.</span><br><span class="hljs-comment">#bools : methods for boolean evaluation.</span><br><span class="hljs-comment">#arrays : methods for arrays.</span><br><span class="hljs-comment">#lists : methods for lists.</span><br><span class="hljs-comment">#sets : methods for sets.</span><br><span class="hljs-comment">#maps : methods for maps.</span><br><span class="hljs-comment">#aggregates : methods for creating aggregates on arrays or collections.</span><br><span class="hljs-comment">#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).</span><br><br>    <span class="hljs-attr">Selection</span> <span class="hljs-string">Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样；</span><br>    <span class="hljs-attr">补充：配合</span> <span class="hljs-string">th:object=&quot;$&#123;session.user&#125;：</span><br>   <span class="hljs-attr">&lt;div</span> <span class="hljs-string">th:object=&quot;$&#123;session.user&#125;&quot;&gt;</span><br>    <span class="hljs-attr">&lt;p&gt;Name</span>: <span class="hljs-string">&lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;</span><br>    <span class="hljs-attr">&lt;p&gt;Surname</span>: <span class="hljs-string">&lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;</span><br>    <span class="hljs-attr">&lt;p&gt;Nationality</span>: <span class="hljs-string">&lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;</span><br>    <span class="hljs-attr">&lt;/div&gt;</span><br>    <br>    <span class="hljs-attr">Message</span> <span class="hljs-string">Expressions: #&#123;...&#125;：获取国际化内容</span><br>    <span class="hljs-attr">Link</span> <span class="hljs-string">URL Expressions: @&#123;...&#125;：定义URL；</span><br>    <span class="hljs-attr">@&#123;/order/process(execId</span>=<span class="hljs-string">$&#123;execId&#125;,execType=&#x27;FAST&#x27;)&#125;</span><br>    <span class="hljs-attr">Fragment</span> <span class="hljs-string">Expressions: ~&#123;...&#125;：片段引用表达式</span><br>    <span class="hljs-attr">&lt;div</span> <span class="hljs-string">th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt;</span><br>    <br><span class="hljs-attr">Literals（字面量）</span><br>      <span class="hljs-attr">Text</span> <span class="hljs-string">literals: &#x27;one text&#x27; , &#x27;Another one!&#x27; ,…</span><br>      <span class="hljs-attr">Number</span> <span class="hljs-string">literals: 0 , 34 , 3.0 , 12.3 ,…</span><br>      <span class="hljs-attr">Boolean</span> <span class="hljs-string">literals: true , false</span><br>      <span class="hljs-attr">Null</span> <span class="hljs-string">literal: null</span><br>      <span class="hljs-attr">Literal</span> <span class="hljs-string">tokens: one , sometext , main ,…</span><br><span class="hljs-attr">Text</span> <span class="hljs-string">operations:（文本操作）</span><br>    <span class="hljs-attr">String</span> <span class="hljs-string">concatenation: +</span><br>    <span class="hljs-attr">Literal</span> <span class="hljs-string">substitutions: |The name is $&#123;name&#125;|</span><br><span class="hljs-attr">Arithmetic</span> <span class="hljs-string">operations:（数学运算）</span><br>    <span class="hljs-attr">Binary</span> <span class="hljs-string">operators: + , - , * , / , %</span><br>    <span class="hljs-attr">Minus</span> <span class="hljs-string">sign (unary operator): -</span><br><span class="hljs-attr">Boolean</span> <span class="hljs-string">operations:（布尔运算）</span><br>    <span class="hljs-attr">Binary</span> <span class="hljs-string">operators: and , or</span><br>    <span class="hljs-attr">Boolean</span> <span class="hljs-string">negation (unary operator): ! , not</span><br><span class="hljs-attr">Comparisons</span> <span class="hljs-string">and equality:（比较运算）</span><br>    <span class="hljs-attr">Comparators</span>: <span class="hljs-string">&gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )</span><br>    <span class="hljs-attr">Equality</span> <span class="hljs-string">operators: == , != ( eq , ne )</span><br><span class="hljs-attr">Conditional</span> <span class="hljs-string">operators:条件运算（三元运算符）</span><br>    <span class="hljs-attr">If-then</span>: <span class="hljs-string">(if) ? (then)</span><br>    <span class="hljs-attr">If-then-else</span>: <span class="hljs-string">(if) ? (then) : (else)</span><br>    <span class="hljs-attr">Default</span>: <span class="hljs-string">(value) ?: (defaultvalue)</span><br><span class="hljs-attr">Special</span> <span class="hljs-string">tokens:</span><br>    <span class="hljs-attr">No-Operation</span>: <span class="hljs-string">_ </span><br></code></pre></td></tr></table></figure><h2 id="4、SpringMVC自动配置"><a href="#4、SpringMVC自动配置" class="headerlink" title="4、SpringMVC自动配置"></a>4、SpringMVC自动配置</h2><p><a href="https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications">https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications</a></p><h3 id="1-Spring-MVC-auto-configuration"><a href="#1-Spring-MVC-auto-configuration" class="headerlink" title="1. Spring MVC auto-configuration"></a>1. Spring MVC auto-configuration</h3><p>Spring Boot 自动配置好了SpringMVC</p><p>以下是SpringBoot对SpringMVC的默认配置:<strong>&#x3D;&#x3D;（WebMvcAutoConfiguration）&#x3D;&#x3D;</strong></p><ul><li><p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p><ul><li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））</li><li>ContentNegotiatingViewResolver：组合所有的视图解析器的；</li><li>&#x3D;&#x3D;如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；&#x3D;&#x3D;</li></ul></li><li><p>Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars</p></li><li><p>Static <code>index.html</code> support. 静态首页访问</p></li><li><p>Custom <code>Favicon</code> support (see below).  favicon.ico</p></li><li><p>自动注册了 of <code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans.</p><ul><li>Converter：转换器；  public String hello(User user)：类型转换使用Converter</li><li><code>Formatter</code>  格式化器；  2017.12.17&#x3D;&#x3D;&#x3D;Date；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date-format&quot;)</span><span class="hljs-comment">//在文件中配置日期格式化的规则</span><br><span class="hljs-keyword">public</span> Formatter&lt;Date&gt; <span class="hljs-title function_">dateFormatter</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DateFormatter</span>(<span class="hljs-built_in">this</span>.mvcProperties.getDateFormat());<span class="hljs-comment">//日期格式化组件</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​&#x3D;&#x3D;自己添加的格式化器转换器，我们只需要放在容器中即可&#x3D;&#x3D;</p><ul><li><p>Support for <code>HttpMessageConverters</code> (see below).</p><ul><li><p>HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json；</p></li><li><p><code>HttpMessageConverters</code> 是从容器中确定；获取所有的HttpMessageConverter；</p><p>&#x3D;&#x3D;自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）&#x3D;&#x3D;</p></li></ul></li><li><p>Automatic registration of <code>MessageCodesResolver</code> (see below).定义错误代码生成规则</p></li><li><p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (see below).</p><p>&#x3D;&#x3D;我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）&#x3D;&#x3D;</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">初始化WebDataBinder；<br>请求数据<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>JavaBean；<br></code></pre></td></tr></table></figure></li></ul><p><strong>org.springframework.boot.autoconfigure.web：web的所有自动场景；</strong></p><p>If you want to keep Spring Boot MVC features, and you just want to add additional <a href="https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc">MVC configuration</a> (interceptors, formatters, view controllers etc.) you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurerAdapter</code>, but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> or <code>ExceptionHandlerExceptionResolver</code> you can declare a <code>WebMvcRegistrationsAdapter</code> instance providing such components.</p><p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p><h3 id="2、扩展SpringMVC"><a href="#2、扩展SpringMVC" class="headerlink" title="2、扩展SpringMVC"></a>2、扩展SpringMVC</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/hello&quot;</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">&quot;success&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/hello&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>&#x3D;&#x3D;编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc&#x3D;&#x3D;</strong>;</p><p><strong>现在本地是2.x版本，已经没有了WebMvcConfigurerAdapter，实现WebMvcConfigurer即可</strong></p><p>既保留了所有的自动配置，也能用我们扩展的配置；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> &#123;<br>       <span class="hljs-comment">// super.addViewControllers(registry);</span><br>        <span class="hljs-comment">//浏览器发送 /atguigu 请求来到 success</span><br>        registry.addViewController(<span class="hljs-string">&quot;/atguigu&quot;</span>).setViewName(<span class="hljs-string">&quot;success&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原理：</p><p>​1）、WebMvcAutoConfiguration是SpringMVC的自动配置类</p><p>​2）、在做其他自动配置时会导入；@Import(<strong>EnableWebMvcConfiguration</strong>.class)<strong>2.2版本是作为WebMvcAutoConfiguration的内部类，且下边方法会在DelegatingWebMvcConfiguration实现，而不是EnableWebMvcConfiguration</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnableWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DelegatingWebMvcConfiguration</span> &#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">WebMvcConfigurerComposite</span> <span class="hljs-variable">configurers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebMvcConfigurerComposite</span>();<br><br> <span class="hljs-comment">//从容器中获取所有的WebMvcConfigurer</span><br>     <span class="hljs-meta">@Autowired(required = false)</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setConfigurers</span><span class="hljs-params">(List&lt;WebMvcConfigurer&gt; configurers)</span> &#123;<br>         <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;<br>             <span class="hljs-built_in">this</span>.configurers.addWebMvcConfigurers(configurers);<br>           <span class="hljs-comment">//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  </span><br>           <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">// public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br>             <span class="hljs-comment">//    for (WebMvcConfigurer delegate : this.delegates) &#123;</span><br>              <span class="hljs-comment">//       delegate.addViewControllers(registry);</span><br>              <span class="hljs-comment">//   &#125;</span><br>             &#125;<br>         &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​3）、容器中所有的WebMvcConfigurer都会一起起作用；</p><p>​4）、我们的配置类也会被调用；</p><p>​效果：SpringMVC的自动配置和我们的扩展配置都会起作用；</p><h3 id="3、全面接管SpringMVC；"><a href="#3、全面接管SpringMVC；" class="headerlink" title="3、全面接管SpringMVC；"></a>3、全面接管SpringMVC；</h3><p>SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了</p><p><strong>我们需要在配置类中添加@EnableWebMvc即可；</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span><br><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> &#123;<br>       <span class="hljs-comment">// super.addViewControllers(registry);</span><br>        <span class="hljs-comment">//浏览器发送 /atguigu 请求来到 success</span><br>        registry.addViewController(<span class="hljs-string">&quot;/atguigu&quot;</span>).setViewName(<span class="hljs-string">&quot;success&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：目前版本不推荐继承<code>WebMvcConfigurerAdapter</code>，推荐实现<code>WebMvcConfigurer</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span>&#123;<br>        registry.addViewController(<span class="hljs-string">&quot;/jie&quot;</span>).setViewName(<span class="hljs-string">&quot;success&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原理：</p><p>为什么@EnableWebMvc自动配置就失效了；</p><p>1）@EnableWebMvc的核心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(DelegatingWebMvcConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableWebMvc &#123;<br></code></pre></td></tr></table></figure><p>2）、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelegatingWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurationSupport</span> &#123;<br></code></pre></td></tr></table></figure><p>3）、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnWebApplication</span><br><span class="hljs-meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class,</span><br><span class="hljs-meta">WebMvcConfigurerAdapter.class &#125;)</span><br><span class="hljs-comment">//容器中没有这个组件的时候，这个自动配置类才生效</span><br><span class="hljs-meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span><br><span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span><br><span class="hljs-meta">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class,</span><br><span class="hljs-meta">ValidationAutoConfiguration.class &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcAutoConfiguration</span> &#123;<br></code></pre></td></tr></table></figure><p>4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；</p><p>5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；</p><h2 id="5、如何修改SpringBoot的默认配置"><a href="#5、如何修改SpringBoot的默认配置" class="headerlink" title="5、如何修改SpringBoot的默认配置"></a>5、如何修改SpringBoot的默认配置</h2><p>模式：</p><p>​1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；</p><p>​2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</p><p>​3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</p><h2 id="6、RestfulCRUD"><a href="#6、RestfulCRUD" class="headerlink" title="6、RestfulCRUD"></a>6、RestfulCRUD</h2><h3 id="1）、默认访问首页"><a href="#1）、默认访问首页" class="headerlink" title="1）、默认访问首页"></a>1）、默认访问首页</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span><br><span class="hljs-comment">//@EnableWebMvc   不要接管SpringMVC</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> &#123;<br>       <span class="hljs-comment">// super.addViewControllers(registry);</span><br>        <span class="hljs-comment">//浏览器发送 /atguigu 请求来到 success</span><br>        registry.addViewController(<span class="hljs-string">&quot;/atguigu&quot;</span>).setViewName(<span class="hljs-string">&quot;success&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//所有的WebMvcConfigurerAdapter组件都会一起起作用</span><br>    <span class="hljs-meta">@Bean</span> <span class="hljs-comment">//将组件注册在容器</span><br>    <span class="hljs-keyword">public</span> WebMvcConfigurerAdapter <span class="hljs-title function_">webMvcConfigurerAdapter</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">WebMvcConfigurerAdapter</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebMvcConfigurerAdapter</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> &#123;<br>                registry.addViewController(<span class="hljs-string">&quot;/&quot;</span>).setViewName(<span class="hljs-string">&quot;login&quot;</span>);<br>                registry.addViewController(<span class="hljs-string">&quot;/index.html&quot;</span>).setViewName(<span class="hljs-string">&quot;login&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> adapter;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2）、国际化"><a href="#2）、国际化" class="headerlink" title="2）、国际化"></a>2）、国际化</h3><p><strong>1）、编写国际化配置文件；</strong></p><p>2）、使用ResourceBundleMessageSource管理国际化资源文件</p><p>3）、在页面使用fmt:message取出国际化内容</p><p>步骤：</p><p>1）、编写国际化配置文件，抽取页面需要显示的国际化消息</p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180211130721.png"></p><p>2）、SpringBoot自动配置好了管理国际化资源文件的组件；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.messages&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageSourceAutoConfiguration</span> &#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Comma-separated list of basenames (essentially a fully-qualified classpath</span><br><span class="hljs-comment"> * location), each following the ResourceBundle convention with relaxed support for</span><br><span class="hljs-comment"> * slash based locations. If it doesn&#x27;t contain a package qualifier (such as</span><br><span class="hljs-comment"> * &quot;org.mypackage&quot;), it will be resolved from the classpath root.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">basename</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;messages&quot;</span>;  <br>    <span class="hljs-comment">//我们的配置文件可以直接放在类路径下叫messages.properties；</span><br>    <br>    <span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageSource <span class="hljs-title function_">messageSource</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ResourceBundleMessageSource</span> <span class="hljs-variable">messageSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceBundleMessageSource</span>();<br><span class="hljs-keyword">if</span> (StringUtils.hasText(<span class="hljs-built_in">this</span>.basename)) &#123;<br>            <span class="hljs-comment">//设置国际化资源文件的基础名（去掉语言国家代码的）</span><br>messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(<br>StringUtils.trimAllWhitespace(<span class="hljs-built_in">this</span>.basename)));<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.encoding != <span class="hljs-literal">null</span>) &#123;<br>messageSource.setDefaultEncoding(<span class="hljs-built_in">this</span>.encoding.name());<br>&#125;<br>messageSource.setFallbackToSystemLocale(<span class="hljs-built_in">this</span>.fallbackToSystemLocale);<br>messageSource.setCacheSeconds(<span class="hljs-built_in">this</span>.cacheSeconds);<br>messageSource.setAlwaysUseMessageFormat(<span class="hljs-built_in">this</span>.alwaysUseMessageFormat);<br><span class="hljs-keyword">return</span> messageSource;<br>&#125;<br></code></pre></td></tr></table></figure><p>3）、去页面获取国际化的值；</p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180211134506.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>  <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Signin Template for Bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Bootstrap core CSS --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;asserts/css/bootstrap.min.css&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Custom styles for this template --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;asserts/css/signin.css&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/asserts/css/signin.css&#125;&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-center&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-signin&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;dashboard.html&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mb-4&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/asserts/img/bootstrap-solid.svg&#125;&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;asserts/img/bootstrap-solid.svg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;72&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;72&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;h3 mb-3 font-weight-normal&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;login.tip&#125;&quot;</span>&gt;</span>Please sign in<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sr-only&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;login.username&#125;&quot;</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Username&quot;</span> <span class="hljs-attr">th:placeholder</span>=<span class="hljs-string">&quot;#&#123;login.username&#125;&quot;</span> <span class="hljs-attr">required</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">autofocus</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sr-only&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;login.password&#125;&quot;</span>&gt;</span>Password<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Password&quot;</span> <span class="hljs-attr">th:placeholder</span>=<span class="hljs-string">&quot;#&#123;login.password&#125;&quot;</span> <span class="hljs-attr">required</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;checkbox mb-3&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;remember-me&quot;</span>/&gt;</span> [[#&#123;login.remember&#125;]]<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-lg btn-primary btn-block&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;login.btn&#125;&quot;</span>&gt;</span>Sign in<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mt-5 mb-3 text-muted&quot;</span>&gt;</span>© 2017-2018<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-sm&quot;</span>&gt;</span>中文<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-sm&quot;</span>&gt;</span>English<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果：根据浏览器语言设置的信息切换了国际化；</p><p>原理：</p><p>​国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-meta">@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)</span><br><span class="hljs-keyword">public</span> LocaleResolver <span class="hljs-title function_">localeResolver</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.mvcProperties<br>.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FixedLocaleResolver</span>(<span class="hljs-built_in">this</span>.mvcProperties.getLocale());<br>&#125;<br><span class="hljs-type">AcceptHeaderLocaleResolver</span> <span class="hljs-variable">localeResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AcceptHeaderLocaleResolver</span>();<br>localeResolver.setDefaultLocale(<span class="hljs-built_in">this</span>.mvcProperties.getLocale());<br><span class="hljs-keyword">return</span> localeResolver;<br>&#125;<br>默认的就是根据请求头带来的区域信息获取Locale进行国际化<br></code></pre></td></tr></table></figure><p>4）、点击链接切换国际化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 可以在连接上携带区域信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLocaleResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LocaleResolver</span> &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Locale <span class="hljs-title function_">resolveLocale</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;l&quot;</span>);<br>        <span class="hljs-type">Locale</span> <span class="hljs-variable">locale</span> <span class="hljs-operator">=</span> Locale.getDefault();<br>        <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(l))&#123;<br>            String[] split = l.split(<span class="hljs-string">&quot;_&quot;</span>);<br>            locale = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Locale</span>(split[<span class="hljs-number">0</span>],split[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> locale;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLocale</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Locale locale)</span> &#123;<br><br>    &#125;<br>&#125;<br><br><br> <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> LocaleResolver <span class="hljs-title function_">localeResolver</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyLocaleResolver</span>();<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="3）、登陆"><a href="#3）、登陆" class="headerlink" title="3）、登陆"></a>3）、登陆</h3><p>开发期间模板引擎页面修改以后，要实时生效</p><p>1）、禁用模板引擎的缓存</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 禁用缓存</span><br><span class="hljs-attr">spring.thymeleaf.cache</span>=<span class="hljs-literal">false</span> <br></code></pre></td></tr></table></figure><p>2）、页面修改完成以后ctrl+f9：重新编译；</p><p>登陆错误消息的显示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;msg&#125;&quot;</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;not #strings.isEmpty(msg)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4）、拦截器进行登陆检查"><a href="#4）、拦截器进行登陆检查" class="headerlink" title="4）、拦截器进行登陆检查"></a>4）、拦截器进行登陆检查</h3><p>拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 登陆检查，</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginHandlerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-comment">//目标方法执行之前</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> request.getSession().getAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>);<br>        <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//未登陆，返回登陆页面</span><br>            request.setAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;没有权限请先登陆&quot;</span>);<br>            request.getRequestDispatcher(<span class="hljs-string">&quot;/index.html&quot;</span>).forward(request,response);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//已登陆，放行请求</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注册拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">//所有的WebMvcConfigurerAdapter组件都会一起起作用</span><br>    <span class="hljs-meta">@Bean</span> <span class="hljs-comment">//将组件注册在容器</span><br>    <span class="hljs-keyword">public</span> WebMvcConfigurerAdapter <span class="hljs-title function_">webMvcConfigurerAdapter</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">WebMvcConfigurerAdapter</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebMvcConfigurerAdapter</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> &#123;<br>                registry.addViewController(<span class="hljs-string">&quot;/&quot;</span>).setViewName(<span class="hljs-string">&quot;login&quot;</span>);<br>                registry.addViewController(<span class="hljs-string">&quot;/index.html&quot;</span>).setViewName(<span class="hljs-string">&quot;login&quot;</span>);<br>                registry.addViewController(<span class="hljs-string">&quot;/main.html&quot;</span>).setViewName(<span class="hljs-string">&quot;dashboard&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-comment">//注册拦截器</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>                <span class="hljs-comment">//super.addInterceptors(registry);</span><br>                <span class="hljs-comment">//静态资源；  *.css , *.js</span><br>                <span class="hljs-comment">//SpringBoot已经做好了静态资源映射</span><br>                registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginHandlerInterceptor</span>()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                        .excludePathPatterns(<span class="hljs-string">&quot;/index.html&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;/user/login&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> adapter;<br>    &#125;<br><br><span class="hljs-comment">//注意2.0之后静态资源也被屏蔽了，也会被拦截</span><br><span class="hljs-comment">//故应如下：</span><br><span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>                <span class="hljs-comment">//需注意静态资源也会被拦截。</span><br>                registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor</span>()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).excludePathPatterns(<span class="hljs-string">&quot;/index.html&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;/user/login&quot;</span>,<span class="hljs-string">&quot;/webjars/**&quot;</span>,<span class="hljs-string">&quot;/asserts/**&quot;</span>);<br>            &#125;<br></code></pre></td></tr></table></figure><h3 id="5）、CRUD-员工列表"><a href="#5）、CRUD-员工列表" class="headerlink" title="5）、CRUD-员工列表"></a>5）、CRUD-员工列表</h3><p>实验要求：</p><p>1）、RestfulCRUD：CRUD满足Rest风格；</p><p>URI：  &#x2F;资源名称&#x2F;资源标识       HTTP请求方式区分对资源CRUD操作</p><table><thead><tr><th></th><th>普通CRUD（uri来区分操作）</th><th>RestfulCRUD</th></tr></thead><tbody><tr><td>查询</td><td>getEmp</td><td>emp—GET</td></tr><tr><td>添加</td><td>addEmp?xxx</td><td>emp—POST</td></tr><tr><td>修改</td><td>updateEmp?id&#x3D;xxx&amp;xxx&#x3D;xx</td><td>emp&#x2F;{id}—PUT</td></tr><tr><td>删除</td><td>deleteEmp?id&#x3D;1</td><td>emp&#x2F;{id}—DELETE</td></tr></tbody></table><p>2）、实验的请求架构;</p><table><thead><tr><th>实验功能</th><th>请求URI</th><th>请求方式</th></tr></thead><tbody><tr><td>查询所有员工</td><td>emps</td><td>GET</td></tr><tr><td>查询某个员工(来到修改页面)</td><td>emp&#x2F;1</td><td>GET</td></tr><tr><td>来到添加页面</td><td>emp</td><td>GET</td></tr><tr><td>添加员工</td><td>emp</td><td>POST</td></tr><tr><td>来到修改页面（查出员工进行信息回显）</td><td>emp&#x2F;1</td><td>GET</td></tr><tr><td>修改员工</td><td>emp</td><td>PUT</td></tr><tr><td>删除员工</td><td>emp&#x2F;1</td><td>DELETE</td></tr></tbody></table><p>3）、员工列表：</p><h4 id="thymeleaf公共页面元素抽取"><a href="#thymeleaf公共页面元素抽取" class="headerlink" title="thymeleaf公共页面元素抽取"></a>thymeleaf公共页面元素抽取</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html">1、抽取公共片段<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;copy&quot;</span>&gt;</span><br><span class="hljs-symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>2、引入公共片段<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:insert</span>=<span class="hljs-string">&quot;~&#123;footer :: copy&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>~&#123;templatename::selector&#125;：模板名::选择器<br>~&#123;templatename::fragmentname&#125;:模板名::片段名<br><br>3、默认效果：<br>insert的公共片段在div标签中<br>如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：<br>行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]；<br></code></pre></td></tr></table></figure><p>三种引入公共片段的th属性：</p><p><strong>th:insert</strong>：将公共片段整个插入到声明引入的元素中</p><p><strong>th:replace</strong>：将声明引入的元素替换为公共片段</p><p><strong>th:include</strong>：将被引入的片段的内容包含进这个标签中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;copy&quot;</span>&gt;</span><br><span class="hljs-symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery<br><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><br>引入方式<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:insert</span>=<span class="hljs-string">&quot;footer :: copy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;footer :: copy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:include</span>=<span class="hljs-string">&quot;footer :: copy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>效果<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery<br><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>引入片段的时候传入参数： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><br><span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-md-2 d-none d-md-block bg-light sidebar&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sidebar&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sidebar-sticky&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav flex-column&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-item&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-link active&quot;</span></span><br><span class="hljs-tag">                   <span class="hljs-attr">th:class</span>=<span class="hljs-string">&quot;$&#123;activeUri==&#x27;main.html&#x27;?&#x27;nav-link active&#x27;:&#x27;nav-link&#x27;&#125;&quot;</span></span><br><span class="hljs-tag">                   <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/main.html&#125;&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;24&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;24&quot;</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">&quot;0 0 24 24&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;none&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;currentColor&quot;</span> <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">stroke-linecap</span>=<span class="hljs-string">&quot;round&quot;</span> <span class="hljs-attr">stroke-linejoin</span>=<span class="hljs-string">&quot;round&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;feather feather-home&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&quot;9 22 9 12 15 12 15 22&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">polyline</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>                    Dashboard <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sr-only&quot;</span>&gt;</span>(current)<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--引入侧边栏;传入参数--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;commons/bar::#sidebar(activeUri=&#x27;emps&#x27;)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6）、CRUD-员工添加"><a href="#6）、CRUD-员工添加" class="headerlink" title="6）、CRUD-员工添加"></a>6）、CRUD-员工添加</h3><p>添加页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>LastName<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;zhangsan&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;zhangsan@atguigu.com&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Gender<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-check form-check-inline&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-check-input&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-check-label&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-check form-check-inline&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-check-input&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-check-label&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>department<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Birth<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;zhangsan&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span>&gt;</span>添加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>提交的数据格式不对：生日：日期；</p><p>2017-12-12；2017&#x2F;12&#x2F;12；2017.12.12；</p><p>日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型;</p><p>2017-12-12—Date； 类型转换，格式化;</p><p>默认日期是按照&#x2F;的方式；</p><h3 id="7）、CRUD-员工修改"><a href="#7）、CRUD-员工修改" class="headerlink" title="7）、CRUD-员工修改"></a>7）、CRUD-员工修改</h3><p>修改添加二合一表单</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--需要区分是员工修改还是添加；--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/emp&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--发送put请求修改员工数据--&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）</span><br><span class="hljs-comment">2、页面创建一个post表单</span><br><span class="hljs-comment">3、创建一个input项，name=&quot;_method&quot;;值就是我们指定的请求方式</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;_method&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;put&quot;</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;emp!=null&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;emp!=null&#125;&quot;</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;emp.id&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>LastName<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lastName&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;zhangsan&quot;</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;zhangsan@atguigu.com&quot;</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;emp!=null&#125;?$&#123;emp.email&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Gender<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-check form-check-inline&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-check-input&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">th:checked</span>=<span class="hljs-string">&quot;$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-check-label&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-check form-check-inline&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-check-input&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">th:checked</span>=<span class="hljs-string">&quot;$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-check-label&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>department<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--提交的是部门的id--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;department.id&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">th:selected</span>=<span class="hljs-string">&quot;$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;&quot;</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;dept.id&#125;&quot;</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;dept:$&#123;depts&#125;&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;dept.departmentName&#125;&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Birth<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;birth&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;zhangsan&quot;</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, &#x27;yyyy-MM-dd HH:mm&#x27;)&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;emp!=null&#125;?&#x27;修改&#x27;:&#x27;添加&#x27;&quot;</span>&gt;</span>添加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="8）、CRUD-员工删除"><a href="#8）、CRUD-员工删除" class="headerlink" title="8）、CRUD-员工删除"></a>8）、CRUD-员工删除</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;emp:$&#123;emps&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;emp.id&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>[[$&#123;emp.lastName&#125;]]<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;emp.email&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;emp.gender&#125;==0?&#x27;女&#x27;:&#x27;男&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;emp.department.departmentName&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#dates.format(emp.birth, &#x27;yyyy-MM-dd HH:mm&#x27;)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-sm btn-primary&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/emp/&#125;+$&#123;emp.id&#125;&quot;</span>&gt;</span>编辑<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">th:attr</span>=<span class="hljs-string">&quot;del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-sm btn-danger deleteBtn&quot;</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    $(<span class="hljs-string">&quot;.deleteBtn&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-comment">//删除当前员工的</span></span><br><span class="language-javascript">        $(<span class="hljs-string">&quot;#deleteEmpForm&quot;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;action&quot;</span>,$(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;del_uri&quot;</span>)).<span class="hljs-title function_">submit</span>();</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="7、错误处理机制"><a href="#7、错误处理机制" class="headerlink" title="7、错误处理机制"></a>7、错误处理机制</h2><h3 id="1）、SpringBoot默认的错误处理机制"><a href="#1）、SpringBoot默认的错误处理机制" class="headerlink" title="1）、SpringBoot默认的错误处理机制"></a>1）、SpringBoot默认的错误处理机制</h3><p>默认效果：</p><p>​1）、浏览器，返回一个默认的错误页面</p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180226173408.png"></p><p>  浏览器发送请求的请求头：</p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180226180347.png"></p><p>​2）、如果是其他客户端，默认响应一个json数据</p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180226173527.png"></p><p>​<img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180226180504.png"></p><p>原理：</p><p>​可以参照ErrorMvcAutoConfiguration；错误处理的自动配置；</p><pre><code class="hljs">  给容器中添加了以下组件</code></pre><p>​1、DefaultErrorAttributes：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">帮我们在页面共享信息；<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">getErrorAttributes</span><span class="hljs-params">(RequestAttributes requestAttributes,</span><br><span class="hljs-params"><span class="hljs-type">boolean</span> includeStackTrace)</span> &#123;<br>Map&lt;String, Object&gt; errorAttributes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;String, Object&gt;();<br>errorAttributes.put(<span class="hljs-string">&quot;timestamp&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>addStatus(errorAttributes, requestAttributes);<br>addErrorDetails(errorAttributes, requestAttributes, includeStackTrace);<br>addPath(errorAttributes, requestAttributes);<br><span class="hljs-keyword">return</span> errorAttributes;<br>&#125;<br></code></pre></td></tr></table></figure><p>​2、BasicErrorController：处理默认&#x2F;error请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicErrorController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractErrorController</span> &#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(produces = &quot;text/html&quot;)</span><span class="hljs-comment">//产生html类型的数据；浏览器发送的请求来到这个方法处理</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">errorHtml</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">HttpServletResponse response)</span> &#123;<br><span class="hljs-type">HttpStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> getStatus(request);<br>Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(<br>request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));<br>response.setStatus(status.value());<br>        <br>        <span class="hljs-comment">//去哪个页面作为错误页面；包含页面地址和页面内容</span><br><span class="hljs-type">ModelAndView</span> <span class="hljs-variable">modelAndView</span> <span class="hljs-operator">=</span> resolveErrorView(request, response, status, model);<br><span class="hljs-keyword">return</span> (modelAndView == <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;error&quot;</span>, model) : modelAndView);<br>&#125;<br><br><span class="hljs-meta">@RequestMapping</span><br><span class="hljs-meta">@ResponseBody</span>    <span class="hljs-comment">//产生json数据，其他客户端来到这个方法处理；</span><br><span class="hljs-keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">error</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>Map&lt;String, Object&gt; body = getErrorAttributes(request,<br>isIncludeStackTrace(request, MediaType.ALL));<br><span class="hljs-type">HttpStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> getStatus(request);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;Map&lt;String, Object&gt;&gt;(body, status);<br>&#125;<br></code></pre></td></tr></table></figure><p>​3、ErrorPageCustomizer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;error.path:/error&#125;&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/error&quot;</span>;  系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则）<br></code></pre></td></tr></table></figure><p>​4、DefaultErrorViewResolver：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">resolveErrorView</span><span class="hljs-params">(HttpServletRequest request, HttpStatus status,</span><br><span class="hljs-params">Map&lt;String, Object&gt; model)</span> &#123;<br><span class="hljs-type">ModelAndView</span> <span class="hljs-variable">modelAndView</span> <span class="hljs-operator">=</span> resolve(String.valueOf(status), model);<br><span class="hljs-keyword">if</span> (modelAndView == <span class="hljs-literal">null</span> &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;<br>modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);<br>&#125;<br><span class="hljs-keyword">return</span> modelAndView;<br>&#125;<br><br><span class="hljs-keyword">private</span> ModelAndView <span class="hljs-title function_">resolve</span><span class="hljs-params">(String viewName, Map&lt;String, Object&gt; model)</span> &#123;<br>        <span class="hljs-comment">//默认SpringBoot可以去找到一个页面？  error/404</span><br><span class="hljs-type">String</span> <span class="hljs-variable">errorViewName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;error/&quot;</span> + viewName;<br>        <br>        <span class="hljs-comment">//模板引擎可以解析这个页面地址就用模板引擎解析</span><br><span class="hljs-type">TemplateAvailabilityProvider</span> <span class="hljs-variable">provider</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.templateAvailabilityProviders<br>.getProvider(errorViewName, <span class="hljs-built_in">this</span>.applicationContext);<br><span class="hljs-keyword">if</span> (provider != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//模板引擎可用的情况下返回到errorViewName指定的视图地址</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(errorViewName, model);<br>&#125;<br>        <span class="hljs-comment">//模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面   error/404.html</span><br><span class="hljs-keyword">return</span> resolveResource(errorViewName, model);<br>&#125;<br></code></pre></td></tr></table></figure><p>​步骤：</p><p>​一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到&#x2F;error请求；就会被<strong>BasicErrorController</strong>处理；</p><p>​1）响应页面；去哪个页面是由<strong>DefaultErrorViewResolver</strong>解析得到的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title function_">resolveErrorView</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">      HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model)</span> &#123;<br>    <span class="hljs-comment">//所有的ErrorViewResolver得到ModelAndView</span><br>   <span class="hljs-keyword">for</span> (ErrorViewResolver resolver : <span class="hljs-built_in">this</span>.errorViewResolvers) &#123;<br>      <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">modelAndView</span> <span class="hljs-operator">=</span> resolver.resolveErrorView(request, status, model);<br>      <span class="hljs-keyword">if</span> (modelAndView != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">return</span> modelAndView;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）、如果定制错误响应："><a href="#2）、如果定制错误响应：" class="headerlink" title="2）、如果定制错误响应："></a>2）、如果定制错误响应：</h3><h4 id="1）、如何定制错误的页面；"><a href="#1）、如何定制错误的页面；" class="headerlink" title="1）、如何定制错误的页面；"></a><strong>1）、如何定制错误的页面；</strong></h4><p>​<strong>1）、有模板引擎的情况下；error&#x2F;状态码;</strong> 【将错误页面命名为  错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到  对应的页面；</p><p>​我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）；</p><p>​页面能获取的信息；</p><p>​timestamp：时间戳</p><p>​status：状态码</p><p>​error：错误提示</p><p>​exception：异常对象</p><p>​message：异常消息</p><p>​errors：JSR303数据校验的错误都在这里</p><p>​2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找；</p><p>​3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面；</p><h4 id="2）、如何定制错误的json数据；"><a href="#2）、如何定制错误的json数据；" class="headerlink" title="2）、如何定制错误的json数据；"></a>2）、如何定制错误的json数据；</h4><p>​1）、自定义异常处理&amp;返回定制json数据；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyExceptionHandler</span> &#123;<br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@ExceptionHandler(UserNotExistException.class)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title function_">handleException</span><span class="hljs-params">(Exception e)</span>&#123;<br>        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;code&quot;</span>,<span class="hljs-string">&quot;user.notexist&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;message&quot;</span>,e.getMessage());<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//没有自适应效果...</span><br></code></pre></td></tr></table></figure><p>​2）、转发到&#x2F;error进行自适应响应效果处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler(UserNotExistException.class)</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">handleException</span><span class="hljs-params">(Exception e, HttpServletRequest request)</span>&#123;<br>       Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>       <span class="hljs-comment">//传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程</span><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * Integer statusCode = (Integer) request</span><br><span class="hljs-comment">        .getAttribute(&quot;javax.servlet.error.status_code&quot;);</span><br><span class="hljs-comment">        */</span><br>       request.setAttribute(<span class="hljs-string">&quot;javax.servlet.error.status_code&quot;</span>,<span class="hljs-number">500</span>);<br>       map.put(<span class="hljs-string">&quot;code&quot;</span>,<span class="hljs-string">&quot;user.notexist&quot;</span>);<br>       map.put(<span class="hljs-string">&quot;message&quot;</span>,e.getMessage());<br>       <span class="hljs-comment">//转发到/error</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/error&quot;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="3）、将我们的定制数据携带出去；"><a href="#3）、将我们的定制数据携带出去；" class="headerlink" title="3）、将我们的定制数据携带出去；"></a>3）、将我们的定制数据携带出去；</h4><p>出现错误以后，会来到&#x2F;error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）；</p><p>​1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中；</p><p>​2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到；</p><p>​容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的；</p><p>自定义ErrorAttributes</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//给容器中加入我们自己定义的ErrorAttributes</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyErrorAttributes</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultErrorAttributes</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">getErrorAttributes</span><span class="hljs-params">(RequestAttributes requestAttributes, <span class="hljs-type">boolean</span> includeStackTrace)</span> &#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-built_in">super</span>.getErrorAttributes(requestAttributes, includeStackTrace);<br>        map.put(<span class="hljs-string">&quot;company&quot;</span>,<span class="hljs-string">&quot;atguigu&quot;</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容，</p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180228135513.png"></p><h2 id="8、配置嵌入式Servlet容器"><a href="#8、配置嵌入式Servlet容器" class="headerlink" title="8、配置嵌入式Servlet容器"></a>8、配置嵌入式Servlet容器</h2><p>SpringBoot默认使用Tomcat作为嵌入式的Servlet容器；</p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180301142915.png"></p><p>问题？</p><h5 id="注意：springboot新版本已经舍弃了EmbeddedServletContainerCustomizer，推荐使用"><a href="#注意：springboot新版本已经舍弃了EmbeddedServletContainerCustomizer，推荐使用" class="headerlink" title="注意：springboot新版本已经舍弃了EmbeddedServletContainerCustomizer，推荐使用"></a><strong>注意：</strong>springboot新版本已经舍弃了EmbeddedServletContainerCustomizer，推荐使用</h5><h3 id="1）、如何定制和修改Servlet容器的相关配置；"><a href="#1）、如何定制和修改Servlet容器的相关配置；" class="headerlink" title="1）、如何定制和修改Servlet容器的相关配置；"></a>1）、如何定制和修改Servlet容器的相关配置；</h3><p>1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）；</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8081</span><br><span class="hljs-attr">server.context-path</span>=<span class="hljs-string">/crud</span><br><br><span class="hljs-attr">server.tomcat.uri-encoding</span>=<span class="hljs-string">UTF-8</span><br><br><span class="hljs-attr">//通用的Servlet容器设置</span><br><span class="hljs-attr">server.xxx</span><br><span class="hljs-attr">//Tomcat的设置</span><br><span class="hljs-attr">server.tomcat.xxx</span><br></code></pre></td></tr></table></figure><p>2、编写一个<strong>EmbeddedServletContainerCustomizer</strong>：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>  <span class="hljs-comment">//一定要将这个定制器加入到容器中</span><br><span class="hljs-keyword">public</span> EmbeddedServletContainerCustomizer <span class="hljs-title function_">embeddedServletContainerCustomizer</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmbeddedServletContainerCustomizer</span>() &#123;<br><br>        <span class="hljs-comment">//定制嵌入式的Servlet容器相关的规则</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customize</span><span class="hljs-params">(ConfigurableEmbeddedServletContainer container)</span> &#123;<br>            container.setPort(<span class="hljs-number">8083</span>);<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）、注册Servlet三大组件【Servlet、Filter、Listener】"><a href="#2）、注册Servlet三大组件【Servlet、Filter、Listener】" class="headerlink" title="2）、注册Servlet三大组件【Servlet、Filter、Listener】"></a>2）、注册Servlet三大组件【Servlet、Filter、Listener】</h3><p>由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。</p><p>注册三大组件用以下方式</p><p>ServletRegistrationBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注册三大组件</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title function_">myServlet</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ServletRegistrationBean</span> <span class="hljs-variable">registrationBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletRegistrationBean</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServlet</span>(),<span class="hljs-string">&quot;/myServlet&quot;</span>);<br>    <span class="hljs-keyword">return</span> registrationBean;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>FilterRegistrationBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title function_">myFilter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">FilterRegistrationBean</span> <span class="hljs-variable">registrationBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterRegistrationBean</span>();<br>    registrationBean.setFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFilter</span>());<br>    registrationBean.setUrlPatterns(Arrays.asList(<span class="hljs-string">&quot;/hello&quot;</span>,<span class="hljs-string">&quot;/myServlet&quot;</span>));<br>    <span class="hljs-keyword">return</span> registrationBean;<br>&#125;<br></code></pre></td></tr></table></figure><p>ServletListenerRegistrationBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> ServletListenerRegistrationBean <span class="hljs-title function_">myListener</span><span class="hljs-params">()</span>&#123;<br>    ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletListenerRegistrationBean</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyListener</span>());<br>    <span class="hljs-keyword">return</span> registrationBean;<br>&#125;<br></code></pre></td></tr></table></figure><p>SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet；</p><p>DispatcherServletAutoConfiguration中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)</span><br><span class="hljs-meta">@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span><br><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title function_">dispatcherServletRegistration</span><span class="hljs-params">(</span><br><span class="hljs-params">      DispatcherServlet dispatcherServlet)</span> &#123;<br>   <span class="hljs-type">ServletRegistrationBean</span> <span class="hljs-variable">registration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletRegistrationBean</span>(<br>         dispatcherServlet, <span class="hljs-built_in">this</span>.serverProperties.getServletMapping());<br>    <span class="hljs-comment">//默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp</span><br>    <span class="hljs-comment">//可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径</span><br>    <br>   registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);<br>   registration.setLoadOnStartup(<br>         <span class="hljs-built_in">this</span>.webMvcProperties.getServlet().getLoadOnStartup());<br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.multipartConfig != <span class="hljs-literal">null</span>) &#123;<br>      registration.setMultipartConfig(<span class="hljs-built_in">this</span>.multipartConfig);<br>   &#125;<br>   <span class="hljs-keyword">return</span> registration;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2）、SpringBoot能不能支持其他的Servlet容器；</p><h3 id="3）、替换为其他嵌入式Servlet容器"><a href="#3）、替换为其他嵌入式Servlet容器" class="headerlink" title="3）、替换为其他嵌入式Servlet容器"></a>3）、替换为其他嵌入式Servlet容器</h3><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302114401.png"></p><p>默认支持：</p><p>Tomcat（默认使用）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Jetty</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入web模块 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--引入其他的Servlet容器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Undertow</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入web模块 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--引入其他的Servlet容器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4）、嵌入式Servlet容器自动配置原理；"><a href="#4）、嵌入式Servlet容器自动配置原理；" class="headerlink" title="4）、嵌入式Servlet容器自动配置原理；"></a>4）、嵌入式Servlet容器自动配置原理；</h3><p>EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnWebApplication</span><br><span class="hljs-meta">@Import(BeanPostProcessorsRegistrar.class)</span><br><span class="hljs-comment">//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件</span><br><span class="hljs-comment">//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：</span><br><span class="hljs-comment">//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmbeddedServletContainerAutoConfiguration</span> &#123;<br>    <br>    <span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)</span><span class="hljs-comment">//判断当前是否引入了Tomcat依赖；</span><br><span class="hljs-meta">@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)</span><span class="hljs-comment">//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmbeddedTomcat</span> &#123;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> TomcatEmbeddedServletContainerFactory <span class="hljs-title function_">tomcatEmbeddedServletContainerFactory</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TomcatEmbeddedServletContainerFactory</span>();<br>&#125;<br><br>&#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Nested configuration if Jetty is being used.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class,</span><br><span class="hljs-meta">WebAppContext.class &#125;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmbeddedJetty</span> &#123;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> JettyEmbeddedServletContainerFactory <span class="hljs-title function_">jettyEmbeddedServletContainerFactory</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JettyEmbeddedServletContainerFactory</span>();<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Nested configuration if Undertow is being used.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmbeddedUndertow</span> &#123;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> UndertowEmbeddedServletContainerFactory <span class="hljs-title function_">undertowEmbeddedServletContainerFactory</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndertowEmbeddedServletContainerFactory</span>();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmbeddedServletContainerFactory</span> &#123;<br><br>   <span class="hljs-comment">//获取嵌入式的Servlet容器</span><br>   EmbeddedServletContainer <span class="hljs-title function_">getEmbeddedServletContainer</span><span class="hljs-params">(</span><br><span class="hljs-params">         ServletContextInitializer... initializers)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302144835.png"></p><p>2）、EmbeddedServletContainer：（嵌入式的Servlet容器）</p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302144910.png"></p><p>3）、以<strong>TomcatEmbeddedServletContainerFactory</strong>为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> EmbeddedServletContainer <span class="hljs-title function_">getEmbeddedServletContainer</span><span class="hljs-params">(</span><br><span class="hljs-params">      ServletContextInitializer... initializers)</span> &#123;<br>    <span class="hljs-comment">//创建一个Tomcat</span><br>   <span class="hljs-type">Tomcat</span> <span class="hljs-variable">tomcat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tomcat</span>();<br>    <br>    <span class="hljs-comment">//配置Tomcat的基本环节</span><br>   <span class="hljs-type">File</span> <span class="hljs-variable">baseDir</span> <span class="hljs-operator">=</span> (<span class="hljs-built_in">this</span>.baseDirectory != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">this</span>.baseDirectory<br>         : createTempDir(<span class="hljs-string">&quot;tomcat&quot;</span>));<br>   tomcat.setBaseDir(baseDir.getAbsolutePath());<br>   <span class="hljs-type">Connector</span> <span class="hljs-variable">connector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Connector</span>(<span class="hljs-built_in">this</span>.protocol);<br>   tomcat.getService().addConnector(connector);<br>   customizeConnector(connector);<br>   tomcat.setConnector(connector);<br>   tomcat.getHost().setAutoDeploy(<span class="hljs-literal">false</span>);<br>   configureEngine(tomcat.getEngine());<br>   <span class="hljs-keyword">for</span> (Connector additionalConnector : <span class="hljs-built_in">this</span>.additionalTomcatConnectors) &#123;<br>      tomcat.getService().addConnector(additionalConnector);<br>   &#125;<br>   prepareContext(tomcat.getHost(), initializers);<br>    <br>    <span class="hljs-comment">//将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器</span><br>   <span class="hljs-keyword">return</span> getTomcatEmbeddedServletContainer(tomcat);<br>&#125;<br></code></pre></td></tr></table></figure><p>4）、我们对嵌入式容器的配置修改是怎么生效？</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">ServerProperties、EmbeddedServletContainerCustomizer<br></code></pre></td></tr></table></figure><p><strong>EmbeddedServletContainerCustomizer</strong>：定制器帮我们修改了Servlet容器的配置？</p><p>怎么修改的原理？</p><p>5）、容器中导入了<strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始化之前</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span><br>      <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-comment">//如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件</span><br>   <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ConfigurableEmbeddedServletContainer) &#123;<br>       <span class="hljs-comment">//</span><br>      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);<br>   &#125;<br>   <span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(</span><br><span class="hljs-params">ConfigurableEmbeddedServletContainer bean)</span> &#123;<br>    <span class="hljs-comment">//获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；</span><br>    <span class="hljs-keyword">for</span> (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123;<br>        customizer.customize(bean);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Collection&lt;EmbeddedServletContainerCustomizer&gt; <span class="hljs-title function_">getCustomizers</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.customizers == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Look up does not include the parent context</span><br>        <span class="hljs-built_in">this</span>.customizers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;EmbeddedServletContainerCustomizer&gt;(<br>            <span class="hljs-built_in">this</span>.beanFactory<br>            <span class="hljs-comment">//从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer</span><br>            <span class="hljs-comment">//定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件</span><br>            .getBeansOfType(EmbeddedServletContainerCustomizer.class,<br>                            <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>)<br>            .values());<br>        Collections.sort(<span class="hljs-built_in">this</span>.customizers, AnnotationAwareOrderComparator.INSTANCE);<br>        <span class="hljs-built_in">this</span>.customizers = Collections.unmodifiableList(<span class="hljs-built_in">this</span>.customizers);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.customizers;<br>&#125;<br><br>ServerProperties也是定制器<br></code></pre></td></tr></table></figure><p>步骤：</p><p>1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</p><p>2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；</p><p>只要是嵌入式的Servlet容器工厂，后置处理器就工作；</p><p>3）、后置处理器，从容器中获取所有的<strong>EmbeddedServletContainerCustomizer</strong>，调用定制器的定制方法</p><p>###5）、嵌入式Servlet容器启动原理；</p><p>什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；</p><p>获取嵌入式的Servlet容器工厂：</p><p>1）、SpringBoot应用启动运行run方法</p><p>2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建<strong>AnnotationConfigEmbeddedWebApplicationContext</strong>，否则：<strong>AnnotationConfigApplicationContext</strong></p><p>3）、refresh(context);<strong>刷新刚才创建好的ioc容器；</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException &#123;<br>   <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.startupShutdownMonitor) &#123;<br>      <span class="hljs-comment">// Prepare this context for refreshing.</span><br>      prepareRefresh();<br><br>      <span class="hljs-comment">// Tell the subclass to refresh the internal bean factory.</span><br>      <span class="hljs-type">ConfigurableListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> obtainFreshBeanFactory();<br><br>      <span class="hljs-comment">// Prepare the bean factory for use in this context.</span><br>      prepareBeanFactory(beanFactory);<br><br>      <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span><br>         postProcessBeanFactory(beanFactory);<br><br>         <span class="hljs-comment">// Invoke factory processors registered as beans in the context.</span><br>         invokeBeanFactoryPostProcessors(beanFactory);<br><br>         <span class="hljs-comment">// Register bean processors that intercept bean creation.</span><br>         registerBeanPostProcessors(beanFactory);<br><br>         <span class="hljs-comment">// Initialize message source for this context.</span><br>         initMessageSource();<br><br>         <span class="hljs-comment">// Initialize event multicaster for this context.</span><br>         initApplicationEventMulticaster();<br><br>         <span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span><br>         onRefresh();<br><br>         <span class="hljs-comment">// Check for listener beans and register them.</span><br>         registerListeners();<br><br>         <span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span><br>         finishBeanFactoryInitialization(beanFactory);<br><br>         <span class="hljs-comment">// Last step: publish corresponding event.</span><br>         finishRefresh();<br>      &#125;<br><br>      <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>         <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>            logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - &quot;</span> +<br>                  <span class="hljs-string">&quot;cancelling refresh attempt: &quot;</span> + ex);<br>         &#125;<br><br>         <span class="hljs-comment">// Destroy already created singletons to avoid dangling resources.</span><br>         destroyBeans();<br><br>         <span class="hljs-comment">// Reset &#x27;active&#x27; flag.</span><br>         cancelRefresh(ex);<br><br>         <span class="hljs-comment">// Propagate exception to caller.</span><br>         <span class="hljs-keyword">throw</span> ex;<br>      &#125;<br><br>      <span class="hljs-keyword">finally</span> &#123;<br>         <span class="hljs-comment">// Reset common introspection caches in Spring&#x27;s core, since we</span><br>         <span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span><br>         resetCommonCaches();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4）、  onRefresh(); web的ioc容器重写了onRefresh方法</p><p>5）、webioc容器会创建嵌入式的Servlet容器；<strong>createEmbeddedServletContainer</strong>();</p><p><strong>6）、获取嵌入式的Servlet容器工厂：</strong></p><p>EmbeddedServletContainerFactory containerFactory &#x3D; getEmbeddedServletContainerFactory();</p><p>​从ioc容器中获取EmbeddedServletContainerFactory 组件；<strong>TomcatEmbeddedServletContainerFactory</strong>创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；</p><p>7）、<strong>使用容器工厂获取嵌入式的Servlet容器</strong>：this.embeddedServletContainer &#x3D; containerFactory      .getEmbeddedServletContainer(getSelfInitializer());</p><p>8）、嵌入式的Servlet容器创建对象并启动Servlet容器；</p><p><strong>先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来；</strong></p><p><strong>&#x3D;&#x3D;IOC容器启动创建嵌入式的Servlet容器&#x3D;&#x3D;</strong></p><h2 id="9、使用外置的Servlet容器"><a href="#9、使用外置的Servlet容器" class="headerlink" title="9、使用外置的Servlet容器"></a>9、使用外置的Servlet容器</h2><p>嵌入式Servlet容器：应用打成可执行的jar</p><p>​优点：简单、便携；</p><p>​缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）；</p><p>外置的Servlet容器：外面安装Tomcat—应用war包的方式打包；</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1）、必须创建一个war项目；（利用idea创建好目录结构）</p><p>2）、将嵌入式的Tomcat指定为provided；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3）、必须编写一个<strong>SpringBootServletInitializer</strong>的子类，并调用configure方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SpringBootServletInitializer</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title function_">configure</span><span class="hljs-params">(SpringApplicationBuilder application)</span> &#123;<br>       <span class="hljs-comment">//传入SpringBoot应用的主程序</span><br>      <span class="hljs-keyword">return</span> application.sources(SpringBoot04WebJspApplication.class);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>4）、启动服务器就可以使用；</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；</p><p>war包：启动服务器，<strong>服务器启动SpringBoot应用</strong>【SpringBootServletInitializer】，启动ioc容器；</p><p>servlet3.0（Spring注解版）：</p><p>8.2.4 Shared libraries &#x2F; runtimes pluggability：</p><p>规则：</p><p>​1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例：</p><p>​2）、ServletContainerInitializer的实现放在jar包的META-INF&#x2F;services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名</p><p>​3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；</p><p>流程：</p><p>1）、启动Tomcat</p><p>2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer：</p><p>Spring的web模块里面有这个文件：<strong>org.springframework.web.SpringServletContainerInitializer</strong></p><p>3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例；</p><p>4）、每一个WebApplicationInitializer都调用自己的onStartup；</p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302221835.png"></p><p>5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法</p><p>6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">createRootApplicationContext</span><span class="hljs-params">(</span><br><span class="hljs-params">      ServletContext servletContext)</span> &#123;<br>    <span class="hljs-comment">//1、创建SpringApplicationBuilder</span><br>   <span class="hljs-type">SpringApplicationBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> createSpringApplicationBuilder();<br>   <span class="hljs-type">StandardServletEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardServletEnvironment</span>();<br>   environment.initPropertySources(servletContext, <span class="hljs-literal">null</span>);<br>   builder.environment(environment);<br>   builder.main(getClass());<br>   <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> getExistingRootWebApplicationContext(servletContext);<br>   <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-built_in">this</span>.logger.info(<span class="hljs-string">&quot;Root context already created (using as parent).&quot;</span>);<br>      servletContext.setAttribute(<br>            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="hljs-literal">null</span>);<br>      builder.initializers(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentContextApplicationContextInitializer</span>(parent));<br>   &#125;<br>   builder.initializers(<br>         <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletContextApplicationContextInitializer</span>(servletContext));<br>   builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);<br>    <br>    <span class="hljs-comment">//调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来</span><br>   builder = configure(builder);<br>    <br>    <span class="hljs-comment">//使用builder创建一个Spring应用</span><br>   <span class="hljs-type">SpringApplication</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> builder.build();<br>   <span class="hljs-keyword">if</span> (application.getSources().isEmpty() &amp;&amp; AnnotationUtils<br>         .findAnnotation(getClass(), Configuration.class) != <span class="hljs-literal">null</span>) &#123;<br>      application.getSources().add(getClass());<br>   &#125;<br>   Assert.state(!application.getSources().isEmpty(),<br>         <span class="hljs-string">&quot;No SpringApplication sources have been defined. Either override the &quot;</span><br>               + <span class="hljs-string">&quot;configure method or add an @Configuration annotation&quot;</span>);<br>   <span class="hljs-comment">// Ensure error pages are registered</span><br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.registerErrorPageFilter) &#123;<br>      application.getSources().add(ErrorPageFilterConfiguration.class);<br>   &#125;<br>    <span class="hljs-comment">//启动Spring应用</span><br>   <span class="hljs-keyword">return</span> run(application);<br>&#125;<br></code></pre></td></tr></table></figure><p>7）、Spring的应用就启动并且创建IOC容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> &#123;<br>   <span class="hljs-type">StopWatch</span> <span class="hljs-variable">stopWatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>();<br>   stopWatch.start();<br>   <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>   <span class="hljs-type">FailureAnalyzers</span> <span class="hljs-variable">analyzers</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>   configureHeadlessProperty();<br>   <span class="hljs-type">SpringApplicationRunListeners</span> <span class="hljs-variable">listeners</span> <span class="hljs-operator">=</span> getRunListeners(args);<br>   listeners.starting();<br>   <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">ApplicationArguments</span> <span class="hljs-variable">applicationArguments</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultApplicationArguments</span>(<br>            args);<br>      <span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> prepareEnvironment(listeners,<br>            applicationArguments);<br>      <span class="hljs-type">Banner</span> <span class="hljs-variable">printedBanner</span> <span class="hljs-operator">=</span> printBanner(environment);<br>      context = createApplicationContext();<br>      analyzers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FailureAnalyzers</span>(context);<br>      prepareContext(context, environment, listeners, applicationArguments,<br>            printedBanner);<br>       <br>       <span class="hljs-comment">//刷新IOC容器</span><br>      refreshContext(context);<br>      afterRefresh(context, applicationArguments);<br>      listeners.finished(context, <span class="hljs-literal">null</span>);<br>      stopWatch.stop();<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logStartupInfo) &#123;<br>         <span class="hljs-keyword">new</span> <span class="hljs-title class_">StartupInfoLogger</span>(<span class="hljs-built_in">this</span>.mainApplicationClass)<br>               .logStarted(getApplicationLog(), stopWatch);<br>      &#125;<br>      <span class="hljs-keyword">return</span> context;<br>   &#125;<br>   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>      handleRunFailure(context, listeners, analyzers, ex);<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(ex);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>&#x3D;&#x3D;启动Servlet容器，再启动SpringBoot应用&#x3D;&#x3D;</strong></p><h1 id="五、Docker"><a href="#五、Docker" class="headerlink" title="五、Docker"></a>五、Docker</h1><h2 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h2><p><strong>Docker</strong>是一个开源的应用容器引擎；是一个轻量级容器技术；</p><p>Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；</p><p>运行中的这个镜像称为容器，容器启动是非常快速的。</p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180303145450.png"></p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180303145531.png"></p><h2 id="2、核心概念"><a href="#2、核心概念" class="headerlink" title="2、核心概念"></a>2、核心概念</h2><p>docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；</p><p>docker客户端(Client)：连接docker主机进行操作；</p><p>docker仓库(Registry)：用来保存各种打包好的软件镜像；</p><p>docker镜像(&#x2F;images&#x2F;springboot)：软件打包好的镜像；放在docker仓库中；</p><p>docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用</p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180303165113.png"></p><p>使用Docker的步骤：</p><p>1）、安装Docker</p><p>2）、去Docker仓库找到这个软件对应的镜像；</p><p>3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；</p><p>4）、对容器的启动停止就是对软件的启动停止；</p><h2 id="3、安装Docker"><a href="#3、安装Docker" class="headerlink" title="3、安装Docker"></a>3、安装Docker</h2><h4 id="1）、安装linux虚拟机"><a href="#1）、安装linux虚拟机" class="headerlink" title="1）、安装linux虚拟机"></a>1）、安装linux虚拟机</h4><p>​1）、VMWare、VirtualBox（安装）；</p><p>​2）、导入虚拟机文件centos7-atguigu.ova；</p><p>​3）、双击启动linux虚拟机;使用  root&#x2F; 123456登陆</p><p>​4）、使用客户端连接linux服务器进行命令操作；</p><p>​5）、设置虚拟机网络；</p><p>​桥接网络&#x3D;&#x3D;&#x3D;选好网卡&#x3D;&#x3D;&#x3D;&#x3D;接入网线；</p><p>​6）、设置好网络以后使用命令重启虚拟机的网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service network restart<br></code></pre></td></tr></table></figure><p>​7）、查看linux的ip地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip addr<br></code></pre></td></tr></table></figure><p>​8）、使用客户端连接linux；</p><h4 id="2）、在linux虚拟机上安装docker"><a href="#2）、在linux虚拟机上安装docker" class="headerlink" title="2）、在linux虚拟机上安装docker"></a>2）、在linux虚拟机上安装docker</h4><p>步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">1、检查内核版本，必须是3.10及以上<br>uname -r<br>2、安装docker<br>yum install docker<br>3、输入y确认安装<br>4、启动docker<br>[root@localhost ~]# systemctl start docker<br>[root@localhost ~]# docker -v<br>Docker version 1.12.6, build 3e8e77d/1.12.6<br>5、开机启动docker<br>[root@localhost ~]# systemctl enable docker<br>Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.<br>6、停止docker<br>systemctl stop docker<br></code></pre></td></tr></table></figure><h2 id="4、Docker常用命令-amp-操作"><a href="#4、Docker常用命令-amp-操作" class="headerlink" title="4、Docker常用命令&amp;操作"></a>4、Docker常用命令&amp;操作</h2><h3 id="1）、镜像操作"><a href="#1）、镜像操作" class="headerlink" title="1）、镜像操作"></a>1）、镜像操作</h3><table><thead><tr><th>操作</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>检索</td><td>docker  search 关键字  eg：docker  search redis</td><td>我们经常去docker  hub上检索镜像的详细信息，如镜像的TAG。</td></tr><tr><td>拉取</td><td>docker pull 镜像名:tag</td><td>:tag是可选的，tag表示标签，多为软件的版本，默认是latest</td></tr><tr><td>列表</td><td>docker images</td><td>查看所有本地镜像</td></tr><tr><td>删除</td><td>docker rmi image-id</td><td>删除指定的本地镜像</td></tr></tbody></table><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h3 id="2）、容器操作"><a href="#2）、容器操作" class="headerlink" title="2）、容器操作"></a>2）、容器操作</h3><p>软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）；</p><p>步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell">1、搜索镜像<br>[root@localhost ~]# docker search tomcat<br>2、拉取镜像<br>[root@localhost ~]# docker pull tomcat<br>3、根据镜像启动容器<br>docker run --name mytomcat -d tomcat:latest<br>4、docker ps  <br>查看运行中的容器<br>5、 停止运行中的容器<br>docker stop  容器的id<br>6、查看所有的容器<br>docker ps -a<br>7、启动容器<br>docker start 容器id<br>8、删除一个容器<br> docker rm 容器id<br>9、启动一个做了端口映射的tomcat<br>[root@localhost ~]# docker run -d -p 8888:8080 tomcat<br>-d：后台运行<br>-p: 将主机的端口映射到容器的一个端口    主机端口:容器内部的端口<br><br>10、为了演示简单关闭了linux的防火墙<br>service firewalld status ；查看防火墙状态<br>service firewalld stop：关闭防火墙<br>11、查看容器的日志<br>docker logs container-name/container-id<br><br>更多命令参看<br>https://docs.docker.com/engine/reference/commandline/docker/<br>可以参考每一个镜像的文档<br><br></code></pre></td></tr></table></figure><h3 id="3）、安装MySQL示例"><a href="#3）、安装MySQL示例" class="headerlink" title="3）、安装MySQL示例"></a>3）、安装MySQL示例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull mysql<br></code></pre></td></tr></table></figure><p>错误的启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run --name mysql01 -d mysql<br>42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846<br><br>mysql退出了<br>[root@localhost ~]# docker ps -a<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                           PORTS               NAMES<br>42f09819908b        mysql               &quot;docker-entrypoint.sh&quot;   34 seconds ago      Exited (1) 33 seconds ago                            mysql01<br>538bde63e500        tomcat              &quot;catalina.sh run&quot;        About an hour ago   Exited (143) About an hour ago                       compassionate_<br>goldstine<br>c4f1ac60b3fc        tomcat              &quot;catalina.sh run&quot;        About an hour ago   Exited (143) About an hour ago                       lonely_fermi<br>81ec743a5271        tomcat              &quot;catalina.sh run&quot;        About an hour ago   Exited (143) About an hour ago                       sick_ramanujan<br><br><br>//错误日志<br>[root@localhost ~]# docker logs 42f09819908b<br>error: database is uninitialized and password option is not specified <br>  You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个<br></code></pre></td></tr></table></figure><p>正确的启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql<br>b874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f<br>[root@localhost ~]# docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES<br>b874c56bec49        mysql               &quot;docker-entrypoint.sh&quot;   4 seconds ago       Up 3 seconds        3306/tcp            mysql01<br></code></pre></td></tr></table></figure><p>做了端口映射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql<br>ad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434<br>[root@localhost ~]# docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES<br>ad10e4bc5c6a        mysql               &quot;docker-entrypoint.sh&quot;   4 seconds ago       Up 2 seconds        0.0.0.0:3306-&gt;3306/tcp   mysql02<br></code></pre></td></tr></table></figure><p>几个其他的高级操作</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e <span class="hljs-attribute">MYSQL_ROOT_PASSWORD</span>=my-secret-pw -d mysql:tag<br>把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面<br>改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）<br><br>docker <span class="hljs-built_in">run</span> --name some-mysql -e <span class="hljs-attribute">MYSQL_ROOT_PASSWORD</span>=my-secret-pw -d mysql:tag <span class="hljs-attribute">--character-set-server</span>=utf8mb4 <span class="hljs-attribute">--collation-server</span>=utf8mb4_unicode_ci<br>指定mysql的一些配置参数<br></code></pre></td></tr></table></figure><h1 id="六、SpringBoot与数据访问"><a href="#六、SpringBoot与数据访问" class="headerlink" title="六、SpringBoot与数据访问"></a>六、SpringBoot与数据访问</h1><h2 id="1、JDBC"><a href="#1、JDBC" class="headerlink" title="1、JDBC"></a>1、JDBC</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://192.168.15.22:3306/jdbc</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br></code></pre></td></tr></table></figure><p>效果：</p><p>​默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；</p><p>​数据源的相关配置都在DataSourceProperties里面；</p><p>自动配置原理：</p><p>org.springframework.boot.autoconfigure.jdbc：</p><p>1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；</p><p>2、SpringBoot默认可以支持；</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.tomcat</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.pool</span>.DataSource、HikariDataSource、BasicDataSource、<br></code></pre></td></tr></table></figure><p>3、自定义数据源类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Generic DataSource configuration.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@ConditionalOnMissingBean(DataSource.class)</span><br><span class="hljs-meta">@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;)</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generic</span> &#123;<br><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">(DataSourceProperties properties)</span> &#123;<br>       <span class="hljs-comment">//使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性</span><br>      <span class="hljs-keyword">return</span> properties.initializeDataSourceBuilder().build();<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>4、<strong>DataSourceInitializer：ApplicationListener</strong>；</p><p>​作用：</p><p>​1）、runSchemaScripts();运行建表语句；</p><p>​2）、runDataScripts();运行插入数据的sql语句；</p><p>默认只需要将文件命名为：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">schema-*.sql、data-*.sql</span><br><span class="hljs-attr">默认规则：schema.sql，schema-all.sql；</span><br><span class="hljs-attr">可以使用</span>   <span class="hljs-string"></span><br><span class="hljs-attr">schema</span>:<span class="hljs-string"></span><br>      <span class="hljs-attr">-</span> <span class="hljs-string">classpath:department.sql</span><br>      <span class="hljs-attr">指定位置</span><br></code></pre></td></tr></table></figure><p>5、操作数据库：自动配置了JdbcTemplate操作数据库</p><h2 id="2、整合Druid数据源"><a href="#2、整合Druid数据源" class="headerlink" title="2、整合Druid数据源"></a>2、整合Druid数据源</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">导入druid数据源<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DruidConfig</span> &#123;<br><br>    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">druid</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//配置Druid的监控</span><br>    <span class="hljs-comment">//1、配置一个管理后台的Servlet</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title function_">statViewServlet</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ServletRegistrationBean</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletRegistrationBean</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StatViewServlet</span>(), <span class="hljs-string">&quot;/druid/*&quot;</span>);<br>        Map&lt;String,String&gt; initParams = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        initParams.put(<span class="hljs-string">&quot;loginUsername&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>);<br>        initParams.put(<span class="hljs-string">&quot;loginPassword&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br>        initParams.put(<span class="hljs-string">&quot;allow&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//默认就是允许所有访问</span><br>        initParams.put(<span class="hljs-string">&quot;deny&quot;</span>,<span class="hljs-string">&quot;192.168.15.21&quot;</span>);<br><br>        bean.setInitParameters(initParams);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br><br>    <span class="hljs-comment">//2、配置一个web监控的filter</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title function_">webStatFilter</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">FilterRegistrationBean</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterRegistrationBean</span>();<br>        bean.setFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WebStatFilter</span>());<br><br>        Map&lt;String,String&gt; initParams = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        initParams.put(<span class="hljs-string">&quot;exclusions&quot;</span>,<span class="hljs-string">&quot;*.js,*.css,/druid/*&quot;</span>);<br><br>        bean.setInitParameters(initParams);<br><br>        bean.setUrlPatterns(Arrays.asList(<span class="hljs-string">&quot;/*&quot;</span>));<br><br>        <span class="hljs-keyword">return</span>  bean;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3、整合MyBatis"><a href="#3、整合MyBatis" class="headerlink" title="3、整合MyBatis"></a>3、整合MyBatis</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180305194443.png"></p><p>步骤：</p><p>​1）、配置数据源相关属性（见上一节Druid）</p><p>​2）、给数据库建表</p><p>​3）、创建JavaBean</p><h3 id="4）、注解版"><a href="#4）、注解版" class="headerlink" title="4）、注解版"></a>4）、注解版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//指定这是一个操作数据库的mapper</span><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DepartmentMapper</span> &#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from department where id=#&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Department <span class="hljs-title function_">getDeptById</span><span class="hljs-params">(Integer id)</span>;<br><br>    <span class="hljs-meta">@Delete(&quot;delete from department where id=#&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteDeptById</span><span class="hljs-params">(Integer id)</span>;<br><br>    <span class="hljs-meta">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span><br>    <span class="hljs-meta">@Insert(&quot;insert into department(departmentName) values(#&#123;departmentName&#125;)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insertDept</span><span class="hljs-params">(Department department)</span>;<br><br>    <span class="hljs-meta">@Update(&quot;update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateDept</span><span class="hljs-params">(Department department)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：</p><p>自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.springframework.context.annotation.Configuration<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ConfigurationCustomizer <span class="hljs-title function_">configurationCustomizer</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigurationCustomizer</span>()&#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customize</span><span class="hljs-params">(Configuration configuration)</span> &#123;<br>                configuration.setMapUnderscoreToCamelCase(<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">使用MapperScan批量扫描所有的Mapper接口；<br><span class="hljs-meta">@MapperScan(value = &quot;com.atguigu.springboot.mapper&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBoot06DataMybatisApplication</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(SpringBoot06DataMybatisApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5）、配置文件版"><a href="#5）、配置文件版" class="headerlink" title="5）、配置文件版"></a>5）、配置文件版</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">config-location:</span> <span class="hljs-string">classpath:mybatis/mybatis-config.xml</span> <span class="hljs-string">指定全局配置文件的位置</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mybatis/mapper/*.xml</span>  <span class="hljs-string">指定sql映射文件的位置</span><br></code></pre></td></tr></table></figure><p>更多使用参照</p><p><a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></p><h2 id="4、整合SpringData-JPA"><a href="#4、整合SpringData-JPA" class="headerlink" title="4、整合SpringData JPA"></a>4、整合SpringData JPA</h2><h3 id="1）、SpringData简介"><a href="#1）、SpringData简介" class="headerlink" title="1）、SpringData简介"></a>1）、SpringData简介</h3><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180306105412.png"></p><h3 id="2）、整合SpringData-JPA"><a href="#2）、整合SpringData-JPA" class="headerlink" title="2）、整合SpringData JPA"></a>2）、整合SpringData JPA</h3><p>JPA:ORM（Object Relational Mapping）；</p><p>1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用JPA注解配置映射关系</span><br><span class="hljs-meta">@Entity</span> <span class="hljs-comment">//告诉JPA这是一个实体类（和数据表映射的类）</span><br><span class="hljs-meta">@Table(name = &quot;tbl_user&quot;)</span> <span class="hljs-comment">//@Table来指定和哪个数据表对应;如果省略默认表名就是user；</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-meta">@Id</span> <span class="hljs-comment">//这是一个主键</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><span class="hljs-comment">//自增主键</span><br>    <span class="hljs-keyword">private</span> Integer id;<br><br>    <span class="hljs-meta">@Column(name = &quot;last_name&quot;,length = 50)</span> <span class="hljs-comment">//这是和数据表对应的一个列</span><br>    <span class="hljs-keyword">private</span> String lastName;<br>    <span class="hljs-meta">@Column</span> <span class="hljs-comment">//省略默认列名就是属性名</span><br>    <span class="hljs-keyword">private</span> String email;<br></code></pre></td></tr></table></figure><p>2）、编写一个Dao接口来操作实体类对应的数据表（Repository）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//继承JpaRepository来完成对数据库的操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;User,Integer&gt; &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>3）、基本的配置JpaProperties</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <br> <span class="hljs-attr">jpa:</span><br>    <span class="hljs-attr">hibernate:</span><br><span class="hljs-comment">#     更新或者创建数据表结构</span><br>      <span class="hljs-attr">ddl-auto:</span> <span class="hljs-string">update</span><br><span class="hljs-comment">#    控制台显示SQL</span><br>    <span class="hljs-attr">show-sql:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h1 id="七、启动配置原理"><a href="#七、启动配置原理" class="headerlink" title="七、启动配置原理"></a>七、启动配置原理</h1><p>几个重要的事件回调机制</p><p>配置在META-INF&#x2F;spring.factories</p><p><strong>ApplicationContextInitializer</strong></p><p><strong>SpringApplicationRunListener</strong></p><p>只需要放在ioc容器中</p><p><strong>ApplicationRunner</strong></p><p><strong>CommandLineRunner</strong></p><p>启动流程：</p><h2 id="1、创建SpringApplication对象"><a href="#1、创建SpringApplication对象" class="headerlink" title="1、创建SpringApplication对象"></a><strong>1、创建SpringApplication对象</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">initialize(sources);<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(Object[] sources)</span> &#123;<br>    <span class="hljs-comment">//保存主配置类</span><br>    <span class="hljs-keyword">if</span> (sources != <span class="hljs-literal">null</span> &amp;&amp; sources.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.sources.addAll(Arrays.asList(sources));<br>    &#125;<br>    <span class="hljs-comment">//判断当前是否一个web应用</span><br>    <span class="hljs-built_in">this</span>.webEnvironment = deduceWebEnvironment();<br>    <span class="hljs-comment">//从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来</span><br>    setInitializers((Collection) getSpringFactoriesInstances(<br>        ApplicationContextInitializer.class));<br>    <span class="hljs-comment">//从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener</span><br>    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));<br>    <span class="hljs-comment">//从多个配置类中找到有main方法的主配置类</span><br>    <span class="hljs-built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180306145727.png"></p><p><img src="/images/springboot/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180306145855.png"></p><h2 id="2、运行run方法"><a href="#2、运行run方法" class="headerlink" title="2、运行run方法"></a>2、运行run方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> &#123;<br>   <span class="hljs-type">StopWatch</span> <span class="hljs-variable">stopWatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>();<br>   stopWatch.start();<br>   <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>   <span class="hljs-type">FailureAnalyzers</span> <span class="hljs-variable">analyzers</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>   configureHeadlessProperty();<br>    <br>   <span class="hljs-comment">//获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories</span><br>   <span class="hljs-type">SpringApplicationRunListeners</span> <span class="hljs-variable">listeners</span> <span class="hljs-operator">=</span> getRunListeners(args);<br>    <span class="hljs-comment">//回调所有的获取SpringApplicationRunListener.starting()方法</span><br>   listeners.starting();<br>   <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-comment">//封装命令行参数</span><br>      <span class="hljs-type">ApplicationArguments</span> <span class="hljs-variable">applicationArguments</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultApplicationArguments</span>(<br>            args);<br>      <span class="hljs-comment">//准备环境</span><br>      <span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> prepareEnvironment(listeners,<br>            applicationArguments);<br>       <span class="hljs-comment">//创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成</span><br>       <br>      <span class="hljs-type">Banner</span> <span class="hljs-variable">printedBanner</span> <span class="hljs-operator">=</span> printBanner(environment);<br>       <br>       <span class="hljs-comment">//创建ApplicationContext；决定创建web的ioc还是普通的ioc</span><br>      context = createApplicationContext();<br>       <br>      analyzers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FailureAnalyzers</span>(context);<br>       <span class="hljs-comment">//准备上下文环境;将environment保存到ioc中；而且applyInitializers()；</span><br>       <span class="hljs-comment">//applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法</span><br>       <span class="hljs-comment">//回调所有的SpringApplicationRunListener的contextPrepared()；</span><br>       <span class="hljs-comment">//</span><br>      prepareContext(context, environment, listeners, applicationArguments,<br>            printedBanner);<br>       <span class="hljs-comment">//prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）；</span><br>       <br>       <span class="hljs-comment">//s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版</span><br>       <span class="hljs-comment">//扫描，创建，加载所有组件的地方；（配置类，组件，自动配置）</span><br>      refreshContext(context);<br>       <span class="hljs-comment">//从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调</span><br>       <span class="hljs-comment">//ApplicationRunner先回调，CommandLineRunner再回调</span><br>      afterRefresh(context, applicationArguments);<br>       <span class="hljs-comment">//所有的SpringApplicationRunListener回调finished方法</span><br>      listeners.finished(context, <span class="hljs-literal">null</span>);<br>      stopWatch.stop();<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logStartupInfo) &#123;<br>         <span class="hljs-keyword">new</span> <span class="hljs-title class_">StartupInfoLogger</span>(<span class="hljs-built_in">this</span>.mainApplicationClass)<br>               .logStarted(getApplicationLog(), stopWatch);<br>      &#125;<br>       <span class="hljs-comment">//整个SpringBoot应用启动完成以后返回启动的ioc容器；</span><br>      <span class="hljs-keyword">return</span> context;<br>   &#125;<br>   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>      handleRunFailure(context, listeners, analyzers, ex);<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(ex);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、事件监听机制"><a href="#3、事件监听机制" class="headerlink" title="3、事件监听机制"></a>3、事件监听机制</h2><p>配置在META-INF&#x2F;spring.factories</p><p><strong>ApplicationContextInitializer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloApplicationContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextInitializer</span>&lt;ConfigurableApplicationContext&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ApplicationContextInitializer...initialize...&quot;</span>+applicationContext);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>SpringApplicationRunListener</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloSpringApplicationRunListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SpringApplicationRunListener</span> &#123;<br><br>    <span class="hljs-comment">//必须有的构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HelloSpringApplicationRunListener</span><span class="hljs-params">(SpringApplication application, String[] args)</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">starting</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;SpringApplicationRunListener...starting...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">environmentPrepared</span><span class="hljs-params">(ConfigurableEnvironment environment)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> environment.getSystemProperties().get(<span class="hljs-string">&quot;os.name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;SpringApplicationRunListener...environmentPrepared..&quot;</span>+o);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextPrepared</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;SpringApplicationRunListener...contextPrepared...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoaded</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;SpringApplicationRunListener...contextLoaded...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finished</span><span class="hljs-params">(ConfigurableApplicationContext context, Throwable exception)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;SpringApplicationRunListener...finished...&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>配置（META-INF&#x2F;spring.factories）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">org.springframework.context.ApplicationContextInitializer</span>=<span class="hljs-string">\</span><br><span class="hljs-string">com.atguigu.springboot.listener.HelloApplicationContextInitializer</span><br><br><span class="hljs-attr">org.springframework.boot.SpringApplicationRunListener</span>=<span class="hljs-string">\</span><br><span class="hljs-string">com.atguigu.springboot.listener.HelloSpringApplicationRunListener</span><br></code></pre></td></tr></table></figure><p>只需要放在ioc容器中</p><p><strong>ApplicationRunner</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloApplicationRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationRunner</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;ApplicationRunner...run....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>CommandLineRunner</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloCommandLineRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CommandLineRunner</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;CommandLineRunner...run...&quot;</span>+ Arrays.asList(args));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="八、自定义starter"><a href="#八、自定义starter" class="headerlink" title="八、自定义starter"></a>八、自定义starter</h1><p>starter：</p><p>​1、这个场景需要使用到的依赖是什么？</p><p>​2、如何编写自动配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//指定这个类是一个配置类</span><br><span class="hljs-meta">@ConditionalOnXXX</span>  <span class="hljs-comment">//在指定条件成立的情况下自动配置类生效</span><br><span class="hljs-meta">@AutoConfigureAfter</span>  <span class="hljs-comment">//指定自动配置类的顺序</span><br><span class="hljs-meta">@Bean</span>  <span class="hljs-comment">//给容器中添加组件</span><br><br><span class="hljs-meta">@ConfigurationPropertie</span>结合相关xxxProperties类来绑定相关的配置<br><span class="hljs-meta">@EnableConfigurationProperties</span> <span class="hljs-comment">//让xxxProperties生效加入到容器中</span><br><br>自动配置类要能加载<br>将需要启动就加载的自动配置类，配置在META-INF/spring.factories<br>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\<br>org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\<br>org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\<br></code></pre></td></tr></table></figure><p>​3、模式：</p><p>启动器只用来做依赖导入；</p><p>专门来写一个自动配置模块；</p><p>启动器依赖自动配置；别人只需要引入启动器（starter）</p><p>mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter</p><p>步骤：</p><p>1）、启动器模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.starter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>atguigu-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--启动器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--引入自动配置模块--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.starter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）、自动配置模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.starter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.10.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>      <span class="hljs-comment">&lt;!--引入spring-boot-starter；所有starter的基本配置--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.starter;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;atguigu.hello&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloProperties</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String prefix;<br>    <span class="hljs-keyword">private</span> String suffix;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPrefix</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> prefix;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrefix</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-built_in">this</span>.prefix = prefix;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSuffix</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> suffix;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuffix</span><span class="hljs-params">(String suffix)</span> &#123;<br>        <span class="hljs-built_in">this</span>.suffix = suffix;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.starter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloService</span> &#123;<br><br>    HelloProperties helloProperties;<br><br>    <span class="hljs-keyword">public</span> HelloProperties <span class="hljs-title function_">getHelloProperties</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> helloProperties;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHelloProperties</span><span class="hljs-params">(HelloProperties helloProperties)</span> &#123;<br>        <span class="hljs-built_in">this</span>.helloProperties = helloProperties;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHellAtguigu</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-keyword">return</span> helloProperties.getPrefix()+<span class="hljs-string">&quot;-&quot;</span> +name + helloProperties.getSuffix();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.starter;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnWebApplication</span> <span class="hljs-comment">//web应用才生效</span><br><span class="hljs-meta">@EnableConfigurationProperties(HelloProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServiceAutoConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    HelloProperties helloProperties;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> HelloService <span class="hljs-title function_">helloService</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">HelloService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloService</span>();<br>        service.setHelloProperties(helloProperties);<br>        <span class="hljs-keyword">return</span> service;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读写锁ReentrantReadWriteLock</title>
    <link href="/2022/06/11/ReentrantReadWriteLock/"/>
    <url>/2022/06/11/ReentrantReadWriteLock/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">读写锁ReentrantReadWriteLock</font></div><blockquote><table><tr><td bgcolor="#6495ED"><font color="#FFF">读写锁维护着一对锁，一个读锁和一个写锁。通过分离读锁和写锁，使得并发性比一般的排他锁有了较大的提升：在同一时间可以允许多个读线程同时访问，但是在写线程访问时，所有读线程和写线程都会被阻塞。</font></td></tr></table></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHARED_SHIFT</span>   <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHARED_UNIT</span>    <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT);<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_COUNT</span>      <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCLUSIVE_MASK</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/** Returns the number of shared holds represented in count  */</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sharedCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>    &#123; <span class="hljs-keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;<br><span class="hljs-comment">/** Returns the number of exclusive holds represented in count  */</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">exclusiveCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123; <span class="hljs-keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;<br></code></pre></td></tr></table></figure><p>这段代码在Sync静态内部类中，这里有两个关键方法sharedCount和exclusiveCount，通过名字可以看出sharedCount是共享锁的数量，exclusiveCount是独占锁的数量。共享锁通过对c像右位移16位获得，独占锁通过和16位的1与运算获得。举个例子，当获取读锁的线程有3个，写锁的线程有1个（当然这是不可能同时有的），state就表示为0000 0000 0000 0011 0000 0000 0000 0001，高16位代表读锁，通过向右位移16位（c &gt;&gt;&gt; SHARED_SHIFT）得倒10进制的3，通过和0000 0000 0000 0000 1111 1111 1111 1111与运算（c &amp; EXCLUSIVE_MASK），获得10进制的1。弄懂了着几个方法，就明白了为什么通过一个state实现了读写共享。</p><p>这当中还有一个问题，由于16位最大全1表示为65535，所以读锁和写锁最多可以获取65535个。</p><p>读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。</p><p>写锁的加锁源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState(); <span class="hljs-comment">// 取到当前锁的个数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> exclusiveCount(c); <span class="hljs-comment">// 取写锁的个数w</span><br><span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果已经有线程持有了锁(c!=0)</span><br>    <span class="hljs-comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span><br><span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread()) <span class="hljs-comment">// 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)    <span class="hljs-comment">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span><br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br><span class="hljs-comment">// Reentrant acquire</span><br>    setState(c + acquires);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) <span class="hljs-comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>setExclusiveOwnerThread(current); <span class="hljs-comment">// 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w &#x3D; exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li><li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!&#x3D;0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li><li>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li><li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!&#x3D;0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li><li>如果c&#x3D;0,w&#x3D;0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Semaphore</title>
    <link href="/2022/06/11/Semaphore/"/>
    <url>/2022/06/11/Semaphore/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">Semaphore</font></div><blockquote><table><tr><td bgcolor="#6495ED"><font color="#FFF">Semaphore，字面意思信号量，可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。和CountDownLatch一样，其本质上是一个“共享锁”。</font></td></tr></table></blockquote><h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><hr><p>Semaphore内部维护了一组虚拟的许可，许可的数量可以通过构造函数的参数指定。</p><ul><li><p>访问特定资源前，必须使用acquire方法获得许可，如果许可数量为0，该线程则一直阻塞，直到有可用许可。</p></li><li><p>访问资源后，使用release释放许可。</p><p>同样的Semaphore也是依赖内部类Sync实现，而Sync继承AQS。Semaphore内部包含公平锁（FairSync）和非公平锁（NonfairSync），和ReentrantLock类似。</p><p><img src="/SemaphoreStruct.png" alt="Semaphore内部实现图"></p><p><img src="/SemaphoreVSReentrantLock.png" alt="Semaphore和ReentrantLock比较"></p><p>Semaphore提供了两个构造函数，Semaphore默认选择非公平锁。：</p><ol><li><p>Semaphore(int permits) ：创建具有给定的许可数和非公平的公平设置的 Semaphore。</p></li><li><p>Semaphore(int permits, boolean fair) ：创建具有给定的许可数和给定的公平设置的 Semaphore。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> permits)</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(permits);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> permits, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>(permits) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(permits);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ul><p>当信号量Semaphore &#x3D; 1 时，它可以当作互斥锁使用。其中0、1就相当于它的状态，当&#x3D;1时表示其他线程可以获取，当&#x3D;0时，排他，即其他线程必须要等待。</p><h5 id="信号量获取"><a href="#信号量获取" class="headerlink" title="信号量获取"></a><font style="color:rgb(69, 182, 247)">信号量获取</font></h5><p>acquire()方法来获取一个许可。结构和ReentrantLock一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>await内部调用AQS的acquireSharedInterruptibly</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireSharedInterruptibly(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>tryAcquireShared由Semaphore内部类Sync重写实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//公平</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//判断该线程是否位于CLH队列的列头</span><br>        <span class="hljs-keyword">if</span> (hasQueuedPredecessors())<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//获取当前的信号量许可</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br><br>        <span class="hljs-comment">//设置“获得acquires个信号量许可之后，剩余的信号量许可数”</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br><br>        <span class="hljs-comment">//CAS设置信号量</span><br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>            compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//非公平</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<span class="hljs-comment">//Sync实现</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>            compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="信号量释放"><a href="#信号量释放" class="headerlink" title="信号量释放"></a><font style="color:rgb(69, 182, 247)">信号量释放</font></h5><p>获取了许可，当用完之后使用release()来释放许可。和CountDownLatch类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>release内部调用AQS的releaseShared</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>tryReleaseShared方法由Semaphore的内部类Sync重写实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-comment">//信号量的许可数 = 当前信号许可数 + 待释放的信号许可数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;<br>        <span class="hljs-keyword">if</span> (next &lt; current)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>        <span class="hljs-comment">//设置可获取的信号许可数为next</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><hr><ol><li><p>多个共享资源互斥的使用</p></li><li><p>并发限流，控制最大线程数</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pools</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)&#123;<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    semaphore.acquire();<br>                    System.out.println(<span class="hljs-string">&quot;任务&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;开始执行&quot;</span>);<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br><br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    semaphore.release();<br>                    System.out.println(<span class="hljs-string">&quot;任务&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;执行完毕&quot;</span>);<br>                &#125;<br>            &#125;;<br>            pools.execute(runnable);<br>        &#125;<br>        pools.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/Semaphore.png" alt="Semaphore测试结果"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>JUC</category>
      
      <category>计数器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PriorityBlockingQueue</title>
    <link href="/2022/06/11/PriorityBlockingQueue/"/>
    <url>/2022/06/11/PriorityBlockingQueue/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">PriorityBlockingQueue</font></div><blockquote><table><tr><td bgcolor="#6495ED"><font color="#FFF"> PriorityBlockingQueue是一个支持优先级的无界阻塞队列，底层采用二叉堆实现的。默认情况下元素采用自然顺序升序排序，当然我们也可以通过构造函数来指定Comparator来对元素进行排序。需要注意的是PriorityBlockingQueue不能保证同优先级元素的顺序。ArrayBlockingQueue、LinkedBlockingQueue都是采用FIFO原则来确定线程执行的先后顺序</font></td></tr></table></blockquote><h4 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。它有两种表现形式：最大堆、最小堆。 最大堆：父节点的键值总是大于或等于任何一个子节点的键值， 最小堆：父节点的键值总是小于或等于任何一个子节点的键值。</p><p>二叉堆一般用数组表示，如果父节点的节点位置在n处，那么其左孩子节点为：2 * n + 1 ，其右孩子节点为2 * (n + 1)，其父节点为（n - 1） &#x2F; 2 处。</p><p><img src="/images/JUC/BlockingQueue/erchadui.png" alt="二叉堆举例"></p><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><p>最小堆为例：首先将要添加的元素N插添加到堆的末尾位置（在二叉堆中我们称之为空穴）。如果元素N放入空穴中而不破坏堆的序（其值大于跟父节点值（最大堆是小于父节点）），那么插入完成。否则，我们则将该元素N的节点与其父节点进行交换，然后与其新父节点进行比较直到它的父节点不在比它小（最大堆是大）或者到达根节点。</p><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><p>删除元素与增加元素一样，需要维护整个二叉堆的序。删除位置1的元素（数组下标0），则把最后一个元素空出来移到最前边，然后和它的两个子节点比较，如果两个子节点中较小的节点小于该节点，就将他们交换，直到两个子节点都比该元素大为止。</p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>内部也是用可重入锁<code>ReentrantLock</code>实现同步机制，但只有一个<code>notEmpty</code>的Condition，<code>ArrayBlockingQueue</code>定义了两个Condition，之所以这样，因为<code>PriorityBlockingQueue</code>是一个<em><strong>无界队列，插入总是会成功</strong></em>，除非消耗尽了资源导致服务器挂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;<br>    <span class="hljs-comment">// 默认容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<br>    <span class="hljs-comment">// 最大容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">// 二叉堆数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Object[] queue;<br>    <span class="hljs-comment">// 队列元素的个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-comment">// 比较器，如果为空，则为自然顺序</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; comparator;<br>    <span class="hljs-comment">// 内部锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<span class="hljs-comment">//非空</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> allocationSpinLock;<br>    <span class="hljs-comment">// 优先队列：主要用于序列化，这是为了兼容之前的版本。只有在序列化和反序列化才非空</span><br>    <span class="hljs-keyword">private</span> PriorityQueue&lt;E&gt; q;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="三个基本添加方法"><a href="#三个基本添加方法" class="headerlink" title="三个基本添加方法"></a>三个基本添加方法</h4><p><code>add</code>、<code>put</code>、<code>offer</code>，<code>add</code>和<code>put</code>内部直接调用<code>offer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//add</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">return</span> offer(e);<br>&#125;<br><span class="hljs-comment">//put</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> &#123;<br>    offer(e); <span class="hljs-comment">// never need to block</span><br>&#125;<br><span class="hljs-comment">//offer</span><br><span class="hljs-comment">//正如该方法注释所说，插入一个元素到该优先级队列，该队列是无界的，所以这个方法永远都是插入成功的。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-type">int</span> n, cap;<br>    Object[] array;<br>    <span class="hljs-keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))<br>        tryGrow(array, cap);<span class="hljs-comment">//进行扩容</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; cmp = comparator;<span class="hljs-comment">//创建队列对象没传入Comparator实现类默认为null</span><br>        <span class="hljs-keyword">if</span> (cmp == <span class="hljs-literal">null</span>)<br>            siftUpComparable(n, e, array);<span class="hljs-comment">//自然排序</span><br>        <span class="hljs-keyword">else</span><br>            siftUpUsingComparator(n, e, array, cmp);<span class="hljs-comment">//自定义排序</span><br>        size = n + <span class="hljs-number">1</span>;<br>        notEmpty.signal();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//扩容  通过自旋</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryGrow</span><span class="hljs-params">(Object[] array, <span class="hljs-type">int</span> oldCap)</span> &#123;<br>    lock.unlock(); <span class="hljs-comment">// 不需要锁主锁</span><br>    Object[] newArray = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//CAS</span><br>    <span class="hljs-comment">// allocationSpinLock = 0;代表释放了自旋锁</span><br>    <span class="hljs-comment">// allocationSpinLock = 1;代表释放了自旋锁</span><br>    <span class="hljs-keyword">if</span> (allocationSpinLock == <span class="hljs-number">0</span> &amp;&amp;<br>        UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, allocationSpinLockOffset,<br>                                 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<span class="hljs-comment">//获取自旋锁，即设置为1</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newCap</span> <span class="hljs-operator">=</span> oldCap + ((oldCap &lt; <span class="hljs-number">64</span>) ?<br>                                   (oldCap + <span class="hljs-number">2</span>) : <span class="hljs-comment">// grow faster if small</span><br>                                   (oldCap &gt;&gt; <span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// possible overflow</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">minCap</span> <span class="hljs-operator">=</span> oldCap + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (minCap &lt; <span class="hljs-number">0</span> || minCap &gt; MAX_ARRAY_SIZE)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>                newCap = MAX_ARRAY_SIZE;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)<br>                newArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[newCapmowei];<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            allocationSpinLock = <span class="hljs-number">0</span>;<span class="hljs-comment">// 代表释放了自旋锁</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newArray == <span class="hljs-literal">null</span>) <span class="hljs-comment">// back off if another thread is allocating</span><br>        Thread.yield();<br>    lock.lock();<br>    <span class="hljs-keyword">if</span> (newArray != <span class="hljs-literal">null</span> &amp;&amp; queue == array) &#123;<br>        queue = newArray;<br>        System.arraycopy(array, <span class="hljs-number">0</span>, newArray, <span class="hljs-number">0</span>, oldCap);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//因为底层是二叉堆，所以需要维持二叉堆顺序，插入的时候和父节点比较</span><br><span class="hljs-comment">//父节点的位置（k - 1) / 2 即：（k - 1) &gt;&gt;&gt; 1 右移一位相当于除以2的1次方</span><br><span class="hljs-comment">//按顺序插入，自然排序</span><br><span class="hljs-comment">//k 二叉堆的末尾即元素数量size</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUpComparable</span><span class="hljs-params">(<span class="hljs-type">int</span> k, T x, Object[] array)</span> &#123;<br>    Comparable&lt;? <span class="hljs-built_in">super</span> T&gt; key = (Comparable&lt;? <span class="hljs-built_in">super</span> T&gt;) x;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[parent];<br>        <span class="hljs-keyword">if</span> (key.compareTo((T) e) &gt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//二者唯一区别</span><br>            <span class="hljs-keyword">break</span>;<br>        array[k] = e;<br>        k = parent;<br>    &#125;<br>    array[k] = key;<br>&#125;<br><span class="hljs-comment">//按顺序插入，自定义排序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUpUsingComparator</span><span class="hljs-params">(<span class="hljs-type">int</span> k, T x, Object[] array,</span><br><span class="hljs-params">                                              Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; cmp)</span> &#123;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[parent];<br>        <span class="hljs-keyword">if</span> (cmp.compare(x, (T) e) &gt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//二者唯一区别</span><br>            <span class="hljs-keyword">break</span>;<br>        array[k] = e;<br>        k = parent;<br>    &#125;<br>    array[k] = x;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="常用出队操作"><a href="#常用出队操作" class="headerlink" title="常用出队操作"></a>常用出队操作</h4><p><code>poll</code>、<code>remove</code>方法来执行出队操作。***出队的永远都是第一个元素：array[0]***。<code>remove</code>底层最后还是调用了<code>poll</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//按照二叉堆删除元素规则出队，删除第一个，末位的和其他元素比较</span><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 没有元素 返回null</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        Object[] array = queue;<br>        <span class="hljs-comment">// 出队元素</span><br>        <span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (E) array[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 最后一个元素（也就是插入到空穴中的元素）</span><br>        <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (E) array[n];<br>        array[n] = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 根据比较器释放为null，来执行不同的处理</span><br>        Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; cmp = comparator;<br>        <span class="hljs-keyword">if</span> (cmp == <span class="hljs-literal">null</span>)<br>            siftDownComparable(<span class="hljs-number">0</span>, x, array, n);<br>        <span class="hljs-keyword">else</span><br>            siftDownUsingComparator(<span class="hljs-number">0</span>, x, array, n, cmp);<br>        size = n;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//自然排序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftDownComparable</span><span class="hljs-params">(<span class="hljs-type">int</span> k, T x, Object[] array,</span><br><span class="hljs-params">                                               <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>        Comparable&lt;? <span class="hljs-built_in">super</span> T&gt; key = (Comparable&lt;? <span class="hljs-built_in">super</span> T&gt;)x;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> n &gt;&gt;&gt; <span class="hljs-number">1</span>;           <span class="hljs-comment">// loop while a non-leaf</span><br>        <span class="hljs-keyword">while</span> (k &lt; half) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>; <span class="hljs-comment">// assume left child is least</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> array[child];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> child + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp;<br>                ((Comparable&lt;? <span class="hljs-built_in">super</span> T&gt;) c).compareTo((T) array[right]) &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//左右节点比较</span><br>                c = array[child = right];<br>            <span class="hljs-keyword">if</span> (key.compareTo((T) c) &lt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//该节点和左右节点最小节点比较</span><br>                <span class="hljs-keyword">break</span>;<br>            array[k] = c;<br>            k = child;<br>        &#125;<br>        array[k] = key;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//自定义排序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftDownUsingComparator</span><span class="hljs-params">(<span class="hljs-type">int</span> k, T x, Object[] array,</span><br><span class="hljs-params">                                                <span class="hljs-type">int</span> n,</span><br><span class="hljs-params">                                                Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; cmp)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k &lt; half) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> array[child];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> child + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; cmp.compare((T) c, (T) array[right]) &gt; <span class="hljs-number">0</span>)<br>                c = array[child = right];<br>            <span class="hljs-keyword">if</span> (cmp.compare(x, (T) c) &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            array[k] = c;<br>            k = child;<br>        &#125;<br>        array[k] = x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>JUC</category>
      
      <category>BlockingQueue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重入锁ReentrantLock</title>
    <link href="/2022/06/11/ReentrantLock/"/>
    <url>/2022/06/11/ReentrantLock/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">重入锁ReentrantLock</font></div><blockquote><table><tr><td bgcolor="#6495ED"><font color="#FFF"><strong>ReentrantLock</strong>，可重入锁，排他锁，可以等同于synchronized的使用，但是ReentrantLock提供了比synchronized更强大、灵活的锁机制，可以减少死锁发生的概率。</font></td></tr></table></blockquote><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><img src="/images/JUC/ReentrantLock/ReentrantLock.png" alt="ReentrantLockUML图"></p><p><kbd>FairSync</kbd>、<kbd>NonfairSync</kbd>和<kbd>Sync</kbd>是ReentrantLock的内部类，FairSync和NonfairSync继承自Sync，Sync继承自AbstractQueuedSynchronizer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><p>ReentrantLock里的大部分功能都是委托给Sync实现的，FairSync和NonfairSync二者内部只有lock()和tryAcquire()，Sync提供了抽象方法Lock()，并且默认实现了nonfairTryAcquire(int acquires)，AbstractQueuedSynchronizer提供了抽象方法tryAcquire()。</p><h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a><font style="color:rgb(69, 182, 247)">获取锁</font></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非公平锁  sync = new NonfairSync();</span><br><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">//公平锁 sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);<br>lock.lock();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    sync.lock();<br>&#125;<br></code></pre></td></tr></table></figure><p>非公平锁为例：</p><p><img src="/images/JUC/ReentrantLock/%E8%8E%B7%E5%8F%96%E9%94%81%E7%9A%84%E5%A4%A7%E6%A6%82%E6%B5%81%E7%A8%8B.png" alt="获取锁的大概流程"></p><p>(AQS)getState &#x3D;&#x3D; 0? 否分支—&gt;可重入锁的具体表现</p><p><img src="/images/JUC/ReentrantLock/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%8A%A0%E8%A7%A3%E9%94%81.png" alt="非公平锁加解锁"></p><p>非公平锁<code>NonfairSync</code>获取锁<code>lock()</code>的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<span class="hljs-comment">//尝试获取锁</span><br>        setExclusiveOwnerThread(Thread.currentThread());<br>    <span class="hljs-keyword">else</span><br>        acquire(<span class="hljs-number">1</span>);<span class="hljs-comment">//ReentrantLock是可重入锁，此处1是为了再次获取了锁进行statu累加</span><br>&#125;<br></code></pre></td></tr></table></figure><p>若锁已被占用，便会执行<code>acquire(int arg)</code>（该方法由AbstractQueuedSynchronizer实现了）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>各个方法定义如下：</p><ol><li><p><kbd>tryAcquire</kbd>：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。该方法自定义组件实现（可以看到NonfairSync内部类已实现），该方法必须要保证线程安全的获取同步状态。</p><p>tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。</p></li><li><p><kbd>addWaiter</kbd>：如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。（<a href="JUC%E4%B9%8BAQS%E7%AE%80%E4%BB%8B.md">AQS简述</a>里有描述）</p></li><li><p><kbd>acquireQueued</kbd>：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。acquireQueued方法可以对排队中的线程进行“获锁”操作。</p></li><li><p><kbd>selfInterrupt</kbd>：产生一个中断。</p></li></ol><p>非公平锁<code>NonfairSync</code>的同步状态的获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>&#125;<br><span class="hljs-comment">//Sync内部实现的，典</span><br><span class="hljs-comment">//该方法主要逻辑：</span><br><span class="hljs-comment">//典型的可重入锁...................................</span><br><span class="hljs-comment">//首先判断同步状态state == 0 ?，如果是表示该锁还没有被线程持有，直接通过CAS获取同步状态，如果成功返回true。</span><br><span class="hljs-comment">//如果state != 0，则判断当前线程是否为获取锁的线程，如果是则获取锁，成功返回true。成功获取锁的线程再次获取锁，这是增加了同步状态state。</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-comment">//当前线程</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//获取同步状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-comment">//state == 0,表示没有该锁处于空闲状态</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//获取锁成功，设置为当前线程所有</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//线程重入</span><br>    <span class="hljs-comment">//判断锁持有的线程是否为当前线程</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>setExclusiveOwnerThread(current)</code>和<code>getExclusiveOwnerThread()</code>类似于set，get。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//由AbstractOwnableSynchronizer提供</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setExclusiveOwnerThread</span><span class="hljs-params">(Thread thread)</span> &#123;<br>    exclusiveOwnerThread = thread;<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Thread <span class="hljs-title function_">getExclusiveOwnerThread</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> exclusiveOwnerThread;<br>&#125;<br></code></pre></td></tr></table></figure><p>acquireQueued方法为一个自旋的过程，也就是说当前线程（Node）进入同步队列后，就会进入一个自旋的过程，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去。“何时出队列？”和“如何出队列？“，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br><span class="hljs-comment">// 标记是否成功拿到资源</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 标记等待过程中是否中断过</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 开始自旋，要么获取锁，要么中断</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-comment">// 获取当前节点的前驱节点</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br><span class="hljs-comment">// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span><br><span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br><span class="hljs-comment">// 获取锁成功，头指针移动到当前node</span><br>setHead(node);<br>p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>failed = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> interrupted;<br>&#125;<br><span class="hljs-comment">// 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析</span><br><span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>interrupted = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (failed)<br>cancelAcquire(node);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHead</span><span class="hljs-params">(Node node)</span> &#123;<br>head = node;<br>node.thread = <span class="hljs-literal">null</span>;<br>node.prev = <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-comment">// 靠前驱节点判断当前线程是否应该被阻塞</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br><span class="hljs-comment">// 获取头结点的节点状态</span><br><span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br><span class="hljs-comment">// 说明头结点处于唤醒状态</span><br><span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br><span class="hljs-comment">// 通过枚举值我们知道waitStatus&gt;0是取消状态</span><br><span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">// 循环向前查找取消节点，把取消节点从队列中剔除</span><br>node.prev = pred = pred.prev;<br>&#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>pred.next = node;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 设置前任节点等待状态为SIGNAL</span><br>compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>parkAndCheckInterrupt主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="hljs-comment">//LockSupport底层其实调用的是Unsafe，有一篇记录了Unsafe的主要功能</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/JUC/ReentrantLock/%E5%85%A5%E9%98%9F%E5%87%BA%E9%98%9F.png" alt="入队出队"></p><p>从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire流程）：</p><p><img src="/images/JUC/ReentrantLock/shouldParkAfterFailedAcquire%E6%B5%81%E7%A8%8B.png" alt="shouldParkAfterFailedAcquire流程"></p><p><em><strong>acquire()执行流程如下：</strong></em></p><p><img src="/images/JUC/ReentrantLock/ReentrantLock-acquire.png" alt="ReentrantLock-acquire"></p><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a><font style="color:rgb(69, 182, 247)">释放锁</font></h4><p>ReentrantLock提供了unlock释放锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    sync.release(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//AQS中定义实现的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>和<kbd>tryAcquire</kbd>一样，<kbd>tryRelease</kbd>也需要组件自定义实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Sync中实现</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-comment">//减掉releases</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-comment">//如果释放的不是持有锁的线程，抛出异常</span><br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//state == 0 表示已经释放完全了，其他线程可以获取同步状态了</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a><font style="color:rgb(69, 182, 247)">公平锁和非公平锁</font></h4><p>公平锁与非公平锁的区别在于获取锁<code>tryAcquire</code>的时候是否按照FIFO的顺序来。<em><strong>释放锁不存在公平性和非公平性</strong></em>。</p><p>比较非公平锁和公平锁获取同步状态的过程，会发现两者<em><strong>唯一的区别</strong></em>就在于<em><strong>公平锁</strong></em>在获取同步状态时多了一个限制条件：<em><strong>hasQueuedPredecessors()</strong></em></p><p>hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以争取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中。</p><p>双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。双端链表的头结点是一个无参构造函数的头结点。</p><p>当h !&#x3D; t时： 如果(s &#x3D; h.next) &#x3D;&#x3D; null，等待队列正在有线程进行初始化，但只是进行到了Tail指向Head，没有将Head指向Tail，此时队列中有元素，需要返回True（这块具体见下边代码分析）。如果(s &#x3D; h.next) !&#x3D; null，说明此时队列中至少有一个有效节点。如果此时s.thread &#x3D;&#x3D; Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果s.thread !&#x3D; Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasQueuedPredecessors</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;  <span class="hljs-comment">//尾节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <span class="hljs-comment">//头节点</span><br>    Node s;<br>    <span class="hljs-keyword">return</span> h != t &amp;&amp;<br>        ((s = h.next) == <span class="hljs-literal">null</span> || s.thread != Thread.currentThread());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//上边是lock()先直接去获取锁，没有获得锁，然后入队执行addWaiter()，假如队内没有节点，执行enq(node);具体内容如下：</span><br><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer  #enq</span><br><br><span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br><span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>tail = head;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>node.prev = t;<br><span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>t.next = node;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>节点入队不是原子操作，所以会出现短暂的head !&#x3D; tail，此时Tail指向最后一个节点，而且Tail指向Head。如果Head没有指向Tail（可见5、6、7行），这种情况下也需要将相关线程加入队列中。所以这块代码是为了解决极端情况下的并发问题。</p><h4 id="ReentrantLock与synchronized的区别"><a href="#ReentrantLock与synchronized的区别" class="headerlink" title="ReentrantLock与synchronized的区别"></a><font style="color:rgb(69, 182, 247)">ReentrantLock与synchronized的区别</font></h4><blockquote><p>博客看的比较专业的</p></blockquote><ol><li>与synchronized相比，ReentrantLock提供了更多，更加全面的功能，具备更强的扩展性。例如：时间锁等候，可中断锁等候，锁投票。</li><li>ReentrantLock还提供了条件Condition，对线程的等待、唤醒操作更加详细和灵活，所以在多个条件变量和高度竞争锁的地方，ReentrantLock更加适合（以后会阐述Condition）。</li><li>ReentrantLock提供了可轮询的锁请求。它会尝试着去获取锁，如果成功则继续，否则可以等到下次运行时处理，而synchronized则一旦进入锁请求要么成功要么阻塞，所以相比synchronized而言，ReentrantLock会不容易产生死锁些。</li><li>ReentrantLock支持更加灵活的同步代码块，但是使用synchronized时，只能在同一个synchronized块结构中获取和释放。注：ReentrantLock的锁释放一定要在finally中处理，否则可能会产生严重的后果。</li><li>ReentrantLock支持中断处理，且性能较synchronized会好些。</li></ol><blockquote><p>自己看课程总结的和Lock的区别</p></blockquote><ol><li>Synchronized内置的java关键字，Lock是一个java类。</li><li>Synchronized无法判断获取锁的状态，Lock可以判断是否获取到锁。</li><li>Synchronized可以自动释放锁，Lock必须手动释放锁（不释放，会造成死锁）：手动挡和自动挡。</li><li>Synchronized线程1（获得锁，阻塞），线程2（等待，傻傻的等），Lock锁不一定一直等待（tryLock()）。</li><li>Synchronized可重入锁，不可中断，非公平，Lock可重入锁，可判断锁状态，默认非公平（可设置）。</li><li>Synchronized适合锁少量代码同步问题，Lock适合锁大量代码。</li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NVIDIA显卡驱动安装</title>
    <link href="/2022/06/11/NVIDIA%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/"/>
    <url>/2022/06/11/NVIDIA%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">NVIDIA显卡驱动安装</font></div><p>参考：<a href="https://blog.csdn.net/qq_21595501/article/details/103705776">Debian 10.2命令安装Nvidia显卡驱动成功，问题回顾</a>，<a href="https://www.cnblogs.com/hellxz/p/7865790.html">debian 9 双显卡安装NVIDIA显卡驱动</a></p><p>deepin外接显示器没有windows那么方便，有一种是wine的方式，但是感觉不咋滴，所以采取该方式：配置nvidia驱动。</p><p>直接官方网站下载.run文件，安装会提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">please use the debian packages instead of the .run file<br></code></pre></td></tr></table></figure><p>deepin就是基于debian的系统，所以可以安装debian的方式来操作。</p><h4 id="清理旧版驱动"><a href="#清理旧版驱动" class="headerlink" title="清理旧版驱动"></a>清理旧版驱动</h4><p>之前有安装过，或者安装失败了，执行如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt purge nvidia*<br>sudo reboot<br></code></pre></td></tr></table></figure><h4 id="禁用nouveau"><a href="#禁用nouveau" class="headerlink" title="禁用nouveau"></a>禁用nouveau</h4><p>创建<kbd>blacklist.conf</kbd>文件，添加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vi /etc/modprobe.d/blacklist.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加内容</span><br>blacklist nouveau   <br>blacklist lbm-nouveau   <br>options nouveau modeset=0 <br>alias nouveau off   <br>alias lbm-nouveau off<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">保存后执行：</span><br>sudo update-initramfs -u<br>sudo reboot<br></code></pre></td></tr></table></figure><p>重启后，执行如下命令检查nouveau是否已禁用，没有输出即成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsmod | grep nouveau<br></code></pre></td></tr></table></figure><h4 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h4><ol><li><p>使用<kbd>nvidia-detect</kbd>查看自己系统所适合的驱动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">sudo apt install nvidia-detect</span><br>nvidia-detect<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="/images/linux/nvidia-detect.png" alt="nvidia-detect"></p><p>可看到推荐安装nvidia-driver，但是安装这个版本依旧报错，但是支持390版本的。</p></li><li><p>修改软件源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vi /etc/apt/sources.list<br><span class="hljs-meta prompt_">#</span><span class="language-bash">最后添加如下内容</span><br>deb http://httpredir.debian.org/debian/ stretch main contrib non-free<br></code></pre></td></tr></table></figure><p>经过测试，如果不添加使用默认原文件所拥有的源，会报错提示没有改软件。</p></li><li><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install linux-headers-$(uname -r|sed &#x27;s/[^-]*-[^-]*-//&#x27;)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">上边查看推荐如下包，但是安装的时候报错</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">sudo apt install -t stretch-backports nvidia-driver</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">但是也推荐安装390</span><br>sudo apt install -t stretch-backports nvidia-legacy-390xx-driver<br>sudo reboot<br></code></pre></td></tr></table></figure><p>最后一步安装可能会报错，多尝试几次，可能是自己网络问题。</p><p>如果该过程没问题，重启后，会正常进入桌面。</p></li></ol><h4 id="配置DM（desktop-manager）加载N卡驱动"><a href="#配置DM（desktop-manager）加载N卡驱动" class="headerlink" title="配置DM（desktop manager）加载N卡驱动"></a>配置DM（desktop manager）加载N卡驱动</h4><ol><li><p><strong>&#x2F;etc&#x2F;X11</strong>创建<strong>xorg.conf</strong>文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vi /etc/X11/xorg.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加如下内容</span><br>Section &quot;Module&quot;<br>    Load &quot;modesetting&quot;<br>EndSection<br><br>Section &quot;Device&quot;<br>     Identifier &quot;nvidia&quot;<br>     Driver &quot;nvidia&quot;<br>     BusID &quot;1:0:0&quot;<br>     Option &quot;AllowEmptyInitialConfiguration&quot;<br>EndSection<br></code></pre></td></tr></table></figure><p>注：usID是之前执行<strong>nvidia-detect</strong>命令记录的编号，但是有点区别，比如我的编号为<strong>01:00.0</strong>，那么我的BusID应为<strong>1:0:0</strong>。</p></li><li><p>创建切换N卡脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vi /usr/local/bin/switch_nvidia.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加如下内容，高分辨率dpi可能需要修改，自己未做修改</span><br>xrandr --setprovideroutputsource modesetting NVIDIA-0<br>xrandr --auto<br>xrandr --dpi 96<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置执行权限</span><br>sudo chmod +x /usr/local/bin/switch_nvidia.sh<br></code></pre></td></tr></table></figure></li><li><p>根据DM (Desktop Manager)的类型选择配置文件</p><p>修改<strong>lightdm.conf</strong>文件，使用<kbd>?display-setup-script=</kbd>搜索，去掉注释，修改内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">display-setup-script=/usr/local/bin/switch_nvidia.sh<br></code></pre></td></tr></table></figure></li><li><p>重启lightdm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl restart lightdm.service<br></code></pre></td></tr></table></figure><p>按照如上操作，重启完后，外界显示屏自动亮屏，同时设置-&gt;显示里会变为多屏设置。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql高级四</title>
    <link href="/2022/06/11/Mysql%E9%AB%98%E7%BA%A7-day04/"/>
    <url>/2022/06/11/Mysql%E9%AB%98%E7%BA%A7-day04/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">Mysql高级四</font></div><h3 id="1-MySql中常用工具"><a href="#1-MySql中常用工具" class="headerlink" title="1. MySql中常用工具"></a>1. MySql中常用工具</h3><h4 id="1-1-mysql"><a href="#1-1-mysql" class="headerlink" title="1.1 mysql"></a>1.1 mysql</h4><p>该mysql不是指mysql服务，而是指mysql的客户端工具。</p><p>语法 ：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-attr">[database]</span><br></code></pre></td></tr></table></figure><h5 id="1-1-1-连接选项"><a href="#1-1-1-连接选项" class="headerlink" title="1.1.1 连接选项"></a>1.1.1 连接选项</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">参数 ： <br>-u, <span class="hljs-attribute">--user</span>=name指定用户名<br>-p, --password[=name]指定密码<br>-h, <span class="hljs-attribute">--host</span>=name指定服务器IP或域名<br>-P, <span class="hljs-attribute">--port</span>=#指定连接端口<br><br>示例 ：<br>mysql -h 127.0.0.1 -P 3306 -u root -p<br><br>mysql -h127.0.0.1 -P3306 -uroot -p2143<br><br></code></pre></td></tr></table></figure><h5 id="1-1-2-执行选项"><a href="#1-1-2-执行选项" class="headerlink" title="1.1.2 执行选项"></a>1.1.2 执行选项</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-e, <span class="hljs-attribute">--execute</span>=name执行SQL语句并退出<br></code></pre></td></tr></table></figure><p>此选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">示例：<br>mysql -uroot -p2143 db01 -e <span class="hljs-string">&quot;select * from tb_book&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1555325632715.png" alt="1555325632715"> </p><h4 id="1-2-mysqladmin"><a href="#1-2-mysqladmin" class="headerlink" title="1.2 mysqladmin"></a>1.2 mysqladmin</h4><p>mysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p><p>可以通过 ： mysqladmin –help  指令查看帮助文档</p><p><img src="/images/mysql/1555326108697.png" alt="1555326108697"> </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">示例 ：<br>mysqladmin -uroot -p2143 <span class="hljs-keyword">create</span> <span class="hljs-string">&#x27;test01&#x27;</span>;  <br>mysqladmin -uroot -p2143 <span class="hljs-keyword">drop</span> <span class="hljs-string">&#x27;test01&#x27;</span>;<br>mysqladmin -uroot -p2143 <span class="hljs-keyword">version</span>;<br><br></code></pre></td></tr></table></figure><h4 id="1-3-mysqlbinlog"><a href="#1-3-mysqlbinlog" class="headerlink" title="1.3 mysqlbinlog"></a>1.3 mysqlbinlog</h4><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具。</p><p>语法 ：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mysqlbinlog [options]  log-files1 log-files2 <span class="hljs-built_in">..</span>.<br><br>选项：<br><br>-d, <span class="hljs-attribute">--database</span>=name : 指定数据库名称，只列出指定的数据库相关操作。<br><br>-o, <span class="hljs-attribute">--offset</span>=# : 忽略掉日志中的前n行命令。<br><br>-r,<span class="hljs-attribute">--result-file</span>=name : 将输出的文本格式日志输出到指定文件。<br><br>-s, --short-form : 显示简单格式， 省略掉一些信息。<br><br><span class="hljs-attribute">--start-datatime</span>=date1  <span class="hljs-attribute">--stop-datetime</span>=date2 : 指定日期间隔内的所有日志。<br><br><span class="hljs-attribute">--start-position</span>=pos1 <span class="hljs-attribute">--stop-position</span>=pos2 : 指定位置间隔内的所有日志。<br></code></pre></td></tr></table></figure><h4 id="1-4-mysqldump"><a href="#1-4-mysqldump" class="headerlink" title="1.4 mysqldump"></a>1.4 mysqldump</h4><p>mysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。</p><p>语法 ：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">mysqldump <span class="hljs-selector-attr">[options]</span> db_name <span class="hljs-selector-attr">[tables]</span><br><br>mysqldump <span class="hljs-selector-attr">[options]</span> <span class="hljs-attr">--database</span>/-<span class="hljs-selector-tag">B</span> db1 <span class="hljs-selector-attr">[db2 db3...]</span><br><br>mysqldump <span class="hljs-selector-attr">[options]</span> <span class="hljs-attr">--all-databases</span>/-<span class="hljs-selector-tag">A</span><br></code></pre></td></tr></table></figure><h5 id="1-4-1-连接选项"><a href="#1-4-1-连接选项" class="headerlink" title="1.4.1 连接选项"></a>1.4.1 连接选项</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">参数 ： <br>-u, <span class="hljs-attribute">--user</span>=name指定用户名<br>-p, --password[=name]指定密码<br>-h, <span class="hljs-attribute">--host</span>=name指定服务器IP或域名<br>-P, <span class="hljs-attribute">--port</span>=#指定连接端口<br></code></pre></td></tr></table></figure><h5 id="1-4-2-输出内容选项"><a href="#1-4-2-输出内容选项" class="headerlink" title="1.4.2 输出内容选项"></a>1.4.2 输出内容选项</h5><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sas">参数：<br>--<span class="hljs-keyword">add</span>-<span class="hljs-keyword">drop</span>-database在每个数据库创建语句前加上 <span class="hljs-keyword">Drop</span> database 语句<br>--<span class="hljs-keyword">add</span>-<span class="hljs-keyword">drop</span>-<span class="hljs-keyword">table</span>在每个表创建语句前加上 <span class="hljs-keyword">Drop</span> <span class="hljs-keyword">table</span> 语句 , 默认开启 ; 不开启 (--<span class="hljs-keyword">skip</span>-<span class="hljs-keyword">add</span>-<span class="hljs-keyword">drop</span>-<span class="hljs-keyword">table</span>)<br><br>-n, --no-<span class="hljs-keyword">create</span>-db不包含数据库的创建语句<br>-t, --no-<span class="hljs-keyword">create</span>-info不包含数据表的创建语句<br>-d --no-data不包含数据<br><br> -T, --tab=name自动生成两个文件：一个.sql文件，创建表结构的语句；<br> 一个.txt文件，数据文件，相当于<span class="hljs-keyword">select</span> <span class="hljs-keyword">into</span> outfile  <br></code></pre></td></tr></table></figure><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">示例 ： <br>mysqldump -uroot -p2143 db01 tb_book --<span class="hljs-keyword">add</span>-<span class="hljs-keyword">drop</span>-database --<span class="hljs-keyword">add</span>-<span class="hljs-keyword">drop</span>-<span class="hljs-keyword">table</span> &gt; a<br><br>mysqldump -uroot -p2143 -T /tmp test city<br></code></pre></td></tr></table></figure><h4 id="1-5-mysqlimport-x2F-source"><a href="#1-5-mysqlimport-x2F-source" class="headerlink" title="1.5 mysqlimport&#x2F;source"></a>1.5 mysqlimport&#x2F;source</h4><p>mysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysqlimport <span class="hljs-selector-attr">[options]</span>  db_name  textfile1  <span class="hljs-selector-attr">[textfile2...]</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mysqlimport -uroot -p2143 test <span class="hljs-regexp">/tmp/</span>city.txt<br></code></pre></td></tr></table></figure><p>如果需要导入sql文件,可以使用mysql中的source 指令 : </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">source</span> <span class="hljs-regexp">/root/</span>tb_book.sql<br></code></pre></td></tr></table></figure><h4 id="1-6-mysqlshow"><a href="#1-6-mysqlshow" class="headerlink" title="1.6 mysqlshow"></a>1.6 mysqlshow</h4><p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。</p><p>语法：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">mysqlshow <span class="hljs-comment">[options]</span> <span class="hljs-comment">[db_name <span class="hljs-comment">[table_name <span class="hljs-comment">[col_name]</span>]</span>]</span><br></code></pre></td></tr></table></figure><p>参数：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attr">--count</span>显示数据库及表的统计信息（数据库，表 均可以不指定）<br><br>-<span class="hljs-selector-tag">i</span>显示指定数据库或者指定表的状态信息<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">#查询每个数据库的表的数量及表中记录的数量</span><br>mysqlshow -uroot -p2143 --<span class="hljs-built_in">count</span><br><br><span class="hljs-comment">#查询test库中每个表中的字段书，及行数</span><br>mysqlshow -uroot -p2143 test --<span class="hljs-built_in">count</span><br><br><span class="hljs-comment">#查询test库中book表的详细情况</span><br>mysqlshow -uroot -p2143 test <span class="hljs-keyword">book </span>--<span class="hljs-built_in">count</span><br><br></code></pre></td></tr></table></figure><h3 id="2-Mysql-日志"><a href="#2-Mysql-日志" class="headerlink" title="2. Mysql 日志"></a>2. Mysql 日志</h3><p>在任何一种数据库中，都会有各种各样的日志，记录着数据库工作的方方面面，以帮助数据库管理员追踪数据库曾经发生过的各种事件。MySQL 也不例外，在 MySQL 中，有 4 种不同的日志，分别是错误日志、二进制日志（BINLOG 日志）、查询日志和慢查询日志，这些日志记录着数据库在不同方面的踪迹。</p><h4 id="2-1-错误日志"><a href="#2-1-错误日志" class="headerlink" title="2.1 错误日志"></a>2.1 错误日志</h4><p>错误日志是 MySQL 中最重要的标志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志。</p><p>该日志是默认开启的 ， 默认存放目录为 mysql 的数据目录（var&#x2F;lib&#x2F;mysql）, 默认的日志文件名为  hostname.err（hostname是主机名）。</p><p>查看日志位置指令 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;log_error%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1553993244446.png" alt="1553993244446"> </p><p>查看日志内容 ： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tail -f /var/lib/mysql/xaxh-server.err<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1553993537874.png" alt="1553993537874"> </p><h4 id="2-2-二进制日志"><a href="#2-2-二进制日志" class="headerlink" title="2.2 二进制日志"></a>2.2 二进制日志</h4><h5 id="2-2-1概述"><a href="#2-2-1概述" class="headerlink" title="2.2.1概述"></a>2.2.1概述</h5><p>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但是不包括数据查询语句。此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的主从复制， 就是通过该binlog实现的。</p><p>二进制日志，默认情况下是没有开启的，需要到MySQL的配置文件中开启，并配置MySQL日志的格式。 </p><p>配置文件位置 : &#x2F;usr&#x2F;my.cnf</p><p>日志存放位置 : 配置时，给定了文件名但是没有指定路径，日志默认写入Mysql的数据目录。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如 : mysqlbin.000001,mysqlbin.000002</span><br><span class="hljs-attr">log_bin</span>=mysqlbin<br><span class="hljs-comment">#5.7版本不加上会报错，自己测的</span><br><span class="hljs-attr">server-id</span>=<span class="hljs-number">1</span><br><br><span class="hljs-comment">#配置二进制日志的格式</span><br><span class="hljs-attr">binlog_format</span>=STATEMENT<br><br></code></pre></td></tr></table></figure><h5 id="2-2-2-日志格式"><a href="#2-2-2-日志格式" class="headerlink" title="2.2.2 日志格式"></a>2.2.2 日志格式</h5><p><strong>STATEMENT</strong></p><p>该日志格式在日志文件中记录的都是SQL语句（statement），每一条对数据进行修改的SQL都会记录在日志文件中，通过Mysql提供的mysqlbinlog工具，可以清晰的查看到每条语句的文本。主从复制的时候，从库（slave）会将日志解析为原文本，并在从库重新执行一次。</p><p><strong>ROW</strong></p><p>该日志格式在日志文件中记录的是每一行的数据变更，而不是记录SQL语句。比如，执行SQL语句 ： update tb_book set status&#x3D;’1’ , 如果是STATEMENT 日志格式，在日志中会记录一行SQL文件； 如果是ROW，由于是对全表进行更新，也就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更。</p><p><strong>MIXED</strong></p><p>这是目前MySQL默认的日志格式，即混合了STATEMENT 和 ROW两种格式。默认情况下采用STATEMENT，但是在一些特殊情况下采用ROW来进行记录。MIXED 格式能尽量利用两种模式的优点，而避开他们的缺点。</p><h5 id="2-2-3-日志读取"><a href="#2-2-3-日志读取" class="headerlink" title="2.2.3 日志读取"></a>2.2.3 日志读取</h5><p>由于日志以二进制方式存储，不能直接读取，需要用mysqlbinlog工具来查看，语法如下 ：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">mysqlbinlog <span class="hljs-built_in">log</span>-<span class="hljs-built_in">file</span>；<br><br></code></pre></td></tr></table></figure><p><strong>查看STATEMENT格式日志</strong> </p><p>执行插入语句 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_book <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Lucene&#x27;</span>,<span class="hljs-string">&#x27;2088-05-01&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>);<br></code></pre></td></tr></table></figure><p> 查看日志文件 ：</p><p><img src="/images/mysql/1554079717375.png" alt="1554079717375"> </p><p>mysqlbin.index : 该文件是日志索引文件 ， 记录日志的文件名；</p><p>mysqlbing.000001 ：日志文件</p><p>查看日志内容 ：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysqlbinlog</span> mysqlbing.<span class="hljs-number">000001</span>；<br><br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1554080016778.png" alt="1554080016778"> </p><p><strong>查看ROW格式日志</strong></p><p>配置 :</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如 : mysqlbin.000001,mysqlbin.000002</span><br><span class="hljs-attr">log_bin</span>=mysqlbin<br><br><span class="hljs-comment">#配置二进制日志的格式</span><br><span class="hljs-attr">binlog_format</span>=ROW<br><br></code></pre></td></tr></table></figure><p>插入数据 :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_book <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;SpringCloud实战&#x27;</span>,<span class="hljs-string">&#x27;2088-05-05&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>);<br></code></pre></td></tr></table></figure><p>如果日志格式是 ROW , 直接查看数据 , 是查看不懂的 ; 可以在mysqlbinlog 后面加上参数 -vv  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL">mysqlbinlog <span class="hljs-operator">-</span>vv mysqlbin<span class="hljs-number">.000002</span> <br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1554095452022.png" alt="1554095452022"> </p><h5 id="2-2-4-日志删除"><a href="#2-2-4-日志删除" class="headerlink" title="2.2.4 日志删除"></a>2.2.4 日志删除</h5><p>对于比较繁忙的系统，由于每天生成日志量大 ，这些日志如果长时间不清楚，将会占用大量的磁盘空间。下面我们将会讲解几种删除日志的常见方法 ：</p><p><strong>方式一</strong> </p><p>通过 Reset Master 指令删除全部 binlog 日志，删除之后，日志编号，将从 xxxx.000001重新开始 。</p><p>查询之前 ，先查询下日志文件 ： </p><p><img src="/images/mysql/1554118609489.png" alt="1554118609489">   </p><p>执行删除日志指令： </p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">Reset</span> Master<br></code></pre></td></tr></table></figure><p>执行之后， 查看日志文件 ：</p><p><img src="/images/mysql/1554118675264.png" alt="1554118675264"> </p><p><strong>方式二</strong></p><p>执行指令 <code> purge  master logs to &#39;mysqlbin.******&#39;</code> ，该命令将删除  <code> ******</code> 编号之前的所有日志。 </p><p><strong>方式三</strong></p><p>执行指令 <code> purge master logs before &#39;yyyy-mm-dd hh24:mi:ss&#39;</code> ，该命令将删除日志为 “yyyy-mm-dd hh24:mi:ss” 之前产生的所有日志 。</p><p><strong>方式四</strong></p><p>设置参数 –expire_logs_days&#x3D;# ，此参数的含义是设置日志的过期天数， 过了指定的天数后日志将会被自动删除，这样将有利于减少DBA 管理日志的工作量。</p><p>配置如下 ： </p><p><img src="/images/mysql/1554125506938.png" alt="1554125506938"> </p><h4 id="2-3-查询日志"><a href="#2-3-查询日志" class="headerlink" title="2.3 查询日志"></a>2.3 查询日志</h4><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。</p><p>默认情况下， 查询日志是未开启的。如果需要开启查询日志，可以设置以下配置 ：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启 </span><br><span class="hljs-attr">general_log</span>=<span class="hljs-number">1</span><br><br><span class="hljs-comment">#设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.log </span><br><span class="hljs-attr">general_log_file</span>=file_name<br><br></code></pre></td></tr></table></figure><p>在 mysql 的配置文件 &#x2F;usr&#x2F;my.cnf 中配置如下内容 ： </p><p><img src="/images/mysql/1554128184632.png" alt="1554128184632"> </p><p>配置完毕之后，在数据库执行以下操作 ：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_book;<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_book <span class="hljs-keyword">where</span> id = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">update</span> tb_book <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;lucene入门指南&#x27;</span> <span class="hljs-keyword">where</span> id = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_book <span class="hljs-keyword">where</span> id &lt; <span class="hljs-number">8</span>;<br><br></code></pre></td></tr></table></figure><p>执行完毕之后， 再次来查询日志文件 ： </p><p><img src="/images/mysql/1554128089851.png" alt="1554128089851"> </p><h4 id="2-4-慢查询日志"><a href="#2-4-慢查询日志" class="headerlink" title="2.4 慢查询日志"></a>2.4 慢查询日志</h4><p>慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的SQL语句的日志。long_query_time 默认为 10 秒，最小为 0， 精度可以到微秒。</p><h5 id="2-4-1-文件位置和格式"><a href="#2-4-1-文件位置和格式" class="headerlink" title="2.4.1 文件位置和格式"></a>2.4.1 文件位置和格式</h5><p>慢查询日志默认是关闭的 。可以通过两个参数来控制慢查询日志 ：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 该参数用来控制慢查询日志是否开启， 可取值： 1 和 0 ， 1 代表开启， 0 代表关闭</span><br><span class="hljs-attr">slow_query_log</span>=<span class="hljs-number">1</span> <br><br><span class="hljs-comment"># 该参数用来指定慢查询日志的文件名</span><br><span class="hljs-attr">slow_query_log_file</span>=slow_query.log<br><br><span class="hljs-comment"># 该选项用来配置查询的时间限制， 超过这个时间将认为值慢查询， 将需要进行日志记录， 默认10s</span><br><span class="hljs-attr">long_query_time</span>=<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h5 id="2-4-2-日志的读取"><a href="#2-4-2-日志的读取" class="headerlink" title="2.4.2 日志的读取"></a>2.4.2 日志的读取</h5><p>和错误日志、查询日志一样，慢查询日志记录的格式也是纯文本，可以被直接读取。</p><p>1） 查询long_query_time 的值。</p><p><img src="/images/mysql/1554130333472.png" alt="1554130333472"> </p><p>2） 执行查询操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, title,price,num ,status <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1554130448709.png" alt="1554130448709"></p><p>由于该语句执行时间很短，为0s ， 所以不会记录在慢查询日志中。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> <span class="hljs-built_in">title</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%阿尔卡特 (OT-927) 炭黑 联通3G手机 双卡双待165454%&#x27;</span> ;<br><br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1554130532577.png" alt="1554130532577"> </p><p>该SQL语句 ， 执行时长为 26.77s ，超过10s ， 所以会记录在慢查询日志文件中。</p><p>3） 查看慢查询日志文件</p><p>直接通过cat 指令查询该日志文件 ： </p><p><img src="/images/mysql/1554130669360.png" alt="1554130669360"> </p><p>如果慢查询日志内容很多， 直接查看文件，比较麻烦， 这个时候可以借助于mysql自带的 mysqldumpslow 工具， 来对慢查询日志进行分类汇总。 </p><p><img src="/images/mysql/1554130856485.png" alt="1554130856485"> </p><h3 id="3-Mysql复制"><a href="#3-Mysql复制" class="headerlink" title="3. Mysql复制"></a>3. Mysql复制</h3><h4 id="3-1-复制概述"><a href="#3-1-复制概述" class="headerlink" title="3.1 复制概述"></a>3.1 复制概述</h4><p>复制是指将主数据库的DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p><p>MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状复制。</p><h4 id="3-2-复制原理"><a href="#3-2-复制原理" class="headerlink" title="3.2 复制原理"></a>3.2 复制原理</h4><p>MySQL 的主从复制原理如下。</p><p><img src="/images/mysql/1.jpg" alt="1554423698190"> </p><p>从上层来看，复制分成三步：</p><ul><li><p>Master 主库在事务提交时，会把数据变更作为时间 Events 记录在二进制日志文件 Binlog 中。</p></li><li><p>主库推送二进制日志文件 Binlog 中的日志事件到从库的中继日志 Relay Log 。</p></li><li><p>slave重做中继日志中的事件，将改变反映它自己的数据。</p></li></ul><h4 id="3-3-复制优势"><a href="#3-3-复制优势" class="headerlink" title="3.3 复制优势"></a>3.3 复制优势</h4><p>MySQL 复制的有点主要包含以下三个方面：</p><ul><li><p>主库出现问题，可以快速切换到从库提供服务。</p></li><li><p>可以在从库上执行查询操作，从主库中更新，实现读写分离，降低主库的访问压力。</p></li><li><p>可以在从库中执行备份，以避免备份期间影响主库的服务。</p></li></ul><h4 id="3-4-搭建步骤"><a href="#3-4-搭建步骤" class="headerlink" title="3.4 搭建步骤"></a>3.4 搭建步骤</h4><h5 id="3-4-1-master"><a href="#3-4-1-master" class="headerlink" title="3.4.1 master"></a>3.4.1 master</h5><p>1） 在master 的配置文件（&#x2F;usr&#x2F;my.cnf）中，配置如下内容：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#mysql 服务ID,保证整个集群环境中唯一</span><br><span class="hljs-attr">server-id</span>=<span class="hljs-string">1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#mysql binlog 日志的存储路径和文件名</span><br><span class="hljs-attr">log-bin</span>=<span class="hljs-string">/var/lib/mysql/mysqlbin</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#错误日志,默认已经开启</span><br><span class="hljs-comment">#log-err</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#mysql的安装目录</span><br><span class="hljs-comment">#basedir</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#mysql的临时目录</span><br><span class="hljs-comment">#tmpdir</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#mysql的数据存放目录</span><br><span class="hljs-comment">#datadir</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#是否只读,1 代表只读, 0 代表读写</span><br><span class="hljs-attr">read-only</span>=<span class="hljs-string">0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#忽略的数据, 指不需要同步的数据库</span><br><span class="hljs-attr">binlog-ignore-db</span>=<span class="hljs-string">mysql</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#指定同步的数据库</span><br><span class="hljs-comment">#binlog-do-db=db01</span><br></code></pre></td></tr></table></figure><p>2） 执行完毕之后，需要重启Mysql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">service mysql restart ；<br></code></pre></td></tr></table></figure><p>3） 创建同步数据的账户，并且进行授权操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">#从数据库的账号，不是系统账号，ip从机ip，主机密码<br><span class="hljs-keyword">grant</span> replication slave <span class="hljs-keyword">on</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;itcast&#x27;</span>@<span class="hljs-string">&#x27;192.168.192.131&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;itcast&#x27;</span>;<br><br>flush privileges;<br></code></pre></td></tr></table></figure><p>4） 查看master状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> master status;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1554477759735.png" alt="1554477759735"> </p><p>字段含义：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">File : 从哪个日志文件开始推送日志文件 <br>Position ： 从哪个位置开始推送日志<br>Binlog_Ignore_DB : 指定不需要同步的数据库<br></code></pre></td></tr></table></figure><h5 id="3-4-2-slave"><a href="#3-4-2-slave" class="headerlink" title="3.4.2 slave"></a>3.4.2 slave</h5><p>1） 在 slave 端配置文件中，配置如下内容：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#mysql服务端ID,唯一</span><br><span class="hljs-attr">server-id</span>=<span class="hljs-string">2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#指定binlog日志</span><br><span class="hljs-attr">log-bin</span>=<span class="hljs-string">/var/lib/mysql/mysqlbin</span><br></code></pre></td></tr></table></figure><p>2）  执行完毕之后，需要重启Mysql：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">service mysql <span class="hljs-built_in">restart</span>；<br></code></pre></td></tr></table></figure><p>3） 执行如下指令 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#用户是主机mysql用户，不是系统用户，都是下划线<br>change master <span class="hljs-keyword">to</span> master_host<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;192.168.192.130&#x27;</span>, master_user<span class="hljs-operator">=</span><span class="hljs-string">&#x27;itcast&#x27;</span>, master_password<span class="hljs-operator">=</span><span class="hljs-string">&#x27;itcast&#x27;</span>, master_log_file<span class="hljs-operator">=</span><span class="hljs-string">&#x27;mysqlbin.000001&#x27;</span>, master_log_pos<span class="hljs-operator">=</span><span class="hljs-number">413</span>;<br></code></pre></td></tr></table></figure><p>指定当前从库对应的主库的IP地址，用户名，密码，从哪个日志文件开始的那个位置开始同步推送日志。</p><p>4） 开启同步操作</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-literal">start</span> <span class="hljs-literal">slave</span>;<br><br>show <span class="hljs-literal">slave</span> status;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1554479387365.png" alt="1554479387365"> </p><p>5） 停止同步操作</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-literal">stop</span> <span class="hljs-literal">slave</span>;<br></code></pre></td></tr></table></figure><h5 id="3-4-3-验证同步操作"><a href="#3-4-3-验证同步操作" class="headerlink" title="3.4.3 验证同步操作"></a>3.4.3 验证同步操作</h5><p>1） 在主库中创建数据库，创建表，并插入数据 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database db01;<br><br><span class="hljs-keyword">user</span> db01;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>(<br>id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>sex <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>),<br><span class="hljs-keyword">primary</span> key (id)<br>)engine<span class="hljs-operator">=</span>innodb <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(id,name,sex) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(id,name,sex) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Trigger&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(id,name,sex) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Dawn&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br></code></pre></td></tr></table></figure><p>2） 在从库中查询数据，进行验证 ：</p><p>在从库中，可以查看到刚才创建的数据库：</p><p><img src="/images/mysql/1554544658640.png" alt="1554544658640"> </p><p>在该数据库中，查询user表中的数据：</p><p><img src="/images/mysql/1554544679538.png" alt="1554544679538"> </p><h3 id="4-综合案例"><a href="#4-综合案例" class="headerlink" title="4. 综合案例"></a>4. 综合案例</h3><h4 id="4-1-需求分析"><a href="#4-1-需求分析" class="headerlink" title="4.1 需求分析"></a>4.1 需求分析</h4><p>在业务系统中，需要记录当前业务系统的访问日志，该访问日志包含：操作人，操作时间，访问类，访问方法，请求参数，请求结果，请求结果类型，请求时长 等信息。记录详细的系统访问日志，主要便于对系统中的用户请求进行追踪，并且在系统 的管理后台可以查看到用户的访问记录。</p><p>记录系统中的日志信息，可以通过Spring 框架的AOP来实现。具体的请求处理流程，如下：</p><p><img src="/images/mysql/1555075760661.png" alt="1555075760661"> </p><h4 id="4-2-搭建案例环境"><a href="#4-2-搭建案例环境" class="headerlink" title="4.2 搭建案例环境"></a>4.2 搭建案例环境</h4><h5 id="4-2-1-数据库表"><a href="#4-2-1-数据库表" class="headerlink" title="4.2.1 数据库表"></a>4.2.1 数据库表</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE mysql_demo <span class="hljs-keyword">DEFAULT</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 ；<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `brand` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;品牌名称&#x27;</span>,<br>  `first_char` <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;品牌首字母&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `item` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;商品id&#x27;</span>,<br>  `title` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品标题&#x27;</span>,<br>  `price` <span class="hljs-keyword">double</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品价格，单位为：元&#x27;</span>,<br>  `num` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;库存数量&#x27;</span>,<br>  `categoryid` <span class="hljs-type">bigint</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;所属类目，叶子类目&#x27;</span>,<br>  `status` <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品状态，1-正常，2-下架，3-删除&#x27;</span>,<br>  `sellerid` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商家ID&#x27;</span>,<br>  `createtime` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `updatetime` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;更新时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;商品表&#x27;</span>;<br><br><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">user</span>` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `username` <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `password` <span class="hljs-type">varchar</span>(<span class="hljs-number">96</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `birthday` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `sex` <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `email` <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `phone` <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `qq` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `operation_log` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;ID&#x27;</span>,<br>  `operate_class` <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;操作类&#x27;</span>,<br>  `operate_method` <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;操作方法&#x27;</span>,<br>  `return_class` <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;返回值类型&#x27;</span>,<br>  `operate_user` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;操作用户&#x27;</span>,<br>  `operate_time` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;操作时间&#x27;</span>,<br>  `param_and_value` <span class="hljs-type">varchar</span>(<span class="hljs-number">500</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;请求参数名及参数值&#x27;</span>,<br>  `cost_time` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;执行方法耗时, 单位 ms&#x27;</span>,<br>  `return_value` <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;返回值&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB  <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4;<br><br></code></pre></td></tr></table></figure><h5 id="4-2-2-pom-xml"><a href="#4-2-2-pom-xml" class="headerlink" title="4.2.2 pom.xml"></a>4.2.2 pom.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slf4j.version</span>&gt;</span>1.6.6<span class="hljs-tag">&lt;/<span class="hljs-name">slf4j.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">log4j.version</span>&gt;</span>1.2.12<span class="hljs-tag">&lt;/<span class="hljs-name">log4j.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mybatis.version</span>&gt;</span>3.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span> <span class="hljs-comment">&lt;!-- spring --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.16.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-support<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-orm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><br><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8080<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">uriEncoding</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">uriEncoding</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="4-2-3-web-xml"><a href="#4-2-3-web-xml" class="headerlink" title="4.2.3 web.xml"></a>4.2.3 web.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.5&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 解决post乱码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.do<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>log-datalist.html<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="4-2-4-db-properties"><a href="#4-2-4-db-properties" class="headerlink" title="4.2.4 db.properties"></a>4.2.4 db.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc.driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://192.168.142.128:3306/mysql_demo</span><br><span class="hljs-attr">jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">jdbc.password</span>=<span class="hljs-string">itcast</span><br></code></pre></td></tr></table></figure><h5 id="4-2-5-applicationContext-xml"><a href="#4-2-5-applicationContext-xml" class="headerlink" title="4.2.5 applicationContext.xml"></a>4.2.5 applicationContext.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 加载配置文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:db.properties&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 配置 spring 创建容器时要扫描的包 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;cn.itcast&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">context:exclude-filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 配置 MyBatis 的 Session 工厂 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;typeAliasesPackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;cn.itcast.pojo&quot;</span>/&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 配置数据源 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 配置 Mapper 扫描器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;cn.itcast.mapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 配置事务管理器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 配置事务的注解驱动 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tx:annotation-driven</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="4-2-6-springmvc-xml"><a href="#4-2-6-springmvc-xml" class="headerlink" title="4.2.6 springmvc.xml"></a>4.2.6 springmvc.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;cn.itcast.controller&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="4-2-7-导入基础工程"><a href="#4-2-7-导入基础工程" class="headerlink" title="4.2.7 导入基础工程"></a>4.2.7 导入基础工程</h5><p><img src="/images/mysql/1555076434270.png" alt="1555076434270"> </p><h4 id="4-3-通过AOP记录操作日志"><a href="#4-3-通过AOP记录操作日志" class="headerlink" title="4.3 通过AOP记录操作日志"></a>4.3 通过AOP记录操作日志</h4><h5 id="4-3-1-自定义注解"><a href="#4-3-1-自定义注解" class="headerlink" title="4.3.1 自定义注解"></a>4.3.1 自定义注解</h5><p>通过自定义注解，来标示方法需不需要进行记录日志，如果该方法在访问时需要记录日志，则在该方法上标示该注解既可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> OperateLog &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-3-2-定义通知类"><a href="#4-3-2-定义通知类" class="headerlink" title="4.3.2 定义通知类"></a>4.3.2 定义通知类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperateAdvice</span> &#123;<br>   <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> Logger.getLogger(OperateAdvice.class);<br>   <br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> OperationLogService operationLogService;<br>   <br><br>   <span class="hljs-meta">@Around(&quot;execution(* cn.itcast.controller.*.*(..)) &amp;&amp; @annotation(operateLog)&quot;)</span><br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">insertLogAround</span><span class="hljs-params">(ProceedingJoinPoint pjp , OperateLog operateLog)</span> <span class="hljs-keyword">throws</span> Throwable&#123;<br>      System.out.println(<span class="hljs-string">&quot; ************************ 记录日志 [start]  ****************************** &quot;</span>);<br>      <br>      <span class="hljs-type">OperationLog</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OperationLog</span>();<br>      <br>      <span class="hljs-type">DateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br>      op.setOperateTime(sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>      op.setOperateUser(DataUtils.getRandStr(<span class="hljs-number">8</span>));<br>      <br>      op.setOperateClass(pjp.getTarget().getClass().getName());<br>      op.setOperateMethod(pjp.getSignature().getName());<br>      <br>      <span class="hljs-comment">//获取方法调用时传递的参数</span><br>      Object[] args = pjp.getArgs();<br>      op.setParamAndValue(Arrays.toString(args));<br><br>      <span class="hljs-type">long</span> <span class="hljs-variable">start_time</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>      <span class="hljs-comment">//放行</span><br>      <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> pjp.proceed();<br><br>      <span class="hljs-type">long</span> <span class="hljs-variable">end_time</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>      op.setCostTime(end_time - start_time);<br><br>      <span class="hljs-keyword">if</span>(object != <span class="hljs-literal">null</span>)&#123;<br>         op.setReturnClass(object.getClass().getName());<br>         op.setReturnValue(object.toString());<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>         op.setReturnClass(<span class="hljs-string">&quot;java.lang.Object&quot;</span>);<br>         op.setParamAndValue(<span class="hljs-string">&quot;void&quot;</span>);<br>      &#125;<br><br>      log.error(JsonUtils.obj2JsonString(op));<br><br>      operationLogService.insert(op);<br>      <br>      System.out.println(<span class="hljs-string">&quot; ************************** 记录日志 [end]  *************************** &quot;</span>);<br>      <br>      <span class="hljs-keyword">return</span> object;<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-3-3-方法上加注解"><a href="#4-3-3-方法上加注解" class="headerlink" title="4.3.3 方法上加注解"></a>4.3.3 方法上加注解</h5><p>在需要记录日志的方法上加上注解@OperateLog。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@OperateLog</span><br><span class="hljs-meta">@RequestMapping(&quot;/insert&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Brand brand)</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        brandService.insert(brand);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;操作成功&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;操作失败&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-日志查询后端代码实现"><a href="#4-4-日志查询后端代码实现" class="headerlink" title="4.4 日志查询后端代码实现"></a>4.4 日志查询后端代码实现</h4><h5 id="4-4-1-Mapper接口"><a href="#4-4-1-Mapper接口" class="headerlink" title="4.4.1 Mapper接口"></a>4.4.1 Mapper接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OperationLogMapper</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(OperationLog operationLog)</span>;<br><br>    <span class="hljs-keyword">public</span> List&lt;OperationLog&gt; <span class="hljs-title function_">selectListByCondition</span><span class="hljs-params">(Map dataMap)</span>;<br><br>    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">countByCondition</span><span class="hljs-params">(Map dataMap)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-4-2-Mapper-xml-映射配置文件"><a href="#4-4-2-Mapper-xml-映射配置文件" class="headerlink" title="4.4.2 Mapper.xml 映射配置文件"></a>4.4.2 Mapper.xml 映射配置文件</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;cn.itcast.mapper.OperationLogMapper&quot;</span> &gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;operationLog&quot;</span>&gt;</span><br>        INSERT INTO operation_log(id,return_value,return_class,operate_user,operate_time,param_and_value,<br>        operate_class,operate_method,cost_time)<br>      VALUES(NULL,#&#123;returnValue&#125;,#&#123;returnClass&#125;,#&#123;operateUser&#125;,#&#123;operateTime&#125;,#&#123;paramAndValue&#125;,<br>        #&#123;operateClass&#125;,#&#123;operateMethod&#125;,#&#123;costTime&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectListByCondition&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;operationLog&quot;</span>&gt;</span><br>      select<br>        id ,<br>        operate_class as operateClass ,<br>        operate_method as operateMethod,<br>        return_class as returnClass,<br>        operate_user as operateUser,<br>        operate_time as operateTime,<br>        param_and_value as paramAndValue,<br>        cost_time as costTime,<br>        return_value as returnValue<br>      from operation_log<br>      <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;oplog_where&quot;</span>/&gt;</span><br>      limit #&#123;start&#125;,#&#123;size&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;long&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>        select count(*) from operation_log<br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;oplog_where&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;oplog_where&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;operateClass != null and operateClass != &#x27;&#x27; &quot;</span>&gt;</span><br>                and operate_class = #&#123;operateClass&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;operateMethod != null and operateMethod != &#x27;&#x27; &quot;</span>&gt;</span><br>                and operate_method = #&#123;operateMethod&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;returnClass != null and returnClass != &#x27;&#x27; &quot;</span>&gt;</span><br>                and return_class = #&#123;returnClass&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;costTime != null&quot;</span>&gt;</span><br>                and cost_time =  #&#123;costTime&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="4-4-3-Service"><a href="#4-4-3-Service" class="headerlink" title="4.4.3 Service"></a>4.4.3 Service</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationLogService</span> &#123;<br><br>    <span class="hljs-comment">//private static Logger logger = Logger.getLogger(OperationLogService.class);</span><br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OperationLogMapper operationLogMapper;<br><br>    <span class="hljs-comment">//插入数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(OperationLog operationLog)</span>&#123;<br>        operationLogMapper.insert(operationLog);<br>    &#125;<br><br>    <span class="hljs-comment">//根据条件查询</span><br>    <span class="hljs-keyword">public</span> PageResult <span class="hljs-title function_">selectListByCondition</span><span class="hljs-params">(Map dataMap, Integer pageNum , Integer pageSize)</span>&#123;<br><br>       <span class="hljs-keyword">if</span>(paramMap ==<span class="hljs-literal">null</span>)&#123;<br>            paramMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        &#125;<br>        paramMap.put(<span class="hljs-string">&quot;start&quot;</span> , (pageNum-<span class="hljs-number">1</span>)*rows);<br>        paramMap.put(<span class="hljs-string">&quot;rows&quot;</span>,rows);<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">costTime</span> <span class="hljs-operator">=</span> paramMap.get(<span class="hljs-string">&quot;costTime&quot;</span>);<br>        <span class="hljs-keyword">if</span>(costTime != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;&quot;</span>.equals(costTime.toString()))&#123;<br>                paramMap.put(<span class="hljs-string">&quot;costTime&quot;</span>,<span class="hljs-literal">null</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                paramMap.put(<span class="hljs-string">&quot;costTime&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(paramMap.get(<span class="hljs-string">&quot;costTime&quot;</span>).toString()));<br>            &#125;<br>        &#125;<br><br>        System.out.println(dataMap);<br><br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">countStart</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> operationLogMapper.countByCondition(dataMap);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">countEnd</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;Count Cost Time : &quot;</span> + (countEnd-countStart)+<span class="hljs-string">&quot; ms&quot;</span>);<br><br><br>        List&lt;OperationLog&gt; list = operationLogMapper.selectListByCondition(dataMap);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">queryEnd</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;Query Cost Time : &quot;</span> + (queryEnd-countEnd)+<span class="hljs-string">&quot; ms&quot;</span>);<br><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageResult</span>(count,list);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-4-4-Controller"><a href="#4-4-4-Controller" class="headerlink" title="4.4.4 Controller"></a>4.4.4 Controller</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/operationLog&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationLogController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OperationLogService operationLogService;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/findList&quot;)</span><br>    <span class="hljs-keyword">public</span> PageResult <span class="hljs-title function_">findList</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Map dataMap, Integer pageNum , Integer pageSize)</span>&#123;<br>        <span class="hljs-type">PageResult</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> operationLogService.selectListByCondition(dataMap, pageNum, pageSize);<br>        <span class="hljs-keyword">return</span> page;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-5-日志查询前端代码实现"><a href="#4-5-日志查询前端代码实现" class="headerlink" title="4.5 日志查询前端代码实现"></a>4.5 日志查询前端代码实现</h4><p>前端代码使用 BootStrap + AdminLTE 进行布局， 使用Vuejs 进行视图层展示。</p><h5 id="4-5-1-js"><a href="#4-5-1-js" class="headerlink" title="4.5.1 js"></a>4.5.1 js</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">       <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript">       <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">           <span class="hljs-attr">dataList</span>:[],</span><br><span class="language-javascript">           <span class="hljs-attr">searchEntity</span>:&#123;</span><br><span class="language-javascript">               <span class="hljs-attr">operateClass</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">               <span class="hljs-attr">operateMethod</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">               <span class="hljs-attr">returnClass</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">               <span class="hljs-attr">costTime</span>:<span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">           &#125;,</span><br><span class="language-javascript"></span><br><span class="language-javascript">           <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>,  <span class="hljs-comment">//显示的是哪一页</span></span><br><span class="language-javascript">           <span class="hljs-attr">pageSize</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">//每一页显示的数据条数</span></span><br><span class="language-javascript">           <span class="hljs-attr">total</span>: <span class="hljs-number">150</span>, <span class="hljs-comment">//记录总数</span></span><br><span class="language-javascript">           <span class="hljs-attr">maxPage</span>:<span class="hljs-number">8</span>  <span class="hljs-comment">//最大页数</span></span><br><span class="language-javascript">       &#125;,</span><br><span class="language-javascript">       <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">           <span class="hljs-attr">pageHandler</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">page</span>) &#123;</span><br><span class="language-javascript">               <span class="hljs-variable language_">this</span>.<span class="hljs-property">page</span> = page;</span><br><span class="language-javascript">               <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">search</span>();</span><br><span class="language-javascript">           &#125;,</span><br><span class="language-javascript"></span><br><span class="language-javascript">           <span class="hljs-attr">search</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">               <span class="hljs-keyword">var</span> _this = <span class="hljs-variable language_">this</span>;</span><br><span class="language-javascript">               <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">showLoading</span>();</span><br><span class="language-javascript">               axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/operationLog/findList.do?pageNum=&#x27;</span> + _this.<span class="hljs-property">page</span> + <span class="hljs-string">&quot;&amp;pageSize=&quot;</span> + _this.<span class="hljs-property">pageSize</span>, _this.<span class="hljs-property">searchEntity</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;</span><br><span class="language-javascript">                   <span class="hljs-keyword">if</span> (response) &#123;</span><br><span class="language-javascript">                       _this.<span class="hljs-property">dataList</span> = response.<span class="hljs-property">data</span>.<span class="hljs-property">dataList</span>;</span><br><span class="language-javascript">                       _this.<span class="hljs-property">total</span> = response.<span class="hljs-property">data</span>.<span class="hljs-property">total</span>;</span><br><span class="language-javascript">                       _this.<span class="hljs-title function_">hideLoading</span>();</span><br><span class="language-javascript">                   &#125;</span><br><span class="language-javascript">               &#125;)</span><br><span class="language-javascript">           &#125;,</span><br><span class="language-javascript"></span><br><span class="language-javascript">           <span class="hljs-attr">showLoading</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">               $(<span class="hljs-string">&#x27;#loadingModal&#x27;</span>).<span class="hljs-title function_">modal</span>(&#123;<span class="hljs-attr">backdrop</span>: <span class="hljs-string">&#x27;static&#x27;</span>, <span class="hljs-attr">keyboard</span>: <span class="hljs-literal">false</span>&#125;);</span><br><span class="language-javascript">           &#125;,</span><br><span class="language-javascript"></span><br><span class="language-javascript">           <span class="hljs-attr">hideLoading</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">               $(<span class="hljs-string">&#x27;#loadingModal&#x27;</span>).<span class="hljs-title function_">modal</span>(<span class="hljs-string">&#x27;hide&#x27;</span>);</span><br><span class="language-javascript">           &#125;,</span><br><span class="language-javascript">       &#125;,</span><br><span class="language-javascript"></span><br><span class="language-javascript">       <span class="hljs-attr">created</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">           <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">pageHandler</span>(<span class="hljs-number">1</span>);</span><br><span class="language-javascript">       &#125;</span><br><span class="language-javascript">   &#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="4-5-2-列表数据展示"><a href="#4-5-2-列表数据展示" class="headerlink" title="4.5.2 列表数据展示"></a>4.5.2 列表数据展示</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in dataList&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;item.id&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;item.operateClass&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;item.operateMethod&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;item.returnClass&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;item.returnValue&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;item.operateUser&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;item.operateTime&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;item.costTime&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-center&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn bg-olive btn-xs&quot;</span>&gt;</span>详情<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn bg-olive btn-xs&quot;</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><p>4.5.3 分页插件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">zpagenav</span> <span class="hljs-attr">v-bind:page</span>=<span class="hljs-string">&quot;page&quot;</span> <span class="hljs-attr">v-bind:page-size</span>=<span class="hljs-string">&quot;pageSize&quot;</span> <span class="hljs-attr">v-bind:total</span>=<span class="hljs-string">&quot;total&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">v-bind:max-page</span>=<span class="hljs-string">&quot;maxPage&quot;</span>  <span class="hljs-attr">v-on:pagehandler</span>=<span class="hljs-string">&quot;pageHandler&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">zpagenav</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-6-联调测试"><a href="#4-6-联调测试" class="headerlink" title="4.6 联调测试"></a>4.6 联调测试</h4><p>可以通过postman来访问业务系统，再查看数据库中的日志信息，验证能不能将用户的访问日志记录下来。</p><p><img src="/images/mysql/1555077276426.png" alt="1555077276426"> </p><h4 id="4-7-分析性能问题"><a href="#4-7-分析性能问题" class="headerlink" title="4.7 分析性能问题"></a>4.7 分析性能问题</h4><p>系统中用户访问日志的数据量，随着时间的推移，这张表的数据量会越来越大，因此我们需要根据业务需求，来对日志查询模块的性能进行优化。</p><p>1） 分页查询优化</p><p>由于在进行日志查询时，是进行分页查询，那也就意味着，在查看时，至少需要查询两次：</p><p>A. 查询符合条件的总记录数。–&gt; count 操作</p><p>B. 查询符合条件的列表数据。–&gt; 分页查询 limit 操作</p><p>通常来说，count() 都需要扫描大量的行（意味着需要访问大量的数据）才能获得精确的结果，因此是很难对该SQL进行优化操作的。如果需要对count进行优化，可以采用另外一种思路，可以增加汇总表，或者redis缓存来专门记录该表对应的记录数，这样的话，就可以很轻松的实现汇总数据的查询，而且效率很高，但是这种统计并不能保证百分之百的准确 。对于数据库的操作，“快速、精确、实现简单”，三者永远只能满足其二，必须舍掉其中一个。</p><p>2） 条件查询优化</p><p>针对于条件查询,需要对查询条件,及排序字段建立索引。</p><p>3） 读写分离</p><p>通过主从复制集群，来完成读写分离，使写操作走主节点， 而读操作，走从节点。</p><p>4） MySQL服务器优化</p><p>5） 应用优化</p><h4 id="4-8-性能优化-分页"><a href="#4-8-性能优化-分页" class="headerlink" title="4.8 性能优化 - 分页"></a>4.8 性能优化 - 分页</h4><h5 id="4-8-1-优化count"><a href="#4-8-1-优化count" class="headerlink" title="4.8.1 优化count"></a>4.8.1 优化count</h5><p>创建一张表用来记录日志表的总数据量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> log_counter(<br>logcount <span class="hljs-type">bigint</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>)engine <span class="hljs-operator">=</span> innodb <span class="hljs-keyword">default</span> CHARSET <span class="hljs-operator">=</span> utf8;<br></code></pre></td></tr></table></figure><p>在每次插入数据之后，更新该表 ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateLogCounter&quot;</span> &gt;</span><br>    update log_counter set logcount = logcount + 1<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在进行分页查询时, 获取总记录数，从该表中查询既可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countLogFromCounter&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;long&quot;</span>&gt;</span><br>    select logcount from log_counter limit 1<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="4-8-2-优化-limit"><a href="#4-8-2-优化-limit" class="headerlink" title="4.8.2 优化 limit"></a>4.8.2 优化 limit</h5><p>在进行分页时，一般通过创建覆盖索引，能够比较好的提高性能。一个非常常见，而又非常头疼的分页场景就是 “limit 1000000,10” ，此时MySQL需要搜索出前1000010 条记录后，仅仅需要返回第 1000001 到 1000010 条记录，前1000000 记录会被抛弃，查询代价非常大。 </p><p><img src="/images/mysql/1555081714638.png" alt="1555081714638"> </p><p>当点击比较靠后的页码时，就会出现这个问题，查询效率非常慢。</p><p>优化SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> operation_log limit <span class="hljs-number">3000000</span> , <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>将上述SQL优化为 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> operation_log t , (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> operation_log <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">3000000</span>,<span class="hljs-number">10</span>) b <span class="hljs-keyword">where</span> t.id <span class="hljs-operator">=</span> b.id ;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectListByCondition&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;operationLog&quot;</span>&gt;</span><br>  select<br>    id ,<br>    operate_class as operateClass ,<br>    operate_method as operateMethod,<br>    return_class as returnClass,<br>    operate_user as operateUser,<br>    operate_time as operateTime,<br>    param_and_value as paramAndValue,<br>    cost_time as costTime,<br>    return_value as returnValue<br>  from operation_log t,<br>    <br>  (select id from operation_log <br>  <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;oplog_where&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>  order by id limit #&#123;start&#125;,#&#123;rows&#125;) b  where t.id = b.id  <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-9-性能优化-索引"><a href="#4-9-性能优化-索引" class="headerlink" title="4.9 性能优化 - 索引"></a>4.9 性能优化 - 索引</h4><p><img src="/images/mysql/1555152703824.png" alt="1555152703824"></p><p>当根据操作人进行查询时， 查询的效率很低，耗时比较长。原因就是因为在创建数据库表结构时，并没有针对于 操作人 字段建立索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> INDEX idx_user_method_return_cost <span class="hljs-keyword">ON</span> operation_log(operate_user,operate_method,return_class,cost_time);<br></code></pre></td></tr></table></figure><p>同上 ， 为了查询效率高，我们也需要对 操作方法、返回值类型、操作耗时 等字段进行创建索引，以提高查询效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> INDEX idx_optlog_method_return_cost <span class="hljs-keyword">ON</span> operation_log(operate_method,return_class,cost_time);<br><br><span class="hljs-keyword">CREATE</span> INDEX idx_optlog_return_cost <span class="hljs-keyword">ON</span> operation_log(return_class,cost_time);<br><br><span class="hljs-keyword">CREATE</span> INDEX idx_optlog_cost <span class="hljs-keyword">ON</span> operation_log(cost_time);<br><br></code></pre></td></tr></table></figure><h4 id="4-10-性能优化-排序"><a href="#4-10-性能优化-排序" class="headerlink" title="4.10 性能优化 - 排序"></a>4.10 性能优化 - 排序</h4><p>在查询数据时，如果业务需求中需要我们对结果内容进行了排序处理 , 这个时候,我们还需要对排序的字段建立适当的索引, 来提高排序的效率 。</p><h4 id="4-11-性能优化-读写分离"><a href="#4-11-性能优化-读写分离" class="headerlink" title="4.11 性能优化 - 读写分离"></a>4.11 性能优化 - 读写分离</h4><h5 id="4-11-1-概述"><a href="#4-11-1-概述" class="headerlink" title="4.11.1 概述"></a>4.11.1 概述</h5><p>在Mysql主从复制的基础上，可以使用读写分离来降低单台Mysql节点的压力，从而来提高访问效率，读写分离的架构如下：</p><p><img src="/images/mysql/1555235426739.png" alt="1555235426739"> </p><p>对于读写分离的实现，可以通过Spring AOP 来进行动态的切换数据源，进行操作 ：</p><h5 id="4-11-2-实现方式"><a href="#4-11-2-实现方式" class="headerlink" title="4.11.2 实现方式"></a>4.11.2 实现方式</h5><p>db.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc.write.driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">jdbc.write.url</span>=<span class="hljs-string">jdbc:mysql://192.168.142.128:3306/mysql_demo</span><br><span class="hljs-attr">jdbc.write.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">jdbc.write.password</span>=<span class="hljs-string">itcast</span><br><br><span class="hljs-attr">jdbc.read.driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">jdbc.read.url</span>=<span class="hljs-string">jdbc:mysql://192.168.142.129:3306/mysql_demo</span><br><span class="hljs-attr">jdbc.read.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">jdbc.read.password</span>=<span class="hljs-string">itcast</span><br></code></pre></td></tr></table></figure><p>applicationContext-datasource.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!-- 配置数据源 - Read --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;readDataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;close&quot;</span>  <span class="hljs-attr">lazy-init</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.read.driver&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.read.url&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.read.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.read.password&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!-- 配置数据源 - Write --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;writeDataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>  <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;close&quot;</span>  <span class="hljs-attr">lazy-init</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.write.driver&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.write.url&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.write.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.write.password&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!-- 配置动态分配的读写 数据源 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cn.itcast.aop.datasource.ChooseDataSource&quot;</span> <span class="hljs-attr">lazy-init</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;targetDataSources&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">key-type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">&quot;javax.sql.DataSource&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;write&quot;</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">&quot;writeDataSource&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;read&quot;</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">&quot;readDataSource&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultTargetDataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;writeDataSource&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;methodType&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">key-type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;read&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;,get,select,count,list,query,find&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;write&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;,add,create,update,delete,remove,insert&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ChooseDataSource</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChooseDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRoutingDataSource</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; METHOD_TYPE_MAP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实现父类中的抽象方法，获取数据源名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">determineCurrentLookupKey</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> DataSourceHandler.getDataSource();<br>    &#125;<br><br>    <span class="hljs-comment">// 设置方法名前缀对应的数据源</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMethodType</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String key : map.keySet()) &#123;<br>            List&lt;String&gt; v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>            String[] types = map.get(key).split(<span class="hljs-string">&quot;,&quot;</span>);<br>            <span class="hljs-keyword">for</span> (String type : types) &#123;<br>                <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(type)) &#123;<br>                    v.add(type);<br>                &#125;<br>            &#125;<br>            METHOD_TYPE_MAP.put(key, v);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;METHOD_TYPE_MAP : &quot;</span>+METHOD_TYPE_MAP);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DataSourceHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceHandler</span> &#123;<br><br>    <span class="hljs-comment">// 数据源名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;String&gt; holder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;String&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在项目启动的时候将配置的读、写数据源加到holder中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putDataSource</span><span class="hljs-params">(String datasource)</span> &#123;<br>        holder.set(datasource);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从holer中获取数据源字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getDataSource</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> holder.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DataSourceAspect</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Order(-9999)</span><br><span class="hljs-meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceAspect</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-built_in">this</span>.getClass());<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 配置前置通知,使用在方法aspect()上注册的切入点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Before(&quot;execution(* cn.itcast.service.*.*(..))&quot;)</span><br>    <span class="hljs-meta">@Order(-9999)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(JoinPoint point)</span> &#123;<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> point.getTarget().getClass().getName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> point.getSignature().getName();<br>        logger.info(className + <span class="hljs-string">&quot;.&quot;</span> + method + <span class="hljs-string">&quot;(&quot;</span> + Arrays.asList(point.getArgs())+ <span class="hljs-string">&quot;)&quot;</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (String key : ChooseDataSource.METHOD_TYPE_MAP.keySet()) &#123;<br>                <span class="hljs-keyword">for</span> (String type : ChooseDataSource.METHOD_TYPE_MAP.get(key)) &#123;<br>                    <span class="hljs-keyword">if</span> (method.startsWith(type)) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;key : &quot;</span> + key);<br>                        DataSourceHandler.putDataSource(key);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 @Order(-9999) 注解来控制事务管理器, 与该通知类的加载顺序 , 需要让通知类 , 先加载 , 来判定使用哪个数据源 .</p><h5 id="4-11-3-验证"><a href="#4-11-3-验证" class="headerlink" title="4.11.3 验证"></a>4.11.3 验证</h5><p>在主库和从库中，执行如下SQL语句，来查看是否读的时候， 从从库中读取 ； 写入操作的时候，是否写入到主库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Innodb_rows_%&#x27;</span> ;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1555235982584.png" alt="1555235982584"> </p><h5 id="4-11-4-原理"><a href="#4-11-4-原理" class="headerlink" title="4.11.4 原理"></a>4.11.4 原理</h5><p><img src="/images/mysql/aop-datasource.png" alt="1555235982584"></p><h4 id="4-12-性能优化-应用优化"><a href="#4-12-性能优化-应用优化" class="headerlink" title="4.12 性能优化 - 应用优化"></a>4.12 性能优化 - 应用优化</h4><h5 id="4-12-1-缓存"><a href="#4-12-1-缓存" class="headerlink" title="4.12.1 缓存"></a>4.12.1 缓存</h5><p>可以在业务系统中使用redis来做缓存，缓存一些基础性的数据，来降低关系型数据库的压力，提高访问效率。</p><h5 id="4-12-2-全文检索"><a href="#4-12-2-全文检索" class="headerlink" title="4.12.2 全文检索"></a>4.12.2 全文检索</h5><p>如果业务系统中的数据量比较大（达到千万级别），这个时候，如果再对数据库进行查询，特别是进行分页查询，速度将变得很慢（因为在分页时首先需要count求合计数），为了提高访问效率，这个时候，可以考虑加入Solr 或者 ElasticSearch全文检索服务，来提高访问效率。</p><h5 id="4-13-3-非关系数据库"><a href="#4-13-3-非关系数据库" class="headerlink" title="4.13.3 非关系数据库"></a>4.13.3 非关系数据库</h5><p>也可以考虑将非核心（重要）数据，存在 MongoDB 中，这样可以提高插入以及查询的效率。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql高级二</title>
    <link href="/2022/06/11/Mysql%E9%AB%98%E7%BA%A7-day02/"/>
    <url>/2022/06/11/Mysql%E9%AB%98%E7%BA%A7-day02/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">Mysql高级二</font></div>**注：导入1000万条数据别忘了自己在B站视频的评论里有记录。**<h3 id="1-Mysql的体系结构概览"><a href="#1-Mysql的体系结构概览" class="headerlink" title="1. Mysql的体系结构概览"></a>1. Mysql的体系结构概览</h3><p><img src="/images/mysql/000001.jpg" alt="171214401286615"> </p><p>整个MySQL Server由以下组成</p><ul><li>Connection Pool : 连接池组件</li><li>Management Services &amp; Utilities : 管理服务和工具组件</li><li>SQL Interface组件</li><li>Parser : 查询分析器组件</li><li>Optimizer : 优化器组件</li><li>Caches &amp; Buffers : 缓冲池组件</li><li>Pluggable Storage Engines : 存储引擎</li><li>File System : 文件系统</li></ul><p>1） 连接层</p><p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于 TCP&#x2F;IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p><p>2） 服务层</p><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><p>3） 引擎层</p><p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</p><p>4）存储层</p><p>数据存储层， 主要是将数据存储在文件系统之上，并完成与存储引擎的交互。</p><p>和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><h3 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2. 存储引擎"></a>2. 存储引擎</h3><h4 id="2-1-存储引擎概述"><a href="#2-1-存储引擎概述" class="headerlink" title="2.1 存储引擎概述"></a>2.1 存储引擎概述</h4><p>​和大多数的数据库不同, MySQL中有一个存储引擎的概念, 针对不同的存储需求可以选择最优的存储引擎。</p><p>​存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式 。存储引擎是基于表的，而不是基于库的。所以存储引擎也可被称为表类型。</p><p>​Oracle，SqlServer等数据库只有一种存储引擎。MySQL提供了插件式的存储引擎架构。所以MySQL存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎。</p><p>​MySQL5.0支持的存储引擎包含 ： InnoDB 、MyISAM 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供事务安全表，其他存储引擎是非事务安全表。</p><p>可以通过指定 show engines ， 来查询当前数据库支持的存储引擎 ： </p><p><img src="/images/mysql/1551186043529.png" alt="1551186043529"> </p><p>创建新表时如果不指定存储引擎，那么系统就会使用默认的存储引擎，MySQL5.5之前的默认存储引擎是MyISAM，5.5之后就改为了InnoDB。</p><p>查看Mysql数据库默认的存储引擎 ， 指令 ：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;%storage_engine%&#x27;</span> ； <br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556086372754.png" alt="1556086372754">   </p><h4 id="2-2-各种存储引擎特性"><a href="#2-2-各种存储引擎特性" class="headerlink" title="2.2 各种存储引擎特性"></a>2.2 各种存储引擎特性</h4><p>下面重点介绍几种常用的存储引擎， 并对比各个存储引擎之间的区别， 如下表所示 ： </p><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>MEMORY</th><th>MERGE</th><th>NDB</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td><td>没有</td><td>有</td></tr><tr><td>事务安全</td><td>&#x3D;&#x3D;支持&#x3D;&#x3D;</td><td></td><td></td><td></td><td></td></tr><tr><td>锁机制</td><td>&#x3D;&#x3D;行锁(适合高并发)&#x3D;&#x3D;</td><td>&#x3D;&#x3D;表锁&#x3D;&#x3D;</td><td>表锁</td><td>表锁</td><td>行锁</td></tr><tr><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td></td><td></td></tr><tr><td>全文索引</td><td>支持(5.6版本之后)</td><td>支持</td><td></td><td></td><td></td></tr><tr><td>集群索引</td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td>数据索引</td><td>支持</td><td></td><td>支持</td><td></td><td>支持</td></tr><tr><td>索引缓存</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据可压缩</td><td></td><td>支持</td><td></td><td></td><td></td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N&#x2F;A</td><td>低</td><td>低</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td><td>低</td><td>高</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>&#x3D;&#x3D;支持&#x3D;&#x3D;</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>下面我们将重点介绍最长使用的两种存储引擎： InnoDB、MyISAM ， 另外两种 MEMORY、MERGE ， 了解即可。</p><h5 id="2-2-1-InnoDB"><a href="#2-2-1-InnoDB" class="headerlink" title="2.2.1 InnoDB"></a>2.2.1 InnoDB</h5><p>​InnoDB存储引擎是Mysql的默认存储引擎。InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。</p><p>InnoDB存储引擎不同于其他存储引擎的特点 ： </p><p><strong>事务控制</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> goods_innodb(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br><span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">primary key</span>(id)<br>)ENGINE=innodb <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">start</span> <span class="hljs-keyword">transaction</span>;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> goods_innodb(id,<span class="hljs-type">name</span>)<span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Meta20&#x27;</span>);<br><br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556075130115.png" alt="1556075130115"> </p><p>测试，发现在InnoDB中是存在事务的 ；</p><p><strong>外键约束</strong></p><p>​MySQL支持外键的存储引擎只有InnoDB ， 在创建外键的时候， 要求父表必须有对应的索引 ， 子表在创建外键的时候， 也会自动的创建对应的索引。</p><p>​下面两张表中 ， country_innodb是父表 ， country_id为主键索引，city_innodb表是子表，country_id字段为外键，对应于country_innodb表的主键country_id 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> country_innodb(<br>country_id <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    country_name <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">primary</span> key(country_id)<br>)ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> city_innodb(<br>city_id <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    city_name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    country_id <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">primary</span> key(city_id),<br>    key idx_fk_country_id(country_id),<br>    <span class="hljs-keyword">CONSTRAINT</span> `fk_city_country` <span class="hljs-keyword">FOREIGN</span> KEY(country_id) <span class="hljs-keyword">REFERENCES</span> country_innodb(country_id) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> RESTRICT <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE<br>)ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> country_innodb <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;China&#x27;</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;America&#x27;</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Japan&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> city_innodb <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Xian&#x27;</span>,<span class="hljs-number">1</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;NewYork&#x27;</span>,<span class="hljs-number">2</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;BeiJing&#x27;</span>,<span class="hljs-number">1</span>);<br><br></code></pre></td></tr></table></figure><p>在创建索引时， 可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION。</p><p>RESTRICT和NO ACTION相同， 是指限制在子表有关联记录的情况下， 父表不能更新；</p><p>CASCADE表示父表在更新或者删除时，更新或者删除子表对 应的记录；</p><p>SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL 。</p><p>针对上面创建的两个表， 子表的外键指定是ON DELETE RESTRICT ON UPDATE CASCADE 方式的， 那么在主表删除记录的时候， 如果子表有对应记录， 则不允许删除， 主表在更新记录的时候， 如果子表有对应记录， 则子表对应更新 。</p><p>表中数据如下图所示 ： </p><p><img src="/images/mysql/1556087540767.png" alt="1556087540767"> </p><p>外键信息可以使用如下两种方式查看 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> city_innodb ;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556087611295.png" alt="1556087611295"> </p><p>删除country_id为1 的country数据： </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> country_innodb <span class="hljs-keyword">where</span> country_id = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556087719145.png" alt="1556087719145"> </p><p>更新主表country表的字段 country_id : </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">update country_innodb set country_id <span class="hljs-operator">=</span> <span class="hljs-number">100</span> where country_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556087759615.png" alt="1556087759615">  </p><p>更新后， 子表的数据信息为 ： </p><p><img src="/images/mysql/1556087793738.png" alt="1556087793738">  </p><p><strong>存储方式</strong></p><p>InnoDB 存储表和索引有以下两种方式 ： </p><p>①. 使用共享表空间存储， 这种方式创建的表的表结构保存在.frm文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。</p><p>②. 使用多表空间存储， 这种方式创建的表的表结构仍然存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。</p><p><img src="/images/mysql/1556075336630.png" alt="1556075336630"> </p><h5 id="2-2-2-MyISAM"><a href="#2-2-2-MyISAM" class="headerlink" title="2.2.2 MyISAM"></a>2.2.2 MyISAM</h5><p>​MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表 。有以下两个比较重要的特点： </p><p><strong>不支持事务</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> goods_myisam(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <br>    <span class="hljs-keyword">primary</span> key(id)<br>)ENGINE<span class="hljs-operator">=</span>myisam <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1551347590309.png" alt="1551347590309"> </p><p>通过测试，我们发现，在MyISAM存储引擎中，是没有事务控制的 ；</p><p><strong>文件存储方式</strong></p><p>每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但拓展名分别是 ： </p><p>.frm (存储表定义)；</p><p>.MYD(MYData , 存储数据)；</p><p>.MYI(MYIndex , 存储索引)；</p><p><img src="/images/mysql/1556075073836.png" alt="1556075073836"> </p><h5 id="2-2-3-MEMORY"><a href="#2-2-3-MEMORY" class="headerlink" title="2.2.3 MEMORY"></a>2.2.3 MEMORY</h5><p>​Memory存储引擎将表的数据存放在内存中。每个MEMORY表实际对应一个磁盘文件，格式是.frm ，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY 类型的表访问非常地快，因为他的数据是存放在内存中的，并且默认使用HASH索引 ， 但是服务一旦关闭，表中的数据就会丢失。</p><h5 id="2-2-4-MERGE"><a href="#2-2-4-MERGE" class="headerlink" title="2.2.4 MERGE"></a>2.2.4 MERGE</h5><p>​MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身并没有存储数据，对MERGE类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行的。</p><p>​对于MERGE类型表的插入操作，是通过INSERT_METHOD子句定义插入的表，可以有3个不同的值，使用FIRST 或 LAST 值使得插入操作被相应地作用在第一或者最后一个表上，不定义这个子句或者定义为NO，表示不能对这个MERGE表执行插入操作。</p><p>​可以对MERGE表进行DROP操作，但是这个操作只是删除MERGE表的定义，对内部的表是没有任何影响的。</p><p><img src="/images/mysql/1556076359503.png" alt="1556076359503"> </p><p>下面是一个创建和使用MERGE表的示例 ： </p><p>1）. 创建3个测试表 order_1990, order_1991, order_all , 其中order_all是前两个表的MERGE表 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> order_1990(<br>order_id <span class="hljs-type">int</span> ,<br>order_money <span class="hljs-keyword">double</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br>order_address <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>),<br><span class="hljs-keyword">primary</span> key (order_id)<br>)engine <span class="hljs-operator">=</span> myisam <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8;<br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> order_1991(<br>order_id <span class="hljs-type">int</span> ,<br>order_money <span class="hljs-keyword">double</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br>order_address <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>),<br><span class="hljs-keyword">primary</span> key (order_id)<br>)engine <span class="hljs-operator">=</span> myisam <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8;<br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> order_all(<br>order_id <span class="hljs-type">int</span> ,<br>order_money <span class="hljs-keyword">double</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br>order_address <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>),<br><span class="hljs-keyword">primary</span> key (order_id)<br>)engine <span class="hljs-operator">=</span> <span class="hljs-keyword">merge</span> <span class="hljs-keyword">union</span> <span class="hljs-operator">=</span> (order_1990,order_1991) INSERT_METHOD<span class="hljs-operator">=</span><span class="hljs-keyword">LAST</span> <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8;<br><br><br></code></pre></td></tr></table></figure><p>2）. 分别向两张表中插入记录 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> order_1990 <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100.0</span>,<span class="hljs-string">&#x27;北京&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> order_1990 <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-number">100.0</span>,<span class="hljs-string">&#x27;上海&#x27;</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> order_1991 <span class="hljs-keyword">values</span>(<span class="hljs-number">10</span>,<span class="hljs-number">200.0</span>,<span class="hljs-string">&#x27;北京&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> order_1991 <span class="hljs-keyword">values</span>(<span class="hljs-number">11</span>,<span class="hljs-number">200.0</span>,<span class="hljs-string">&#x27;上海&#x27;</span>);<br></code></pre></td></tr></table></figure><p>3）. 查询3张表中的数据。</p><p>order_1990中的数据 ： </p><p><img src="/images/mysql/1551408083254.png" alt="1551408083254"> </p><p>order_1991中的数据 ： </p><p><img src="/images/mysql/1551408133323.png" alt="1551408133323">  </p><p>order_all中的数据 ：</p><p><img src="/images/mysql/1551408216185.png" alt="1551408216185"> </p><p>​ </p><p>4）. 往order_all中插入一条记录 ，由于在MERGE表定义时，INSERT_METHOD 选择的是LAST，那么插入的数据会想最后一张表中插入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> order_all <span class="hljs-keyword">values</span>(<span class="hljs-number">100</span>,<span class="hljs-number">10000.0</span>,<span class="hljs-string">&#x27;西安&#x27;</span>)；<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1551408519889.png" alt="1551408519889">  </p><h4 id="2-3-存储引擎的选择"><a href="#2-3-存储引擎的选择" class="headerlink" title="2.3 存储引擎的选择"></a>2.3 存储引擎的选择</h4><p>​在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。以下是几种常用的存储引擎的使用环境。</p><ul><li>InnoDB : 是Mysql的默认存储引擎，用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询意外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定， 还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择。</li><li>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li><li>MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。</li><li>MERGE：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率。这对于存储诸如数据仓储等VLDB环境十分合适。</li></ul><h3 id="3-优化SQL步骤"><a href="#3-优化SQL步骤" class="headerlink" title="3. 优化SQL步骤"></a>3. 优化SQL步骤</h3><p>在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多 SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在 MySQL 中优化 SQL 语句的方法。</p><p>当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。</p><h4 id="3-1-查看SQL执行频率"><a href="#3-1-查看SQL执行频率" class="headerlink" title="3.1 查看SQL执行频率"></a>3.1 查看SQL执行频率</h4><p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”。</p><p>下面的命令显示了当前 session 中所有统计参数的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Com_______&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1552487172501.png" alt="1552487172501">  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Innodb_rows_%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1552487245859.png" alt="1552487245859"></p><p>Com_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。</p><table><thead><tr><th align="left">参数</th><th>含义</th></tr></thead><tbody><tr><td align="left">Com_select</td><td>执行 select 操作的次数，一次查询只累加 1。</td></tr><tr><td align="left">Com_insert</td><td>执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。</td></tr><tr><td align="left">Com_update</td><td>执行 UPDATE 操作的次数。</td></tr><tr><td align="left">Com_delete</td><td>执行 DELETE 操作的次数。</td></tr><tr><td align="left">Innodb_rows_read</td><td>select 查询返回的行数。</td></tr><tr><td align="left">Innodb_rows_inserted</td><td>执行 INSERT 操作插入的行数。</td></tr><tr><td align="left">Innodb_rows_updated</td><td>执行 UPDATE 操作更新的行数。</td></tr><tr><td align="left">Innodb_rows_deleted</td><td>执行 DELETE 操作删除的行数。</td></tr><tr><td align="left">Connections</td><td>试图连接 MySQL 服务器的次数。</td></tr><tr><td align="left">Uptime</td><td>服务器工作时间。</td></tr><tr><td align="left">Slow_queries</td><td>慢查询的次数。</td></tr></tbody></table><p>Com_***      :  这些参数对于所有存储引擎的表操作都会进行累计。</p><p>Innodb_*** :  这几个参数只是针对InnoDB 存储引擎的，累加的算法也略有不同。</p><h4 id="3-2-定位低效率执行SQL"><a href="#3-2-定位低效率执行SQL" class="headerlink" title="3.2 定位低效率执行SQL"></a>3.2 定位低效率执行SQL</h4><p>可以通过以下两种方式定位执行效率较低的 SQL 语句。</p><ul><li>慢查询日志 : 通过慢查询日志定位那些执行效率较低的 SQL 语句，用–log-slow-queries[&#x3D;file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。具体可以查看本书第 26 章中日志管理的相关部分。</li><li>show processlist  : 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</li></ul><p><img src="/images/mysql/1556098544349.png" alt="1556098544349"> </p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-number">1</span>） id列，用户登录mysql时，系统分配的<span class="hljs-string">&quot;connection_id&quot;</span>，可以使用函数connection_id()查看<br><br><span class="hljs-number">2</span>） <span class="hljs-keyword">user</span>列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句<br><br><span class="hljs-number">3</span>） host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户<br><br><span class="hljs-number">4</span>） db列，显示这个进程目前连接的是哪个数据库<br><br><span class="hljs-number">5</span>） command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等<br><br><span class="hljs-number">6</span>） time列，显示这个状态持续的时间，单位是秒<br><br><span class="hljs-number">7</span>） <span class="hljs-keyword">state</span>列，显示使用当前连接的sql语句的状态，很重要的列。<span class="hljs-keyword">state</span>描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying <span class="hljs-keyword">to</span> tmp <span class="hljs-built_in">table</span>、sorting result、sending data等状态才可以完成<br><br><span class="hljs-number">8</span>） info列，显示这个sql语句，是判断问题语句的一个重要依据<br></code></pre></td></tr></table></figure><h4 id="3-3-explain分析执行计划"><a href="#3-3-explain分析执行计划" class="headerlink" title="3.3 explain分析执行计划"></a>3.3 explain分析执行计划</h4><p>通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p><p>查询SQL语句的执行计划 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain  <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1552487489859.png" alt="1552487489859"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain  <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> title <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;阿尔卡特 (OT-979) 冰川白 联通3G手机3&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1552487526919.png" alt="1552487526919">  </p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。</td></tr><tr><td>select_type</td><td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等</td></tr><tr><td>table</td><td>输出结果集的表</td></tr><tr><td>type</td><td>表示表的连接类型，性能由好到差的连接类型为( system  —&gt;  const  —–&gt;  eq_ref  ——&gt;  ref  ——-&gt;  ref_or_null—-&gt;  index_merge  —&gt;  index_subquery  —–&gt;  range  —–&gt;  index  ——&gt; all )</td></tr><tr><td>possible_keys</td><td>表示查询时，可能使用的索引</td></tr><tr><td>key</td><td>表示实际使用的索引</td></tr><tr><td>key_len</td><td>索引字段的长度</td></tr><tr><td>rows</td><td>扫描行的数量</td></tr><tr><td>extra</td><td>执行情况的说明和描述</td></tr></tbody></table><h5 id="3-3-1-环境准备"><a href="#3-3-1-环境准备" class="headerlink" title="3.3.1 环境准备"></a>3.3.1 环境准备</h5><p><img src="/images/mysql/1556122799330.png" alt="1556122799330"> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_role` (<br>  `id` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `role_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `role_code` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `description` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `unique_role_name` (`role_name`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_user` (<br>  `id` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `username` <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `password` <span class="hljs-type">varchar</span>(<span class="hljs-number">96</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `unique_user_username` (`username`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `user_role` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> auto_increment ,<br>  `user_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `role_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `fk_ur_user_id` (`user_id`),<br>  KEY `fk_ur_role_id` (`role_id`),<br>  <span class="hljs-keyword">CONSTRAINT</span> `fk_ur_role_id` <span class="hljs-keyword">FOREIGN</span> KEY (`role_id`) <span class="hljs-keyword">REFERENCES</span> `t_role` (`id`) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">NO</span> ACTION <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">NO</span> ACTION,<br>  <span class="hljs-keyword">CONSTRAINT</span> `fk_ur_user_id` <span class="hljs-keyword">FOREIGN</span> KEY (`user_id`) <span class="hljs-keyword">REFERENCES</span> `t_user` (`id`) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">NO</span> ACTION <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">NO</span> ACTION<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><br><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;super&#x27;</span>,<span class="hljs-string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="hljs-string">&#x27;超级管理员&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="hljs-string">&#x27;系统管理员&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;itcast&#x27;</span>,<span class="hljs-string">&#x27;$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui&#x27;</span>,<span class="hljs-string">&#x27;test02&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;stu1&#x27;</span>,<span class="hljs-string">&#x27;$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK/y/spH5rftCpUMZa&#x27;</span>,<span class="hljs-string">&#x27;学生1&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;stu2&#x27;</span>,<span class="hljs-string">&#x27;$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr/p1FR6ZKgc18u.Tvqm&#x27;</span>,<span class="hljs-string">&#x27;学生2&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&#x27;t1&#x27;</span>,<span class="hljs-string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="hljs-string">&#x27;老师1&#x27;</span>);<br><br><br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;学生&#x27;</span>,<span class="hljs-string">&#x27;student&#x27;</span>,<span class="hljs-string">&#x27;学生&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;老师&#x27;</span>,<span class="hljs-string">&#x27;teacher&#x27;</span>,<span class="hljs-string">&#x27;老师&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&#x27;教学管理员&#x27;</span>,<span class="hljs-string">&#x27;teachmanager&#x27;</span>,<span class="hljs-string">&#x27;教学管理员&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&#x27;管理员&#x27;</span>,<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-string">&#x27;管理员&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;10&#x27;</span>,<span class="hljs-string">&#x27;超级管理员&#x27;</span>,<span class="hljs-string">&#x27;super&#x27;</span>,<span class="hljs-string">&#x27;超级管理员&#x27;</span>);<br><br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user_role(id,user_id,role_id) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>),(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>),(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>),(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>),(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>),(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;10&#x27;</span>) ;<br><br><br></code></pre></td></tr></table></figure><h5 id="3-3-2-explain-之-id"><a href="#3-3-2-explain-之-id" class="headerlink" title="3.3.2 explain 之 id"></a>3.3.2 explain 之 id</h5><p>id 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。id 情况有三种 ： </p><p>1） id 相同表示加载表的顺序是从上到下。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">explain select * <span class="hljs-keyword">from</span> t_role r, t_user u, user_role ur <span class="hljs-keyword">where</span> r.<span class="hljs-built_in">id</span> = ur.role_id <span class="hljs-keyword">and</span> u.<span class="hljs-built_in">id</span> = ur.user_id ;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556102471304.png" alt="1556102471304"></p><p>2） id 不同id值越大，优先级越高，越先被执行。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_role <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> role_id <span class="hljs-keyword">FROM</span> user_role <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;stu1&#x27;</span>))<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556103009534.png" alt="1556103009534"> </p><p>3） id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_role r , (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> user_role ur <span class="hljs-keyword">WHERE</span> ur.`user_id` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2&#x27;</span>) a <span class="hljs-keyword">WHERE</span> r.id <span class="hljs-operator">=</span> a.role_id ; <br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556103294182.png" alt="1556103294182"> </p><h5 id="3-3-3-explain-之-select-type"><a href="#3-3-3-explain-之-select-type" class="headerlink" title="3.3.3 explain 之 select_type"></a>3.3.3 explain 之 select_type</h5><p> 表示 SELECT 的类型，常见的取值，如下表所示：</p><table><thead><tr><th>select_type</th><th>含义</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的select查询，查询中不包含子查询或者UNION</td></tr><tr><td>PRIMARY</td><td>查询中若包含任何复杂的子查询，最外层查询标记为该标识</td></tr><tr><td>SUBQUERY</td><td>在SELECT 或 WHERE 列表中包含了子查询</td></tr><tr><td>DERIVED</td><td>在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中</td></tr><tr><td>UNION</td><td>若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED</td></tr><tr><td>UNION RESULT</td><td>从UNION表获取结果的SELECT</td></tr></tbody></table><h5 id="3-3-4-explain-之-table"><a href="#3-3-4-explain-之-table" class="headerlink" title="3.3.4 explain 之 table"></a>3.3.4 explain 之 table</h5><p>展示这一行的数据是关于哪一张表的 </p><h5 id="3-3-5-explain-之-type"><a href="#3-3-5-explain-之-type" class="headerlink" title="3.3.5 explain 之 type"></a>3.3.5 explain 之 type</h5><p>type 显示的是访问类型，是较为重要的一个指标，可取值为： </p><table><thead><tr><th>type</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>MySQL不访问任何表，索引，直接返回结果</td></tr><tr><td>举例</td><td>select now();</td></tr><tr><td>system</td><td>表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现</td></tr><tr><td>举例</td><td>select * from (select * from t_user where id&#x3D;’1’) a;5.7版本之前外层查询会是system，但是5.7是const</td></tr><tr><td>const</td><td>表示通过索引一次就找到了，const 用于比较primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常亮。const于将 “主键” 或 “唯一” 索引的所有部分与常量值进行比较</td></tr><tr><td>eq_ref</td><td>类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描</td></tr><tr><td>ref</td><td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个）</td></tr><tr><td>range</td><td>只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， &lt; , &gt; , in 等操作。</td></tr><tr><td>index</td><td>index 与 ALL的区别为  index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。</td></tr><tr><td>all</td><td>将遍历全表以找到匹配的行</td></tr></tbody></table><p>结果值从最好到最坏以此是：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">NULL</span> &gt; <span class="hljs-keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="hljs-keyword">ref</span> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; <span class="hljs-keyword">index</span> &gt; <span class="hljs-keyword">ALL</span><br><br><br><span class="hljs-keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="hljs-keyword">ref</span> &gt; range &gt; i<span class="hljs-comment">---+-------+---------------+---------+---------+-------+-----</span><br><span class="hljs-number">1</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> <span class="hljs-built_in">warning</span> (<span class="hljs-number">0.00</span> sec)                                                                 <br>                                                                                                   <br>mysql&gt;                               ndex &gt; <span class="hljs-keyword">ALL</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref 。&#x3D;&#x3D;</p><h5 id="3-3-6-explain-之-key"><a href="#3-3-6-explain-之-key" class="headerlink" title="3.3.6 explain 之  key"></a>3.3.6 explain 之  key</h5><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">possible_keys : 显示可能应用在这张表的索引， 一个或多个。 <br><br>key ： 实际使用的索引， 如果为NULL， 则没有使用索引。<br><br>key_len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。<br></code></pre></td></tr></table></figure><h5 id="3-3-7-explain-之-rows"><a href="#3-3-7-explain-之-rows" class="headerlink" title="3.3.7 explain 之 rows"></a>3.3.7 explain 之 rows</h5><p>扫描行的数量。</p><h5 id="3-3-8-explain-之-extra"><a href="#3-3-8-explain-之-extra" class="headerlink" title="3.3.8 explain 之 extra"></a>3.3.8 explain 之 extra</h5><p>其他的额外的执行计划信息，在该列展示 。</p><table><thead><tr><th>extra</th><th>含义</th></tr></thead><tbody><tr><td>using  filesort</td><td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “文件排序”, 效率低。需要扫描文件的内容，然后根据文件内容进行排序</td></tr><tr><td>举例</td><td>select * from t_user order by password;(password不是索引)，假如根据id，就会是null</td></tr><tr><td>using  temporary</td><td>使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于 order by 和 group by； 效率低</td></tr><tr><td>举例</td><td>explain select * from t_user group by password;  没有修改任何参数应该会报错（only_full_group_by之类的），解决办法下边</td></tr><tr><td>using  index</td><td>表示相应的select操作使用了覆盖索引， 避免访问表的数据行， 效率不错。</td></tr></tbody></table><p><strong>注</strong>：</p><p>原因：SQL 标准中不允许 SELECT 列表，HAVING 条件语句，或 ORDER BY 语句中出现 GROUP BY 中未列表的可聚合列。而 MySQL 中有一个状态 <a href="https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_only_full_group_by">ONLY_FULL_GROUP_BY</a> 来标识是否遵从这一标准，默认为开启状态。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">报错示范：<br><span class="hljs-keyword">SELECT</span> gender, <br>       last_name <br><span class="hljs-keyword">FROM</span>   employees <br><span class="hljs-keyword">GROUP</span>  <span class="hljs-keyword">BY</span> gender;<br>正确：<br><span class="hljs-keyword">SELECT</span> gender,<br><span class="hljs-keyword">FROM</span>   employees <br><span class="hljs-keyword">GROUP</span>  <span class="hljs-keyword">BY</span> gender;<br>或者<br><span class="hljs-keyword">SELECT</span> gender,<br>last_name<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> gender,<br>last_name;<br></code></pre></td></tr></table></figure><p>解决办法：</p><p>select @@sql_mode;可以查看</p><p>SET SESSION sql_mode&#x3D;(SELECT REPLACE(@@sql_mode,’ONLY_FULL_GROUP_BY,’,’’)); 重新设置，再去查就没有（only_full_group_by）项了。</p><h4 id="3-4-show-profile分析SQL"><a href="#3-4-show-profile分析SQL" class="headerlink" title="3.4 show profile分析SQL"></a>3.4 show profile分析SQL</h4><p>Mysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</p><p>通过 have_profiling 参数，能够看到当前MySQL是否支持profile：</p><p><img src="/images/mysql/1552488401999.png" alt="1552488401999"> </p><p>默认profiling是关闭的，可以通过set语句在Session级别开启profiling：</p><p><img src="/images/mysql/1552488372405.png" alt="1552488372405"> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> profiling<span class="hljs-operator">=</span><span class="hljs-number">1</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>开启profiling 开关；<br></code></pre></td></tr></table></figure><p>通过profile，我们能够更清楚地了解SQL执行的过程。</p><p>首先，我们可以执行一系列的操作，如下图所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> databases;<br><br>use db01;<br><br><span class="hljs-keyword">show</span> tables;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_item;<br></code></pre></td></tr></table></figure><p>执行完上述命令之后，再执行show profiles 指令， 来查看SQL语句执行的耗时：</p><p><img src="/images/mysql/1552489017940.png" alt="1552489017940">  </p><p>通过show  profile for  query  query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间：</p><p><img src="/images/mysql/1552489053763.png" alt="1552489053763"> </p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">TIP ：<br>Sending data 状态表示MySQL线程开始访问数据行并把结果返回给客户端，而不仅仅是返回个客户端。由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整各查询中耗时最长的状态。<br></code></pre></td></tr></table></figure><p>在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间  ：</p><p><img src="/images/mysql/1552489671119.png" alt="1552489671119"> </p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Status</td><td>sql 语句执行的状态</td></tr><tr><td>Duration</td><td>sql 执行过程中每一个步骤的耗时</td></tr><tr><td>CPU_user</td><td>当前用户占有的cpu</td></tr><tr><td>CPU_system</td><td>系统占有的cpu</td></tr></tbody></table><p>optimizing</p><h4 id="3-5-trace分析优化器执行计划"><a href="#3-5-trace分析优化器执行计划" class="headerlink" title="3.5 trace分析优化器执行计划"></a>3.5 trace分析优化器执行计划</h4><p>MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。</p><p>打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> optimizer_trace<span class="hljs-operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="hljs-operator">=</span><span class="hljs-keyword">on</span>;<br><span class="hljs-keyword">set</span> optimizer_trace_max_mem_size<span class="hljs-operator">=</span><span class="hljs-number">1000000</span>;<br></code></pre></td></tr></table></figure><p>执行SQL语句 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>最后， 检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information_schema.optimizer_trace\G;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><code class="hljs json">*************************** <span class="hljs-number">1.</span> row ***************************<br>QUERY<span class="hljs-punctuation">:</span> select * from tb_item where id &lt; <span class="hljs-number">4</span><br>TRACE<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;steps&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;join_preparation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;select#&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;steps&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;expanded_query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/* select#1 */ select `tb_item`.`id` AS `id`,`tb_item`.`title` AS `title`,`tb_item`.`price` AS `price`,`tb_item`.`num` AS `num`,`tb_item`.`categoryid` AS `categoryid`,`tb_item`.`status` AS `status`,`tb_item`.`sellerid` AS `sellerid`,`tb_item`.`createtime` AS `createtime`,`tb_item`.`updatetime` AS `updatetime` from `tb_item` where (`tb_item`.`id` &lt; 4)&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* steps */</span><br>      <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* join_preparation */</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;join_optimization&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;select#&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;steps&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;condition_processing&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;WHERE&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;original_condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(`tb_item`.`id` &lt; 4)&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;steps&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                  <span class="hljs-attr">&quot;transformation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;equality_propagation&quot;</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;resulting_condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(`tb_item`.`id` &lt; 4)&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-punctuation">&#123;</span><br>                  <span class="hljs-attr">&quot;transformation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;constant_propagation&quot;</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;resulting_condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(`tb_item`.`id` &lt; 4)&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-punctuation">&#123;</span><br>                  <span class="hljs-attr">&quot;transformation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;trivial_condition_removal&quot;</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;resulting_condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(`tb_item`.`id` &lt; 4)&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>              <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* steps */</span><br>            <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* condition_processing */</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;table_dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>              <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;table&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;`tb_item`&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;row_may_be_null&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;map_bit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;depends_on_map_bits&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* depends_on_map_bits */</span><br>              <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* table_dependencies */</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;ref_optimizer_key_uses&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* ref_optimizer_key_uses */</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;rows_estimation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>              <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;table&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;`tb_item`&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;range_analysis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                  <span class="hljs-attr">&quot;table_scan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;rows&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9816098</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;cost&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2.04e6</span><br>                  <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* table_scan */</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;potential_range_indices&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-punctuation">&#123;</span><br>                      <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;PRIMARY&quot;</span><span class="hljs-punctuation">,</span><br>                      <span class="hljs-attr">&quot;usable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>                      <span class="hljs-attr">&quot;key_parts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                        <span class="hljs-string">&quot;id&quot;</span><br>                      <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* key_parts */</span><br>                    <span class="hljs-punctuation">&#125;</span><br>                  <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* potential_range_indices */</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;setup_range_conditions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                  <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* setup_range_conditions */</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;group_index_range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;chosen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;cause&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;not_group_by_or_distinct&quot;</span><br>                  <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* group_index_range */</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;analyzing_range_alternatives&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;range_scan_alternatives&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                      <span class="hljs-punctuation">&#123;</span><br>                        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;PRIMARY&quot;</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;ranges&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                          <span class="hljs-string">&quot;id &lt; 4&quot;</span><br>                        <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* ranges */</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;index_dives_for_eq_ranges&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;rowid_ordered&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;using_mrr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;index_only&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;rows&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;cost&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1.6154</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;chosen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><br>                      <span class="hljs-punctuation">&#125;</span><br>                    <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* range_scan_alternatives */</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;analyzing_roworder_intersect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                      <span class="hljs-attr">&quot;usable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>                      <span class="hljs-attr">&quot;cause&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;too_few_roworder_scans&quot;</span><br>                    <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* analyzing_roworder_intersect */</span><br>                  <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* analyzing_range_alternatives */</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;chosen_range_access_summary&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;range_access_plan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;range_scan&quot;</span><span class="hljs-punctuation">,</span><br>                      <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;PRIMARY&quot;</span><span class="hljs-punctuation">,</span><br>                      <span class="hljs-attr">&quot;rows&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>                      <span class="hljs-attr">&quot;ranges&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                        <span class="hljs-string">&quot;id &lt; 4&quot;</span><br>                      <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* ranges */</span><br>                    <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* range_access_plan */</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;rows_for_plan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;cost_for_plan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1.6154</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;chosen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><br>                  <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* chosen_range_access_summary */</span><br>                <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* range_analysis */</span><br>              <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* rows_estimation */</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;considered_execution_plans&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>              <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;plan_prefix&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* plan_prefix */</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;table&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;`tb_item`&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;best_access_path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                  <span class="hljs-attr">&quot;considered_access_paths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-punctuation">&#123;</span><br>                      <span class="hljs-attr">&quot;access_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;range&quot;</span><span class="hljs-punctuation">,</span><br>                      <span class="hljs-attr">&quot;rows&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>                      <span class="hljs-attr">&quot;cost&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2.2154</span><span class="hljs-punctuation">,</span><br>                      <span class="hljs-attr">&quot;chosen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><br>                    <span class="hljs-punctuation">&#125;</span><br>                  <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* considered_access_paths */</span><br>                <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* best_accessoptimizing_path */</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;cost_for_plan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2.2154</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;rows_for_plan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;chosen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><br>              <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* considered_execution_plans */</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;attaching_conditions_to_tables&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;original_condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(`tb_item`.`id` &lt; 4)&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;attached_conditions_computation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>              <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* attached_conditions_computation */</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;attached_conditions_summaryoptimizing&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                  <span class="hljs-attr">&quot;table&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;`tb_item`&quot;</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;attached&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(`tb_item`.`id` &lt; 4)&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>              <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* attached_conditions_summary */</span><br>            <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* attaching_conditions_to_tables */</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;refine_plan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>              <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;table&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;`tb_item`&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;access_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;range&quot;</span><br>              <span class="hljs-punctuation">&#125;</span>optimizing<br>            <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* refine_plan */</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* steps */</span><br>      <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* join_optimization */</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  optimizing  <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;join_execution&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;select#&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;steps&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* steps */</span><br>      <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* join_execution */</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* steps */</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="4-索引的使用"><a href="#4-索引的使用" class="headerlink" title="4. 索引的使用"></a>4. 索引的使用</h3><p>索引是数据库优化最常用也是最重要的手段之一, 通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题。</p><h4 id="4-1-验证索引提升查询效率"><a href="#4-1-验证索引提升查询效率" class="headerlink" title="4.1 验证索引提升查询效率"></a>4.1 验证索引提升查询效率</h4><p>在我们准备的表结构tb_item 中， 一共存储了 300 万记录；</p><p>A. 根据ID查询 </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select * <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span> = <span class="hljs-number">1999</span>\G;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1553261992653.png" alt="1553261992653"> </p><p>查询速度很快， 接近0s ， 主要的原因是因为id为主键， 有索引；</p><p><img src="/images/mysql/1553262044466.png" alt="1553262044466"> </p><p>2). 根据 title 进行精确查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> title <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;iphoneX 移动3G 32G941&#x27;</span>\G; <br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1553262215900.png" alt="1553262215900"> </p><p>查看SQL语句的执行计划 ： </p><p><img src="/images/mysql/1553262469785.png" alt="1553262469785"> </p><p>处理方案 ， 针对title字段， 创建索引 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> index idx_item_title <span class="hljs-keyword">on</span> tb_item(title);<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1553263229523.png" alt="1553263229523"> </p><p>索引创建完成之后，再次进行查询 ： </p><p><img src="/images/mysql/1553263302706.png" alt="1553263302706"> </p><p>通过explain ， 查看执行计划，执行SQL时使用了刚才创建的索引 </p><p><img src="/images/mysql/1553263355262.png" alt="1553263355262"> </p><h4 id="4-2-索引的使用"><a href="#4-2-索引的使用" class="headerlink" title="4.2 索引的使用"></a>4.2 索引的使用</h4><h5 id="4-2-1-准备环境"><a href="#4-2-1-准备环境" class="headerlink" title="4.2.1 准备环境"></a>4.2.1 准备环境</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> `tb_seller` (<br>`sellerid` <span class="hljs-type">varchar</span> (<span class="hljs-number">100</span>),<br>`name` <span class="hljs-type">varchar</span> (<span class="hljs-number">100</span>),<br>`nickname` <span class="hljs-type">varchar</span> (<span class="hljs-number">50</span>),<br>`password` <span class="hljs-type">varchar</span> (<span class="hljs-number">60</span>),<br>`status` <span class="hljs-type">varchar</span> (<span class="hljs-number">1</span>),<br>`address` <span class="hljs-type">varchar</span> (<span class="hljs-number">100</span>),<br>`createtime` datetime,<br>    <span class="hljs-keyword">primary</span> key(`sellerid`)<br>)engine<span class="hljs-operator">=</span>innodb <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8mb4; <br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;alibaba&#x27;</span>,<span class="hljs-string">&#x27;阿里巴巴&#x27;</span>,<span class="hljs-string">&#x27;阿里小店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;baidu&#x27;</span>,<span class="hljs-string">&#x27;百度科技有限公司&#x27;</span>,<span class="hljs-string">&#x27;百度小店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;huawei&#x27;</span>,<span class="hljs-string">&#x27;华为科技有限公司&#x27;</span>,<span class="hljs-string">&#x27;华为小店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;itcast&#x27;</span>,<span class="hljs-string">&#x27;传智播客教育科技有限公司&#x27;</span>,<span class="hljs-string">&#x27;传智播客&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;itheima&#x27;</span>,<span class="hljs-string">&#x27;黑马程序员&#x27;</span>,<span class="hljs-string">&#x27;黑马程序员&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>optimizing,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;luoji&#x27;</span>,<span class="hljs-string">&#x27;罗技科技有限公司&#x27;</span>,<span class="hljs-string">&#x27;罗技小店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;oppo&#x27;</span>,<span class="hljs-string">&#x27;OPPO科技有限公司&#x27;</span>,<span class="hljs-string">&#x27;OPPO官方旗舰店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;ourpalm&#x27;</span>,<span class="hljs-string">&#x27;掌趣科技股份有限公司&#x27;</span>,<span class="hljs-string">&#x27;掌趣小店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;qiandu&#x27;</span>,<span class="hljs-string">&#x27;千度科技&#x27;</span>,<span class="hljs-string">&#x27;千度小店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;sina&#x27;</span>,<span class="hljs-string">&#x27;新浪科技有限公司&#x27;</span>,<span class="hljs-string">&#x27;新浪官方旗舰店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;xiaomi&#x27;</span>,<span class="hljs-string">&#x27;小米科技&#x27;</span>,<span class="hljs-string">&#x27;小米官方旗舰店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;西安市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;yijia&#x27;</span>,<span class="hljs-string">&#x27;宜家家居&#x27;</span>,<span class="hljs-string">&#x27;宜家家居旗舰店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><br><br><span class="hljs-keyword">create</span> index idx_seller_name_sta_addr <span class="hljs-keyword">on</span> tb_seller(name,status,address);<br></code></pre></td></tr></table></figure><h5 id="4-2-2-避免索引失效"><a href="#4-2-2-避免索引失效" class="headerlink" title="4.2.2 避免索引失效"></a>4.2.2 避免索引失效</h5><h6 id="1、全值匹配-，对索引中所有列都指定具体值。"><a href="#1、全值匹配-，对索引中所有列都指定具体值。" class="headerlink" title="1、全值匹配 ，对索引中所有列都指定具体值。"></a>1、全值匹配 ，对索引中所有列都指定具体值。</h6><p>该情况下，索引生效，执行效率高。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_seller <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;小米科技&#x27;</span> <span class="hljs-keyword">and</span> status<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> address<span class="hljs-operator">=</span><span class="hljs-string">&#x27;北京市&#x27;</span>\G;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556170997921.png" alt="1556170997921"> </p><h6 id="2、最左前缀法则"><a href="#2、最左前缀法则" class="headerlink" title="2、最左前缀法则"></a>2、最左前缀法则</h6><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。</p><p>比如组合索引为name、status、address，主要是看包不包括name，并不是关注条件里三者顺序</p><p>匹配最左前缀法则，走索引：</p><p><img src="/images/mysql/1556171348995.png" alt="1556171348995">  </p><p>违法最左前缀法则 ， 索引失效：</p><p><img src="/images/mysql/1556171428140.png" alt="1556171428140"> </p><p>如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：</p><p><img src="/images/mysql/1556171662203.png" alt="1556171662203"> </p><h6 id="3、范围查询右边的列，不能使用索引-。"><a href="#3、范围查询右边的列，不能使用索引-。" class="headerlink" title="3、范围查询右边的列，不能使用索引 。"></a>3、范围查询右边的列，不能使用索引 。</h6><p><img src="/images/mysql/1556172256791.png" alt="1556172256791"> </p><p>根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。</p><h6 id="4、不要在索引列上进行运算操作，-索引将失效。"><a href="#4、不要在索引列上进行运算操作，-索引将失效。" class="headerlink" title="4、不要在索引列上进行运算操作， 索引将失效。"></a>4、不要在索引列上进行运算操作， 索引将失效。</h6><p><img src="/images/mysql/1556172813715.png" alt="1556172813715"> </p><h6 id="5、字符串不加单引号，造成索引失效。"><a href="#5、字符串不加单引号，造成索引失效。" class="headerlink" title="5、字符串不加单引号，造成索引失效。"></a>5、字符串不加单引号，造成索引失效。</h6><p><img src="/images/mysql/1556172967493.png" alt="1556172967493"> </p><p>由于，在查询是，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。</p><h6 id="6、尽量使用覆盖索引，避免select"><a href="#6、尽量使用覆盖索引，避免select" class="headerlink" title="6、尽量使用覆盖索引，避免select *"></a>6、尽量使用覆盖索引，避免select *</h6><p>尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。</p><p><img src="/images/mysql/1556173928299.png" alt="1556173928299"> </p><p>如果查询列，超出索引列，也会降低性能。</p><p><img src="/images/mysql/1556173986068.png" alt="1556173986068"> </p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs axapta">TIP : <br><br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">index</span> ：使用覆盖索引的时候就会出现<br><br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">where</span>：在查找使用索引的情况下，需要回表去查询所需的数据(获取数据还需要去表里拿改行数据，索引只保存了索引部分值)<br><br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">index</span> condition：查找使用了索引，但是需要回表查询数据<br><br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">index</span> ; <span class="hljs-keyword">using</span> <span class="hljs-keyword">where</span>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据<br></code></pre></td></tr></table></figure><h6 id="7、用or分割开的条件，-如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。"><a href="#7、用or分割开的条件，-如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。" class="headerlink" title="7、用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。"></a>7、用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</h6><p>示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_seller <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;黑马程序员&#x27;</span> <span class="hljs-keyword">or</span> createtime <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>\G;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556174994440.png" alt="1556174994440"> </p><h6 id="8、以-开头的Like模糊查询，索引失效。"><a href="#8、以-开头的Like模糊查询，索引失效。" class="headerlink" title="8、以%开头的Like模糊查询，索引失效。"></a>8、以%开头的Like模糊查询，索引失效。</h6><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><p><img src="/images/mysql/1556175114369.png" alt="1556175114369"> </p><p>解决方案 ： </p><p>通过覆盖索引来解决 </p><p><img src="/images/mysql/1556247686483.png" alt="1556247686483"> </p><h6 id="9、如果MySQL评估使用索引比全表更慢，则不使用索引。"><a href="#9、如果MySQL评估使用索引比全表更慢，则不使用索引。" class="headerlink" title="9、如果MySQL评估使用索引比全表更慢，则不使用索引。"></a>9、如果MySQL评估使用索引比全表更慢，则不使用索引。</h6><p><img src="/images/mysql/1556175445210.png" alt="1556175445210"> </p><p>如果not in检索的数据量大，不走索引，但是如果not in检索的数据量小，走索引。同理，in也一样。跟null   not null 是一样的</p><h6 id="10、is-NULL-，-is-NOT-NULL-有时索引失效。"><a href="#10、is-NULL-，-is-NOT-NULL-有时索引失效。" class="headerlink" title="10、is  NULL ， is NOT NULL  有时索引失效。"></a>10、is  NULL ， is NOT NULL  <font color='red'>有时</font>索引失效。</h6><p><img src="/images/mysql/1556180634889.png" alt="1556180634889">  </p><h6 id="11、in走索引，-not-in-索引失效。"><a href="#11、in走索引，-not-in-索引失效。" class="headerlink" title="11、in走索引， not in 索引失效。"></a>11、in走索引， not in 索引失效。</h6><p><img src="/images/mysql/1556249602732.png" alt="1556249602732">  </p><h6 id="12、单列索引和复合索引。"><a href="#12、单列索引和复合索引。" class="headerlink" title="12、单列索引和复合索引。"></a>12、单列索引和复合索引。</h6><p>尽量使用复合索引，而少使用单列索引 。</p><p>创建复合索引 </p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran">create <span class="hljs-built_in">index</span> idx_name_sta_address on tb_seller(<span class="hljs-keyword">name</span>, <span class="hljs-keyword">status</span>, address);<br><br>就相当于创建了三个索引 ： <br><span class="hljs-keyword">name</span><br><span class="hljs-keyword">name</span> + <span class="hljs-keyword">status</span><br><span class="hljs-keyword">name</span> + <span class="hljs-keyword">status</span> + address<br><br></code></pre></td></tr></table></figure><p>创建单列索引 </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_seller_name <span class="hljs-keyword">on</span> tb_seller(<span class="hljs-type">name</span>);<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_seller_status <span class="hljs-keyword">on</span> tb_seller(status);<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_seller_address <span class="hljs-keyword">on</span> tb_seller(address);<br></code></pre></td></tr></table></figure><p>数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部索引 。</p><h4 id="4-3-查看索引使用情况"><a href="#4-3-查看索引使用情况" class="headerlink" title="4.3 查看索引使用情况"></a>4.3 查看索引使用情况</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Handler_read%&#x27;</span>;<br><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Handler_read%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1552885364563.png" alt="1552885364563"> </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Handler_read_first：索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。<br><br>Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。<br><br>Handler_read_next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。<br><br>Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化<span class="hljs-keyword">ORDER</span> <span class="hljs-title">BY</span> ... DESC。<br><br>Handler_read_rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。<br><br>Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。<br></code></pre></td></tr></table></figure><h3 id="5-SQL优化"><a href="#5-SQL优化" class="headerlink" title="5. SQL优化"></a>5. SQL优化</h3><h4 id="5-1-大批量插入数据"><a href="#5-1-大批量插入数据" class="headerlink" title="5.1 大批量插入数据"></a>5.1 大批量插入数据</h4><p>环境准备 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tb_user_2` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `username` <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `password` <span class="hljs-type">varchar</span>(<span class="hljs-number">96</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `birthday` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `sex` <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `email` <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `phone` <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `qq` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `status` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;用户状态&#x27;</span>,<br>  `create_time` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `update_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `unique_user_username` (`username`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 ;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">load data <span class="hljs-keyword">local</span> infile <span class="hljs-string">&#x27;/home/muzili/sql2.log&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> `tb_user_2` fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span> lines terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\n&#x27;</span>;<br>加载本地文件，表名用的是``，不是<span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>当使用load 命令导入数据的时候，适当的设置可以提高导入的效率。</p><p><img src="/images/mysql/1556269346488.png" alt="1556269346488"> </p><p>对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率：</p><h5 id="1、主键顺序插入"><a href="#1、主键顺序插入" class="headerlink" title="1、主键顺序插入"></a>1、主键顺序插入</h5><p>因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl">脚本文件介绍 :<br><span class="hljs-function"><span class="hljs-title">sql1</span>.<span class="hljs-built_in">log</span>  ----&gt;</span> 主键有序<br><span class="hljs-function"><span class="hljs-title">sql2</span>.<span class="hljs-built_in">log</span>  ----&gt;</span> 主键无序<br></code></pre></td></tr></table></figure><p>插入ID顺序排列数据：</p><p><img src="/images/mysql/1555771750567.png" alt="1555771750567"></p><p>插入ID无序排列数据：</p><p><img src="/images/mysql/1555771959734.png" alt="1555771959734"> </p><h5 id="2、关闭唯一性校验"><a href="#2、关闭唯一性校验" class="headerlink" title="2、关闭唯一性校验"></a>2、关闭唯一性校验</h5><p>在导入数据前执行 SET UNIQUE_CHECKS&#x3D;0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS&#x3D;1，恢复唯一性校验，可以提高导入的效率。</p><p><img src="/images/mysql/1555772132736.png" alt="1555772132736"> </p><h5 id="3、手动提交事务"><a href="#3、手动提交事务" class="headerlink" title="3、手动提交事务"></a>3、手动提交事务</h5><p>如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT&#x3D;0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT&#x3D;1，打开自动提交，也可以提高导入的效率。</p><p><img src="/images/mysql/1555772351208.png" alt="1555772351208">&#x2F;</p><h4 id="5-2-优化insert语句"><a href="#5-2-优化insert语句" class="headerlink" title="5.2 优化insert语句"></a>5.2 优化insert语句</h4><p>当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。</p><h5 id="1、如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。"><a href="#1、如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。" class="headerlink" title="1、如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。"></a>1、如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。</h5><p>示例， 原始方式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br></code></pre></td></tr></table></figure><p>优化后的方案为 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>)，(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br></code></pre></td></tr></table></figure><h5 id="2、在事务中进行数据插入。事务提交改为手动提交"><a href="#2、在事务中进行数据插入。事务提交改为手动提交" class="headerlink" title="2、在事务中进行数据插入。事务提交改为手动提交"></a>2、在事务中进行数据插入。事务提交改为手动提交</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><h5 id="3、数据有序插入"><a href="#3、数据有序插入" class="headerlink" title="3、数据有序插入"></a>3、数据有序插入</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Tim&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Rose&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>);<br></code></pre></td></tr></table></figure><p>优化后</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Tim&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Rose&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="5-3-优化order-by语句"><a href="#5-3-优化order-by语句" class="headerlink" title="5.3 优化order by语句"></a>5.3 优化order by语句</h4><h5 id="5-3-1-环境准备"><a href="#5-3-1-环境准备" class="headerlink" title="5.3.1 环境准备"></a>5.3.1 环境准备</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `emp` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `salary` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB  <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-string">&#x27;25&#x27;</span>,<span class="hljs-string">&#x27;2300&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>,<span class="hljs-string">&#x27;30&#x27;</span>,<span class="hljs-string">&#x27;3500&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;Luci&#x27;</span>,<span class="hljs-string">&#x27;25&#x27;</span>,<span class="hljs-string">&#x27;2800&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;Jay&#x27;</span>,<span class="hljs-string">&#x27;36&#x27;</span>,<span class="hljs-string">&#x27;3500&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;Tom2&#x27;</span>,<span class="hljs-string">&#x27;21&#x27;</span>,<span class="hljs-string">&#x27;2200&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&#x27;Jerry2&#x27;</span>,<span class="hljs-string">&#x27;31&#x27;</span>,<span class="hljs-string">&#x27;3300&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;Luci2&#x27;</span>,<span class="hljs-string">&#x27;26&#x27;</span>,<span class="hljs-string">&#x27;2700&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&#x27;Jay2&#x27;</span>,<span class="hljs-string">&#x27;33&#x27;</span>,<span class="hljs-string">&#x27;3500&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&#x27;Tom3&#x27;</span>,<span class="hljs-string">&#x27;23&#x27;</span>,<span class="hljs-string">&#x27;2400&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;10&#x27;</span>,<span class="hljs-string">&#x27;Jerry3&#x27;</span>,<span class="hljs-string">&#x27;32&#x27;</span>,<span class="hljs-string">&#x27;3100&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;11&#x27;</span>,<span class="hljs-string">&#x27;Luci3&#x27;</span>,<span class="hljs-string">&#x27;26&#x27;</span>,<span class="hljs-string">&#x27;2900&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;12&#x27;</span>,<span class="hljs-string">&#x27;Jay3&#x27;</span>,<span class="hljs-string">&#x27;37&#x27;</span>,<span class="hljs-string">&#x27;4500&#x27;</span>);<br><br><span class="hljs-keyword">create</span> index idx_emp_age_salary <span class="hljs-keyword">on</span> emp(age,salary);<br></code></pre></td></tr></table></figure><h5 id="5-3-2-两种排序方式"><a href="#5-3-2-两种排序方式" class="headerlink" title="5.3.2 两种排序方式"></a>5.3.2 两种排序方式</h5><h6 id="1、第一种是通过对返回数据进行排序，也就是通常说的-filesort-排序，所有不是通过索引直接返回排序结果的排序都叫-FileSort-排序。"><a href="#1、第一种是通过对返回数据进行排序，也就是通常说的-filesort-排序，所有不是通过索引直接返回排序结果的排序都叫-FileSort-排序。" class="headerlink" title="1、第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。"></a>1、第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</h6><p><img src="/images/mysql/1556335817763.png" alt="1556335817763"> </p><h6 id="2、第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为-using-index，不需要额外排序，操作效率高。-覆盖索引"><a href="#2、第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为-using-index，不需要额外排序，操作效率高。-覆盖索引" class="headerlink" title="2、第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。(覆盖索引)"></a>2、第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。(覆盖索引)</h6><p><img src="/images/mysql/1556335866539.png" alt="1556335866539"> </p><p>多字段排序</p><p><img src="/images/mysql/1556336352061.png" alt="1556336352061"> &#x2F;</p><p>了解了MySQL的排序方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。where 条件和Order by 使用相同的索引，并且Order By 的顺序和索引顺序相同， 并且Order  by 的字段都是升序，或者都是降序。否则肯定需要额外的操作，这样就会出现FileSort。</p><p>Order  by 的字段都是升序，或者都是降序：一个降序一个升序会出现FileSort</p><p>Order By 的顺序和索引顺序相同：例如索引为索引1，索引2，order by 索引2，索引1</p><p>show index find tablename查看，上边的例子，索引顺序为age,salary</p><h5 id="5-3-3-Filesort-的优化"><a href="#5-3-3-Filesort-的优化" class="headerlink" title="5.3.3 Filesort 的优化"></a>5.3.3 Filesort 的优化</h5><p>通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作。对于Filesort ， MySQL 有两种排序算法：</p><p>1、两次扫描算法 ：MySQL4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I&#x2F;O操作。</p><p>2、一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort  buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。</p><p>MySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query语句取出的字段总大小， 来判定是否那种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。</p><p>可以适当提高 sort_buffer_size  和 max_length_for_sort_data  系统变量，来增大排序区的大小，提高排序的效率。</p><p><img src="/images/mysql/1556338367593.png" alt="1556338367593"> </p><h4 id="5-4-优化group-by-语句"><a href="#5-4-优化group-by-语句" class="headerlink" title="5.4 优化group by 语句"></a>5.4 优化group by 语句</h4><p>由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。</p><p>如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行order by null 禁止排序。如下 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">drop</span> index idx_emp_age_salary <span class="hljs-keyword">on</span> emp;<br><br>explain <span class="hljs-keyword">select</span> age,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> age;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556339573979.png" alt="1556339573979">  </p><p>优化后</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> age,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556339633161.png" alt="1556339633161">  </p><p>从上面的例子可以看出，第一个SQL语句需要进行”filesort”，而第二个SQL由于order  by  null 不需要进行 “filesort”， 而上文提过Filesort往往非常耗费时间。</p><p>创建索引 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> index idx_emp_age_salary <span class="hljs-keyword">on</span> emp(age,salary)；<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556339688158.png" alt="1556339688158"> </p><h4 id="5-5-优化嵌套查询"><a href="#5-5-优化嵌套查询" class="headerlink" title="5.5 优化嵌套查询"></a>5.5 优化嵌套查询</h4><p>Mysql4.1版本之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。</p><p>示例 ，查找有角色的所有的用户信息 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> user_id <span class="hljs-keyword">from</span> user_role );<br></code></pre></td></tr></table></figure><p>执行计划为 : </p><p><img src="/images/mysql/1556359399199.png" alt="1556359399199">   </p><p>优化后 :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user u , user_role ur <span class="hljs-keyword">where</span> u.id <span class="hljs-operator">=</span> ur.user_id;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556359482142.png" alt="1556359482142">   </p><p>连接(Join)查询之所以更有效率一些 ，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。</p><h4 id="5-6-优化OR条件"><a href="#5-6-优化OR条件" class="headerlink" title="5.6 优化OR条件"></a>5.6 优化OR条件</h4><p>对于包含OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引 ， 而且不能使用到复合索引； 如果没有索引，则应该考虑增加索引。</p><p>获取 emp 表中的所有的索引 ： </p><p><img src="/images/mysql/1556354464657.png" alt="1556354464657">  </p><p>示例 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556354887509.png" alt="1556354887509"></p><p><img src="/images/mysql/1556354920964.png" alt="1556354920964">  </p><p>建议使用 union 替换 or ： </p><p><img src="/images/mysql/1556355027728.png" alt="1556355027728"> </p><p>我们来比较下重要指标，发现主要差别是 type 和 ref 这两项</p><p>type 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="hljs-keyword">ref</span> &gt; fulltext &gt; ref_or_null  &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; <span class="hljs-keyword">index</span> &gt; <span class="hljs-keyword">ALL</span><br></code></pre></td></tr></table></figure><p>UNION 语句的 type 值为 ref，OR 语句的 type 值为 range，可以看到这是一个很明显的差距</p><p>UNION 语句的 ref 值为 const，OR 语句的 type 值为 null，const 表示是常量值引用，非常快</p><p>这两项的差距就说明了 UNION 要优于 OR 。</p><h4 id="5-7-优化分页查询"><a href="#5-7-优化分页查询" class="headerlink" title="5.7 优化分页查询"></a>5.7 优化分页查询</h4><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10  ，此时需要MySQL排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p><p><img src="/images/mysql/1556361314783.png" alt="1556361314783"> </p><h5 id="5-7-1-优化思路一"><a href="#5-7-1-优化思路一" class="headerlink" title="5.7.1 优化思路一"></a>5.7.1 优化思路一</h5><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p><p><img src="/images/mysql/1556416102800.png" alt="1556416102800"> </p><h5 id="5-7-2-优化思路二"><a href="#5-7-2-优化思路二" class="headerlink" title="5.7.2 优化思路二"></a>5.7.2 优化思路二</h5><p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。</p><p><img src="/images/mysql/1556363928151.png" alt="1556363928151"> </p><h4 id="5-8-使用SQL提示"><a href="#5-8-使用SQL提示" class="headerlink" title="5.8 使用SQL提示"></a>5.8 使用SQL提示</h4><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><h5 id="5-8-1-USE-INDEX"><a href="#5-8-1-USE-INDEX" class="headerlink" title="5.8.1 USE INDEX"></a>5.8.1 USE INDEX</h5><p>在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_seller_name <span class="hljs-keyword">on</span> tb_seller(<span class="hljs-type">name</span>);<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556370971576.png" alt="1556370971576"> </p><h5 id="5-8-2-IGNORE-INDEX"><a href="#5-8-2-IGNORE-INDEX" class="headerlink" title="5.8.2 IGNORE INDEX"></a>5.8.2 IGNORE INDEX</h5><p>如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 hint 。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_seller <span class="hljs-keyword">ignore</span> <span class="hljs-keyword">index</span>(idx_seller_name) <span class="hljs-keyword">where</span> name = <span class="hljs-string">&#x27;小米科技&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556371004594.png" alt="1556371004594"> </p><h5 id="5-8-3-FORCE-INDEX"><a href="#5-8-3-FORCE-INDEX" class="headerlink" title="5.8.3 FORCE INDEX"></a>5.8.3 FORCE INDEX</h5><p>为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为hint 。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> index idx_seller_address <span class="hljs-keyword">on</span> tb_seller(address);<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556371355788.png" alt="1556371355788"> </p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql高级三</title>
    <link href="/2022/06/11/Mysql%E9%AB%98%E7%BA%A7-day03/"/>
    <url>/2022/06/11/Mysql%E9%AB%98%E7%BA%A7-day03/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">Mysql高级三</font></div><h3 id="1-应用优化"><a href="#1-应用优化" class="headerlink" title="1. 应用优化"></a>1. 应用优化</h3><p>前面章节，我们介绍了很多数据库的优化措施。但是在实际生产环境中，由于数据库本身的性能局限，就必须要对前台的应用进行一些优化，来降低数据库的访问压力。</p><h4 id="1-1-使用连接池"><a href="#1-1-使用连接池" class="headerlink" title="1.1 使用连接池"></a>1.1 使用连接池</h4><p>对于访问数据库来说，建立连接的代价是比较昂贵的，因为我们频繁的创建关闭连接，是比较耗费资源的，我们有必要建立 数据库连接池，以提高访问的性能。</p><h4 id="1-2-减少对MySQL的访问"><a href="#1-2-减少对MySQL的访问" class="headerlink" title="1.2 减少对MySQL的访问"></a>1.2 减少对MySQL的访问</h4><h5 id="1-2-1-避免对数据进行重复检索"><a href="#1-2-1-避免对数据进行重复检索" class="headerlink" title="1.2.1 避免对数据进行重复检索"></a>1.2.1 避免对数据进行重复检索</h5><p>在编写应用代码时，需要能够理清对数据库的访问逻辑。能够一次连接就获取到结果的，就不用两次连接，这样可以大大减少对数据库无用的重复请求。</p><p>比如 ，需要获取书籍的id 和name字段 ， 则查询如下： </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> id , <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> tb_book;<br></code></pre></td></tr></table></figure><p>之后，在业务逻辑中有需要获取到书籍状态信息， 则查询如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select <span class="hljs-built_in">id</span> , status <span class="hljs-keyword">from</span> tb_book;<br></code></pre></td></tr></table></figure><p>这样，就需要向数据库提交两次请求，数据库就要做两次查询操作。其实完全可以用一条SQL语句得到想要的结果。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">select</span> id, <span class="hljs-keyword">name</span> , <span class="hljs-keyword">status</span> from tb_book;<br></code></pre></td></tr></table></figure><h5 id="1-2-2-增加cache层"><a href="#1-2-2-增加cache层" class="headerlink" title="1.2.2 增加cache层"></a>1.2.2 增加cache层</h5><p>在应用中，我们可以在应用中增加 缓存 层来达到减轻数据库负担的目的。缓存层有很多种，也有很多实现方式，只要能达到降低数据库的负担又能满足应用需求就可以。</p><p>因此可以部分数据从数据库中抽取出来放到应用端以文本方式存储， 或者使用框架(Mybatis, Hibernate)提供的一级缓存&#x2F;二级缓存，或者使用redis数据库来缓存数据 。</p><h4 id="1-3-负载均衡"><a href="#1-3-负载均衡" class="headerlink" title="1.3 负载均衡"></a>1.3 负载均衡</h4><p>负载均衡是应用中使用非常普遍的一种优化方法，它的机制就是利用某种均衡算法，将固定的负载量分布到不同的服务器上， 以此来降低单台服务器的负载，达到优化的效果。</p><h5 id="1-3-1-利用MySQL复制分流查询"><a href="#1-3-1-利用MySQL复制分流查询" class="headerlink" title="1.3.1 利用MySQL复制分流查询"></a>1.3.1 利用MySQL复制分流查询</h5><p>通过MySQL的主从复制，实现读写分离，使增删改操作走主节点，查询操作走从节点，从而可以降低单台服务器的读写压力。</p><p><img src="/images/mysql/1.jpg" alt="1"> </p><h5 id="1-3-2-采用分布式数据库架构"><a href="#1-3-2-采用分布式数据库架构" class="headerlink" title="1.3.2 采用分布式数据库架构"></a>1.3.2 采用分布式数据库架构</h5><p>分布式数据库架构适合大数据量、负载高的情况，它有良好的拓展性和高可用性。通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载均衡，提高访问效率。</p><h3 id="2-Mysql中查询缓存优化"><a href="#2-Mysql中查询缓存优化" class="headerlink" title="2. Mysql中查询缓存优化"></a>2. Mysql中查询缓存优化</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>开启Mysql的查询缓存，当执行完全相同的SQL语句的时候，服务器就会直接从缓存中读取结果，当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存。</p><h4 id="2-2-操作流程"><a href="#2-2-操作流程" class="headerlink" title="2.2 操作流程"></a>2.2 操作流程</h4><p> <img src="/images/mysql/20180919131632347.png" alt="20180919131632347"> </p><ol><li>客户端发送一条查询给服务器；</li><li>服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；</li><li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；</li><li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；</li><li>将结果返回给客户端。</li></ol><h4 id="2-3-查询缓存配置"><a href="#2-3-查询缓存配置" class="headerlink" title="2.3 查询缓存配置"></a>2.3 查询缓存配置</h4><ol><li><p>查看当前的MySQL数据库是否支持查询缓存：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;have_query_cache&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1555249929012.png" alt="1555249929012"> </p></li><li><p>查看当前MySQL是否开启了查询缓存 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;query_cache_type&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1555250015377.png" alt="1555250015377"> </p></li><li><p>查看查询缓存的占用大小 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;query_cache_size&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1555250142451.png" alt="1555250142451">  </p></li><li><p>查看查询缓存的状态变量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SHOW</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Qcache%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1555250443958.png" alt="1555250443958"> </p><p>各个变量的含义如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>Qcache_free_blocks</td><td>查询缓存中的可用内存块数</td></tr><tr><td>Qcache_free_memory</td><td>查询缓存的可用内存量</td></tr><tr><td>Qcache_hits</td><td>查询缓存命中数</td></tr><tr><td>Qcache_inserts</td><td>添加到查询缓存的查询数</td></tr><tr><td>Qcache_lowmen_prunes</td><td>由于内存不足而从查询缓存中删除的查询数</td></tr><tr><td>Qcache_not_cached</td><td>非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存）</td></tr><tr><td>Qcache_queries_in_cache</td><td>查询缓存中注册的查询数</td></tr><tr><td>Qcache_total_blocks</td><td>查询缓存中的块总数</td></tr></tbody></table></li></ol><h4 id="2-4-开启查询缓存"><a href="#2-4-开启查询缓存" class="headerlink" title="2.4 开启查询缓存"></a>2.4 开启查询缓存</h4><p>MySQL的查询缓存默认是关闭的，需要手动配置参数 query_cache_type ， 来开启查询缓存。query_cache_type 该参数的可取值有三个 ：</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>OFF 或 0</td><td>查询缓存功能关闭</td></tr><tr><td>ON 或 1</td><td>查询缓存功能打开，SELECT的结果符合缓存条件即会缓存，否则，不予缓存，显式指定 SQL_NO_CACHE，不予缓存</td></tr><tr><td>DEMAND 或 2</td><td>查询缓存功能按需进行，显式指定 SQL_CACHE 的SELECT语句才会缓存；其它均不予缓存</td></tr></tbody></table><p>在 &#x2F;usr&#x2F;my.cnf 配置中，增加以下配置 ： </p><p><img src="/images/mysql/1555251383805.png" alt="1555251383805"> </p><p>配置完毕之后，重启服务既可生效 ；</p><p>然后就可以在命令行执行SQL语句进行验证 ，执行一条比较耗时的SQL语句，然后再多执行几次，查看后面几次的执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存。</p><h4 id="2-5-查询缓存SELECT选项"><a href="#2-5-查询缓存SELECT选项" class="headerlink" title="2.5 查询缓存SELECT选项"></a>2.5 查询缓存SELECT选项</h4><p>可以在SELECT语句中指定两个与查询缓存相关的选项 ：</p><p>SQL_CACHE : 如果查询结果是可缓存的，并且 query_cache_type 系统变量的值为ON或 DEMAND ，则缓存查询结果 。</p><p>SQL_NO_CACHE : 服务器不使用查询缓存。它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果。</p><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> SQL_CACHE id, name <span class="hljs-keyword">FROM</span> customer;<br><span class="hljs-keyword">SELECT</span> SQL_NO_CACHE id, name <span class="hljs-keyword">FROM</span> customer;<br></code></pre></td></tr></table></figure><p>​</p><h4 id="2-6-查询缓存失效的情况"><a href="#2-6-查询缓存失效的情况" class="headerlink" title="2.6 查询缓存失效的情况"></a>2.6 查询缓存失效的情况</h4><p>1） SQL 语句不一致的情况， 要想命中查询缓存，查询的SQL语句必须一致。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL">SQL1 : <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_item;<br>SQL2 : <span class="hljs-keyword">Select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_item;<br></code></pre></td></tr></table></figure><p>2） 当查询语句中有一些不确定的时，则不会缓存。如 ： now() , current_date() , curdate() , curtime() , rand() , uuid() , user() , database() 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL">SQL1 : <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> updatetime <span class="hljs-operator">&lt;</span> now() limit <span class="hljs-number">1</span>;<br>SQL2 : <span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>();<br>SQL3 : <span class="hljs-keyword">select</span> database();<br></code></pre></td></tr></table></figure><p>3） 不使用任何表查询语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br></code></pre></td></tr></table></figure><p>4）  查询 mysql， information_schema或  performance_schema 数据库中的表时，不会走查询缓存。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information_schema.engines;<br></code></pre></td></tr></table></figure><p>5） 在存储的函数，触发器或事件的主体内执行的查询。</p><p>6） 如果表更改，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除。这包括使用<code>MERGE</code>映射到已更改表的表的查询。一个表可以被许多类型的语句，如被改变 INSERT， UPDATE， DELETE， TRUNCATE TABLE， ALTER TABLE， DROP TABLE，或 DROP DATABASE 。</p><h3 id="3-Mysql内存管理及优化"><a href="#3-Mysql内存管理及优化" class="headerlink" title="3. Mysql内存管理及优化"></a>3. Mysql内存管理及优化</h3><h4 id="3-1-内存优化原则"><a href="#3-1-内存优化原则" class="headerlink" title="3.1 内存优化原则"></a>3.1 内存优化原则</h4><p>1） 将尽量多的内存分配给MySQL做缓存，但要给操作系统和其他程序预留足够内存。</p><p>2） MyISAM 存储引擎的数据文件读取依赖于操作系统自身的IO缓存，因此，如果有MyISAM表，就要预留更多的内存给操作系统做IO缓存。</p><p>3） 排序区、连接区等缓存是分配给每个数据库会话（session）专用的，其默认值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽。</p><h4 id="3-2-MyISAM-内存优化"><a href="#3-2-MyISAM-内存优化" class="headerlink" title="3.2 MyISAM 内存优化"></a>3.2 MyISAM 内存优化</h4><p>myisam存储引擎使用 key_buffer 缓存索引块，加速myisam索引的读写速度。对于myisam表的数据块，mysql没有特别的缓存机制，完全依赖于操作系统的IO缓存。</p><h5 id="key-buffer-size"><a href="#key-buffer-size" class="headerlink" title="key_buffer_size"></a>key_buffer_size</h5><p>key_buffer_size决定MyISAM索引块缓存区的大小，直接影响到MyISAM表的存取效率。可以在MySQL参数文件中设置key_buffer_size的值，对于一般MyISAM数据库，建议至少将1&#x2F;4可用内存分配给key_buffer_size。</p><p>在&#x2F;usr&#x2F;my.cnf 中做如下配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">key_buffer_size</span>=<span class="hljs-number">512</span>M<br></code></pre></td></tr></table></figure><h5 id="read-buffer-size"><a href="#read-buffer-size" class="headerlink" title="read_buffer_size"></a>read_buffer_size</h5><p>如果需要经常顺序扫描myisam表，可以通过增大read_buffer_size的值来改善性能。但需要注意的是read_buffer_size是每个session独占的，如果默认值设置太大，就会造成内存浪费。</p><h5 id="read-rnd-buffer-size"><a href="#read-rnd-buffer-size" class="headerlink" title="read_rnd_buffer_size"></a>read_rnd_buffer_size</h5><p>对于需要做排序的myisam表的查询，如带有order by子句的sql，适当增加 read_rnd_buffer_size 的值，可以改善此类的sql性能。但需要注意的是 read_rnd_buffer_size 是每个session独占的，如果默认值设置太大，就会造成内存浪费。</p><h4 id="3-3-InnoDB-内存优化"><a href="#3-3-InnoDB-内存优化" class="headerlink" title="3.3 InnoDB 内存优化"></a>3.3 InnoDB 内存优化</h4><p>innodb用一块内存区做IO缓存池，该缓存池不仅用来缓存innodb的索引块，而且也用来缓存innodb的数据块。</p><h5 id="innodb-buffer-pool-size"><a href="#innodb-buffer-pool-size" class="headerlink" title="innodb_buffer_pool_size"></a>innodb_buffer_pool_size</h5><p>该变量决定了 innodb 存储引擎表数据和索引数据的最大缓存区大小。在保证操作系统及其他程序有足够内存可用的情况下，innodb_buffer_pool_size 的值越大，缓存命中率越高，访问InnoDB表需要的磁盘I&#x2F;O 就越少，性能也就越高。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">innodb_buffer_pool_size</span>=<span class="hljs-number">512</span>M<br></code></pre></td></tr></table></figure><h5 id="innodb-log-buffer-size"><a href="#innodb-log-buffer-size" class="headerlink" title="innodb_log_buffer_size"></a>innodb_log_buffer_size</h5><p>决定了innodb重做日志缓存的大小，对于可能产生大量更新记录的大事务，增加innodb_log_buffer_size的大小，可以避免innodb在事务提交前就执行不必要的日志写入磁盘操作。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">innodb_log_buffer_size</span>=<span class="hljs-number">10</span>M<br></code></pre></td></tr></table></figure><h3 id="4-Mysql并发参数调整"><a href="#4-Mysql并发参数调整" class="headerlink" title="4. Mysql并发参数调整"></a>4. Mysql并发参数调整</h3><p>从实现上来说，MySQL Server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在Mysql中，控制并发连接和线程的主要参数包括 max_connections、back_log、thread_cache_size、table_open_cahce。</p><h4 id="4-1-max-connections"><a href="#4-1-max-connections" class="headerlink" title="4.1 max_connections"></a>4.1 max_connections</h4><p>采用max_connections 控制允许连接到MySQL数据库的最大数量，默认值是 151。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。</p><p>Mysql 最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。</p><h4 id="4-2-back-log"><a href="#4-2-back-log" class="headerlink" title="4.2 back_log"></a>4.2 back_log</h4><p>back_log 参数控制MySQL监听TCP端口时设置的积压请求栈大小。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections &#x2F; 5）， 但最大不超过900。</p><p>如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</p><h4 id="4-3-table-open-cache"><a href="#4-3-table-open-cache" class="headerlink" title="4.3 table_open_cache"></a>4.3 table_open_cache</h4><p>该参数用来控制所有SQL语句执行线程可打开表缓存的数量， 而在执行SQL语句时，每一个SQL执行线程至少要打开 1 个表缓存。该参数的值应该根据设置的最大连接数 max_connections 以及每个连接执行关联查询中涉及的表的最大数量来设定 ：</p><p>​max_connections x N ；</p><h4 id="4-4-thread-cache-size"><a href="#4-4-thread-cache-size" class="headerlink" title="4.4 thread_cache_size"></a>4.4 thread_cache_size</h4><p>为了加快连接数据库的速度，MySQL 会缓存一定数量的客户服务线程以备重用，通过参数 thread_cache_size 可控制 MySQL 缓存客户服务线程的数量。</p><h4 id="4-5-innodb-lock-wait-timeout"><a href="#4-5-innodb-lock-wait-timeout" class="headerlink" title="4.5 innodb_lock_wait_timeout"></a>4.5 innodb_lock_wait_timeout</h4><p>该参数是用来设置InnoDB 事务等待行锁的时间，默认值是50ms ， 可以根据需要进行动态设置。对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起； 对于后台运行的批量处理程序来说， 可以将行锁的等待时间调大， 以避免发生大的回滚操作。</p><h3 id="5-Mysql锁问题"><a href="#5-Mysql锁问题" class="headerlink" title="5. Mysql锁问题"></a>5. Mysql锁问题</h3><h4 id="5-1-锁概述"><a href="#5-1-锁概述" class="headerlink" title="5.1 锁概述"></a>5.1 锁概述</h4><p>锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。</p><p>在数据库中，除传统的计算资源（如 CPU、RAM、I&#x2F;O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><h4 id="5-2-锁分类"><a href="#5-2-锁分类" class="headerlink" title="5.2 锁分类"></a>5.2 锁分类</h4><p>从对数据操作的粒度分 ： </p><p>1） 表锁：操作时，会锁定整个表。</p><p>2） 行锁：操作时，会锁定当前操作行。</p><p>从对数据操作的类型分：</p><p>1） 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</p><p>2） 写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。</p><h4 id="5-3-Mysql-锁"><a href="#5-3-Mysql-锁" class="headerlink" title="5.3 Mysql 锁"></a>5.3 Mysql 锁</h4><p>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。下表中罗列出了各存储引擎对锁的支持情况：</p><table><thead><tr><th>存储引擎</th><th>表级锁</th><th>行级锁</th><th>页面锁</th></tr></thead><tbody><tr><td>MyISAM</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>InnoDB</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>MEMORY</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>BDB</td><td>支持</td><td>不支持</td><td>支持</td></tr></tbody></table><p>MySQL这3种锁的特性可大致归纳如下 ：</p><table><thead><tr><th>锁类型</th><th>特点</th></tr></thead><tbody><tr><td>表级锁</td><td>偏向MyISAM 存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</td></tr><tr><td>行级锁</td><td>偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</td></tr><tr><td>页面锁</td><td>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</td></tr></tbody></table><p>从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（OLTP）系统。</p><h4 id="5-2-MyISAM-表锁"><a href="#5-2-MyISAM-表锁" class="headerlink" title="5.2 MyISAM 表锁"></a>5.2 MyISAM 表锁</h4><p>MyISAM 存储引擎只支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。</p><h5 id="5-2-1-如何加表锁"><a href="#5-2-1-如何加表锁" class="headerlink" title="5.2.1 如何加表锁"></a>5.2.1 如何加表锁</h5><p>MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。</p><p>显示加表锁语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL">加读锁 ： lock <span class="hljs-keyword">table</span> table_name read;<br><br>加写锁 ： lock <span class="hljs-keyword">table</span> table_name write；<br></code></pre></td></tr></table></figure><h5 id="5-2-2-读锁案例"><a href="#5-2-2-读锁案例" class="headerlink" title="5.2.2 读锁案例"></a>5.2.2 读锁案例</h5><p>准备环境</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> database demo_03 <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8mb4;<br><br>use demo_03;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tb_book` (<br>  `id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) auto_increment,<br>  `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `publish_time` <span class="hljs-type">DATE</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `status` <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>myisam <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 ;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb_book (id, name, publish_time, status) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;java编程思想&#x27;</span>,<span class="hljs-string">&#x27;2088-08-01&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb_book (id, name, publish_time, status) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;solr编程思想&#x27;</span>,<span class="hljs-string">&#x27;2088-08-08&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>);<br><br><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tb_user` (<br>  `id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) auto_increment,<br>  `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>myisam <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 ;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb_user (id, name) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;令狐冲&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb_user (id, name) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;田伯光&#x27;</span>);<br><br></code></pre></td></tr></table></figure><p>客户端 一 ：</p><p>1）获得tb_book 表的读锁 </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">lock</span> <span class="hljs-keyword">table</span> tb_book <span class="hljs-keyword">read</span>;<br></code></pre></td></tr></table></figure><p>2） 执行查询操作</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_book;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1553906896564.png" alt="1553906896564"> </p><p>可以正常执行 ， 查询出数据。</p><p>客户端 二 ：</p><p>3） 执行查询操作</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_book;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1553907044500.png" alt="1553907044500"> </p><p>客户端 一 ：</p><p>4）查询未锁定的表</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> tb_seller;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1553908913515.png" alt="1553908913515"> </p><p>客户端 二 ：</p><p>5）查询未锁定的表</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> tb_seller;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1553908973840.png" alt="1553908973840"> </p><p>可以正常查询出未锁定的表；</p><p>客户端 一 ：</p><p>6） 执行插入操作 </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_book <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span>,<span class="hljs-string">&#x27;Mysql高级&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1553907198462.png" alt="1553907198462"> </p><p>执行插入， 直接报错 ， 由于当前tb_book 获得的是 读锁， 不能执行更新操作。</p><p>客户端 二 ：</p><p>7） 执行插入操作 </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_book <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span>,<span class="hljs-string">&#x27;Mysql高级&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1553907403957.png" alt="1553907403957"> </p><p>当在客户端一中释放锁指令 unlock tables  后 ， 客户端二中的 inesrt 语句 ， 立即执行 ；</p><h5 id="5-2-3-写锁案例"><a href="#5-2-3-写锁案例" class="headerlink" title="5.2.3 写锁案例"></a>5.2.3 写锁案例</h5><p>客户端 一 :</p><p>1）获得tb_book 表的写锁 </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">lock</span> <span class="hljs-keyword">table</span> tb_book <span class="hljs-keyword">write</span> ;<br></code></pre></td></tr></table></figure><p>2）执行查询操作</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_book ;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1553907849829.png" alt="1553907849829"> </p><p>查询操作执行成功；</p><p>3）执行更新操作</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span> tb_book <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;java编程思想（第二版）&#x27;</span> <span class="hljs-keyword">where</span> id = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1553907875221.png" alt="1553907875221"> </p><p>更新操作执行成功 ；</p><p>客户端 二 :</p><p>4）执行查询操作</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_book ;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1553908019755.png" alt="1553908019755"> </p><p>当在客户端一中释放锁指令 unlock tables  后 ， 客户端二中的 select 语句 ， 立即执行 ；</p><p><img src="/images/mysql/1553908131373.png" alt="1553908131373"> </p><h5 id="5-2-4-结论"><a href="#5-2-4-结论" class="headerlink" title="5.2.4 结论"></a>5.2.4 结论</h5><p>锁模式的相互兼容性如表中所示：</p><p><img src="/images/mysql/1553905621992.png" alt="1553905621992"> </p><p>由上表可见： </p><p>​1） 对MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</p><p>​2） 对MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；</p><p>​简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁，则既会阻塞读，又会阻塞写。</p><p>此外，MyISAM 的读写锁调度是写优先，这也是MyISAM不适合做写为主的表的存储引擎的原因。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p><h5 id="5-2-5-查看锁的争用情况"><a href="#5-2-5-查看锁的争用情况" class="headerlink" title="5.2.5 查看锁的争用情况"></a>5.2.5 查看锁的争用情况</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">tables</span>；<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556443073322.png" alt="1556443073322"> </p><p>In_user : 表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。</p><p>Name_locked：表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Table_locks%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556443170082.png" alt="1556443170082"> </p><p>Table_locks_immediate ： 指的是能够立即获得表级锁的次数，每立即获取锁，值加1。</p><p>Table_locks_waited ： 指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加1，此值高说明存在着较为严重的表级锁争用情况。</p><h4 id="5-3-InnoDB-行锁"><a href="#5-3-InnoDB-行锁" class="headerlink" title="5.3 InnoDB 行锁"></a>5.3 InnoDB 行锁</h4><h5 id="5-3-1-行锁介绍"><a href="#5-3-1-行锁介绍" class="headerlink" title="5.3.1 行锁介绍"></a>5.3.1 行锁介绍</h5><p>行锁特点 ：偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p><p>InnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是 采用了行级锁。</p><h5 id="5-3-2-背景知识"><a href="#5-3-2-背景知识" class="headerlink" title="5.3.2 背景知识"></a>5.3.2 背景知识</h5><p><strong>事务及其ACID属性</strong></p><p>事务是由一组SQL语句组成的逻辑处理单元。</p><p>事务具有以下4个特性，简称为事务ACID属性。</p><table><thead><tr><th>ACID属性</th><th>含义</th></tr></thead><tbody><tr><td>原子性（Atomicity）</td><td>事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败。</td></tr><tr><td>一致性（Consistent）</td><td>在事务开始和完成时，数据都必须保持一致状态。</td></tr><tr><td>隔离性（Isolation）</td><td>数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的 “独立” 环境下运行。</td></tr><tr><td>持久性（Durable）</td><td>事务完成之后，对于数据的修改是永久的。</td></tr></tbody></table><p><strong>并发事务处理带来的问题</strong></p><table><thead><tr><th>问题</th><th>含义</th><th>解决</th></tr></thead><tbody><tr><td>丢失更新（Lost Update）</td><td>当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖。</td><td></td></tr><tr><td>脏读（Dirty Reads）</td><td>当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</td><td></td></tr><tr><td>不可重复读（Non-Repeatable Reads）</td><td>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现和以前读出的数据不一致。<strong>针对update操作</strong></td><td>使用<strong>行级锁</strong>，锁定该行，当前事务多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。</td></tr><tr><td>幻读（Phantom Reads）</td><td>一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其他事务插入了满足其查询条件的新数据。<strong>针对insert和delete操作</strong></td><td>使用<strong>表级锁</strong>，锁定整张表，当前事务多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。</td></tr></tbody></table><p><strong>事务隔离级别</strong></p><p>为了解决上述提到的事务并发问题，数据库提供一定的事务隔离机制来解决这个问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使用事务在一定程度上“串行化” 进行，这显然与“并发” 是矛盾的。 </p><p>数据库的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏写、脏读、不可重复读、幻读这几类问题。</p><table><thead><tr><th>隔离级别</th><th>丢失更新</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable read（默认）</td><td>×</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>备注 ： √  代表可能出现 ， × 代表不会出现 。</p><p>Mysql 的数据库的默认隔离级别为 Repeatable read ， 查看方式：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;tx_isolation&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1554331600009.png" alt="1554331600009">  </p><h5 id="5-3-3-InnoDB-的行锁模式"><a href="#5-3-3-InnoDB-的行锁模式" class="headerlink" title="5.3.3 InnoDB 的行锁模式"></a>5.3.3 InnoDB 的行锁模式</h5><p>InnoDB  实现了以下两种类型的行锁。</p><ul><li>共享锁（S）：又称为读锁，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改，我们可以用<code>select ...... lock in share mode;</code>的方式手工加上一把<code>S锁</code>。</li><li>排他锁（X）：又称为写锁，简称X锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改，我们用一个<code>FOR UPDATE</code>给一行数据加上一个<code>X锁</code>。</li></ul><p>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；</p><p>对于普通SELECT语句，InnoDB不会加任何锁；</p><p>可以通过以下语句显示给记录集加共享锁或排他锁 。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">共享锁（S）：<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE<br><br>排他锁（X) ：<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span><br></code></pre></td></tr></table></figure><h5 id="5-3-4-案例准备工作"><a href="#5-3-4-案例准备工作" class="headerlink" title="5.3.4 案例准备工作"></a>5.3.4 案例准备工作</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test_innodb_lock(<br>id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>),<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>),<br>sex <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>)<br>)engine <span class="hljs-operator">=</span> innodb <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;100&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;400&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;500&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;600&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;700&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;800&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;900&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;200&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>);<br><br><span class="hljs-keyword">create</span> index idx_test_innodb_lock_id <span class="hljs-keyword">on</span> test_innodb_lock(id);<br><span class="hljs-keyword">create</span> index idx_test_innodb_lock_name <span class="hljs-keyword">on</span> test_innodb_lock(name);<br></code></pre></td></tr></table></figure><h5 id="5-3-5-行锁基本演示"><a href="#5-3-5-行锁基本演示" class="headerlink" title="5.3.5 行锁基本演示"></a>5.3.5 行锁基本演示</h5><table><thead><tr><th>Session-1</th><th>Session-2</th></tr></thead><tbody><tr><td><img src="/images/mysql/1554354615030.png" alt="1554354615030">      关闭自动提交功能</td><td><img src="/images/mysql/1554354601867.png" alt="1554354601867">  关闭自动提交功能</td></tr><tr><td><img src="/images/mysql/1554354713628.png" alt="1554354713628"> 可以正常的查询出全部的数据</td><td><img src="/images/mysql/1554354717336.png" alt="1554354717336"> 可以正常的查询出全部的数据</td></tr><tr><td><img src="/images/mysql/1554354830589.png" alt="1554354830589">查询id 为3的数据 ；</td><td><img src="/images/mysql/1554354832708.png" alt="1554354832708">获取id为3的数据 ；</td></tr><tr><td><img src="/images/mysql/1554382789984.png" alt="1554382789984"> 更新id为3的数据，但是不提交；</td><td><img src="/images/mysql/1554382905352.png" alt="1554382905352"> 更新id为3 的数据， 出于等待状态</td></tr><tr><td><img src="/images/mysql/1554382977653.png" alt="1554382977653"> 通过commit， 提交事务</td><td><img src="/images/mysql/1554383044542.png" alt="1554383044542"> 解除阻塞，更新正常进行</td></tr><tr><td>以上， 操作的都是同一行的数据，接下来，演示不同行的数据 ：</td><td></td></tr><tr><td><img src="/images/mysql/1554385220580.png" alt="1554385220580"> 更新id为3数据，正常的获取到行锁 ， 执行更新 ；</td><td><img src="/images/mysql/1554385236768.png" alt="1554385236768"> 由于与Session-1 操作不是同一行，获取当前行锁，执行更新；</td></tr></tbody></table><h5 id="5-3-6-无索引行锁升级为表锁"><a href="#5-3-6-无索引行锁升级为表锁" class="headerlink" title="5.3.6 无索引行锁升级为表锁"></a>5.3.6 无索引行锁升级为表锁</h5><p>如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。</p><p>查看当前表的索引 ： show  index  from test_innodb_lock ;</p><p><img src="/images/mysql/1554385956215.png" alt="1554385956215"> </p><table><thead><tr><th>Session-1</th><th>Session-2</th></tr></thead><tbody><tr><td>关闭事务的自动提交<img src="/images/mysql/1554386287454.png" alt="1554386287454"></td><td>关闭事务的自动提交<img src="/images/mysql/1554386312524.png" alt="1554386312524"></td></tr><tr><td>执行更新语句 ：<img src="/images/mysql/1554386654793.png" alt="1554386654793"></td><td>执行更新语句， 但处于阻塞状态：<img src="/images/mysql/1554386685610.png" alt="1554386685610"></td></tr><tr><td>提交事务：<img src="/images/mysql/1554386721653.png" alt="1554386721653"></td><td>解除阻塞，执行更新成功 ：<img src="/images/mysql/1554386750004.png" alt="1554386750004"></td></tr><tr><td></td><td>执行提交操作 ：<img src="/images/mysql/1554386804807.png" alt="1554386804807"></td></tr></tbody></table><p>由于 执行更新时 ， name字段本来为varchar类型， 我们是作为数组类型使用，存在类型转换，索引失效，最终行锁变为表锁 ；</p><h5 id="5-3-7-间隙锁危害"><a href="#5-3-7-间隙锁危害" class="headerlink" title="5.3.7 间隙锁危害"></a>5.3.7 间隙锁危害</h5><p>当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁； 对于键值在条件范围内但并不存在的记录，叫做 “间隙（GAP）” ， InnoDB也会对这个 “间隙” 加锁，这种锁机制就是所谓的 间隙锁（Next-Key锁） 。</p><p>示例 ： </p><table><thead><tr><th>Session-1</th><th>Session-2</th></tr></thead><tbody><tr><td>关闭事务自动提交 <img src="/images/mysql/1554387987130.png" alt="1554387987130"></td><td>关闭事务自动提交<img src="/images/mysql/1554387994533.png" alt="1554387994533"></td></tr><tr><td>根据id范围更新数据<img src="/images/mysql/1554388492478.png" alt="1554388492478"></td><td></td></tr><tr><td></td><td>插入id为2的记录， 出于阻塞状态<img src="/images/mysql/1554388515936.png" alt="1554388515936"></td></tr><tr><td>提交事务 ；<img src="/images/mysql/1554388149305.png" alt="1554388149305"></td><td></td></tr><tr><td></td><td>解除阻塞 ， 执行插入操作 ：<img src="/images/mysql/1554388548562.png" alt="1554388548562"></td></tr><tr><td></td><td>提交事务 ：</td></tr></tbody></table><h5 id="5-3-8-InnoDB-行锁争用情况"><a href="#5-3-8-InnoDB-行锁争用情况" class="headerlink" title="5.3.8 InnoDB 行锁争用情况"></a>5.3.8 InnoDB 行锁争用情况</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span>  status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_row_lock%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/mysql/1556455943670.png" alt="1556455943670"></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Innodb_row_lock_current_waits:</span> 当前正在等待锁定的数量<br><br><span class="hljs-symbol">Innodb_row_lock_time:</span> 从系统启动到现在锁定总时间长度<br><br><span class="hljs-symbol">Innodb_row_lock_time_avg:</span>每次等待所花平均时长<br><br><span class="hljs-symbol">Innodb_row_lock_time_max:</span>从系统启动到现在等待最长的一次所花的时间<br><br><span class="hljs-symbol">Innodb_row_lock_waits:</span> 系统启动后到现在总共等待的次数<br><br><br>当等待的次数很高，而且每次等待的时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。<br><br></code></pre></td></tr></table></figure><h5 id="5-3-9-总结"><a href="#5-3-9-总结" class="headerlink" title="5.3.9 总结"></a>5.3.9 总结</h5><p>InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高一些，但是在整体并发处理能力方面要远远由于MyISAM的表锁的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势。</p><p>但是，InnoDB的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p><p>优化建议：</p><ul><li>尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁。</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能减少索引条件，及索引范围，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>尽可使用低级别事务隔离（但是需要业务层面满足需求）</li></ul><h3 id="6-常用SQL技巧"><a href="#6-常用SQL技巧" class="headerlink" title="6. 常用SQL技巧"></a>6. 常用SQL技巧</h3><h4 id="6-1-SQL执行顺序"><a href="#6-1-SQL执行顺序" class="headerlink" title="6.1 SQL执行顺序"></a>6.1 SQL执行顺序</h4><p>编写顺序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span><br><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> list<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">FROM</span><br><span class="hljs-operator">&lt;</span>left_table<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>join_type<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">JOIN</span><br><span class="hljs-operator">&lt;</span>right_table<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>join_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">WHERE</span><br><span class="hljs-operator">&lt;</span>where_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br><span class="hljs-operator">&lt;</span>group_by_list<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">HAVING</span><br><span class="hljs-operator">&lt;</span>having_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br><span class="hljs-operator">&lt;</span>order_by_condition<span class="hljs-operator">&gt;</span><br>LIMIT<br><span class="hljs-operator">&lt;</span>limit_params<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>执行顺序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">FROM</span><span class="hljs-operator">&lt;</span>left_table<span class="hljs-operator">&gt;</span><br><br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>join_condition<span class="hljs-operator">&gt;</span><br><br><span class="hljs-operator">&lt;</span>join_type<span class="hljs-operator">&gt;</span><span class="hljs-keyword">JOIN</span><span class="hljs-operator">&lt;</span>right_table<span class="hljs-operator">&gt;</span><br><br><span class="hljs-keyword">WHERE</span><span class="hljs-operator">&lt;</span>where_condition<span class="hljs-operator">&gt;</span><br><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>group_by_list<span class="hljs-operator">&gt;</span><br><br><span class="hljs-keyword">HAVING</span><span class="hljs-operator">&lt;</span>having_condition<span class="hljs-operator">&gt;</span><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> list<span class="hljs-operator">&gt;</span><br><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><span class="hljs-operator">&lt;</span>order_by_condition<span class="hljs-operator">&gt;</span><br><br>LIMIT<span class="hljs-operator">&lt;</span>limit_params<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h4 id="6-2-正则表达式使用"><a href="#6-2-正则表达式使用" class="headerlink" title="6.2 正则表达式使用"></a>6.2 正则表达式使用</h4><p>正则表达式（Regular Expression）是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>^</td><td>在字符串开始处进行匹配</td></tr><tr><td>$</td><td>在字符串末尾处进行匹配</td></tr><tr><td>.</td><td>匹配任意单个字符, 包括换行符</td></tr><tr><td>[…]</td><td>匹配出括号内的任意字符</td></tr><tr><td>[^…]</td><td>匹配不出括号内的任意字符</td></tr><tr><td>a*</td><td>匹配零个或者多个a(包括空串)</td></tr><tr><td>a+</td><td>匹配一个或者多个a(不包括空串)</td></tr><tr><td>a?</td><td>匹配零个或者一个a</td></tr><tr><td>a1|a2</td><td>匹配a1或a2</td></tr><tr><td>a(m)</td><td>匹配m个a</td></tr><tr><td>a(m,)</td><td>至少匹配m个a</td></tr><tr><td>a(m,n)</td><td>匹配m个a 到 n个a</td></tr><tr><td>a(,n)</td><td>匹配0到n个a</td></tr><tr><td>(…)</td><td>将模式元素组成单一元素</td></tr></tbody></table><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> regexp <span class="hljs-string">&#x27;^T&#x27;</span>;<br><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> regexp <span class="hljs-string">&#x27;2$&#x27;</span>;<br><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> regexp <span class="hljs-string">&#x27;[uvw]&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="6-3-MySQL-常用函数"><a href="#6-3-MySQL-常用函数" class="headerlink" title="6.3 MySQL 常用函数"></a>6.3 MySQL 常用函数</h4><p>数字函数</p><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td>ABS</td><td>求绝对值</td></tr><tr><td>SQRT</td><td>求二次方根</td></tr><tr><td>MOD</td><td>求余数</td></tr><tr><td>CEIL 和 CEILING</td><td>两个函数功能相同，都是返回不小于参数的最小整数，即向上取整</td></tr><tr><td>FLOOR</td><td>向下取整，返回值转化为一个BIGINT</td></tr><tr><td>RAND</td><td>生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列</td></tr><tr><td>ROUND</td><td>对所传参数进行四舍五入</td></tr><tr><td>SIGN</td><td>返回参数的符号</td></tr><tr><td>POW 和 POWER</td><td>两个函数的功能相同，都是所传参数的次方的结果值</td></tr><tr><td>SIN</td><td>求正弦值</td></tr><tr><td>ASIN</td><td>求反正弦值，与函数 SIN 互为反函数</td></tr><tr><td>COS</td><td>求余弦值</td></tr><tr><td>ACOS</td><td>求反余弦值，与函数 COS 互为反函数</td></tr><tr><td>TAN</td><td>求正切值</td></tr><tr><td>ATAN</td><td>求反正切值，与函数 TAN 互为反函数</td></tr><tr><td>COT</td><td>求余切值</td></tr></tbody></table><p>字符串函数</p><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td>LENGTH</td><td>计算字符串长度函数，返回字符串的字节长度</td></tr><tr><td>CONCAT</td><td>合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个</td></tr><tr><td>INSERT</td><td>替换字符串函数</td></tr><tr><td>LOWER</td><td>将字符串中的字母转换为小写</td></tr><tr><td>UPPER</td><td>将字符串中的字母转换为大写</td></tr><tr><td>LEFT</td><td>从左侧字截取符串，返回字符串左边的若干个字符</td></tr><tr><td>RIGHT</td><td>从右侧字截取符串，返回字符串右边的若干个字符</td></tr><tr><td>TRIM</td><td>删除字符串左右两侧的空格</td></tr><tr><td>REPLACE</td><td>字符串替换函数，返回替换后的新字符串</td></tr><tr><td>SUBSTRING</td><td>截取字符串，返回从指定位置开始的指定长度的字符换</td></tr><tr><td>REVERSE</td><td>字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</td></tr></tbody></table><p>日期函数</p><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td>CURDATE 和 CURRENT_DATE</td><td>两个函数作用相同，返回当前系统的日期值</td></tr><tr><td>CURTIME 和 CURRENT_TIME</td><td>两个函数作用相同，返回当前系统的时间值</td></tr><tr><td>NOW 和  SYSDATE</td><td>两个函数作用相同，返回当前系统的日期和时间值</td></tr><tr><td>MONTH</td><td>获取指定日期中的月份</td></tr><tr><td>MONTHNAME</td><td>获取指定日期中的月份英文名称</td></tr><tr><td>DAYNAME</td><td>获取指定曰期对应的星期几的英文名称</td></tr><tr><td>DAYOFWEEK</td><td>获取指定日期对应的一周的索引位置值</td></tr><tr><td>WEEK</td><td>获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53</td></tr><tr><td>DAYOFYEAR</td><td>获取指定曰期是一年中的第几天，返回值范围是1~366</td></tr><tr><td>DAYOFMONTH</td><td>获取指定日期是一个月中是第几天，返回值范围是1~31</td></tr><tr><td>YEAR</td><td>获取年份，返回值范围是 1970〜2069</td></tr><tr><td>TIME_TO_SEC</td><td>将时间参数转换为秒数</td></tr><tr><td>SEC_TO_TIME</td><td>将秒数转换为时间，与TIME_TO_SEC 互为反函数</td></tr><tr><td>DATE_ADD 和 ADDDATE</td><td>两个函数功能相同，都是向日期添加指定的时间间隔</td></tr><tr><td>DATE_SUB 和 SUBDATE</td><td>两个函数功能相同，都是向日期减去指定的时间间隔</td></tr><tr><td>ADDTIME</td><td>时间加法运算，在原始时间上添加指定的时间</td></tr><tr><td>SUBTIME</td><td>时间减法运算，在原始时间上减去指定的时间</td></tr><tr><td>DATEDIFF</td><td>获取两个日期之间间隔，返回参数 1 减去参数 2 的值</td></tr><tr><td>DATE_FORMAT</td><td>格式化指定的日期，根据参数返回指定格式的值</td></tr><tr><td>WEEKDAY</td><td>获取指定日期在一周内的对应的工作日索引</td></tr></tbody></table><p>聚合函数</p><table><thead><tr><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td>MAX</td><td>查询指定列的最大值</td></tr><tr><td>MIN</td><td>查询指定列的最小值</td></tr><tr><td>COUNT</td><td>统计查询结果的行数</td></tr><tr><td>SUM</td><td>求和，返回指定列的总和</td></tr><tr><td>AVG</td><td>求平均值，返回指定列数据的平均值</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql高级一</title>
    <link href="/2022/06/11/Mysql%E9%AB%98%E7%BA%A7-day01/"/>
    <url>/2022/06/11/Mysql%E9%AB%98%E7%BA%A7-day01/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">Mysql高级一</font></div><h3 id="1-Linux-系统安装MySQL"><a href="#1-Linux-系统安装MySQL" class="headerlink" title="1. Linux 系统安装MySQL"></a>1. Linux 系统安装MySQL</h3><h4 id="1-1-下载Linux-安装包"><a href="#1-1-下载Linux-安装包" class="headerlink" title="1.1 下载Linux 安装包"></a>1.1 下载Linux 安装包</h4><h4 id="1-2-安装MySQL"><a href="#1-2-安装MySQL" class="headerlink" title="1.2 安装MySQL"></a>1.2 安装MySQL</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>). 卸载 centos 中预安装的 mysql<br><br><span class="hljs-attribute">rpm</span> -qa | grep -i mysql<br><br><span class="hljs-attribute">rpm</span> -e mysql-libs-<span class="hljs-number">5</span>.<span class="hljs-number">1</span>.<span class="hljs-number">71</span>-<span class="hljs-number">1</span>.el6.x86_64 --nodeps<br><br><span class="hljs-attribute">2</span>). 上传 mysql 的安装包<br><br><span class="hljs-attribute">alt</span> + p -------&gt; put  E:/test/MySQL-<span class="hljs-number">5</span>.<span class="hljs-number">6</span>.<span class="hljs-number">22</span>-<span class="hljs-number">1</span>.el6.i686.rpm-bundle.tar<br><br><span class="hljs-attribute">3</span>). 解压 mysql 的安装包 <br><br><span class="hljs-attribute">mkdir</span> mysql<br><br><span class="hljs-attribute">tar</span> -xvf MySQL-<span class="hljs-number">5</span>.<span class="hljs-number">6</span>.<span class="hljs-number">22</span>-<span class="hljs-number">1</span>.el6.i686.rpm-bundle.tar -C /root/mysql<br><br><span class="hljs-attribute">4</span>). 安装依赖包 <br><br><span class="hljs-attribute">yum</span> -y install libaio.so.<span class="hljs-number">1</span> libgcc_s.so.<span class="hljs-number">1</span> libstdc++.so.<span class="hljs-number">6</span> libncurses.so.<span class="hljs-number">5</span> --setopt=protected_multilib=false<br><br><span class="hljs-attribute">yum</span>  update libstdc++-<span class="hljs-number">4</span>.<span class="hljs-number">4</span>.<span class="hljs-number">7</span>-<span class="hljs-number">4</span>.el6.x86_64<br><br><span class="hljs-attribute">5</span>). 安装 mysql-client<br><br><span class="hljs-attribute">rpm</span> -ivh MySQL-client-<span class="hljs-number">5</span>.<span class="hljs-number">6</span>.<span class="hljs-number">22</span>-<span class="hljs-number">1</span>.el6.i686.rpm<br><br><span class="hljs-attribute">6</span>). 安装 mysql-server<br><br><span class="hljs-attribute">rpm</span> -ivh MySQL-server-<span class="hljs-number">5</span>.<span class="hljs-number">6</span>.<span class="hljs-number">22</span>-<span class="hljs-number">1</span>.el6.i686.rpm<br><br></code></pre></td></tr></table></figure><h4 id="1-3-启动-MySQL-服务"><a href="#1-3-启动-MySQL-服务" class="headerlink" title="1.3 启动 MySQL 服务"></a>1.3 启动 MySQL 服务</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SQL">service mysql <span class="hljs-keyword">start</span><br><br>service mysql stop<br><br>service mysql status<br><br>service mysql restart<br></code></pre></td></tr></table></figure><h4 id="1-4-登录MySQL"><a href="#1-4-登录MySQL" class="headerlink" title="1.4 登录MySQL"></a>1.4 登录MySQL</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql 安装完成之后, 会自动生成一个随机的密码, 并且保存在一个密码文件中 : /root/.mysql_secret<br><br>mysql -u root -p <br><br>登录之后, 修改密码 :<br><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">password</span> = <span class="hljs-keyword">password</span>(<span class="hljs-string">&#x27;itcast&#x27;</span>);<br><br>授权远程访问 : <br><br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">on</span> *.* <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;root&#x27;</span> @<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;itcast&#x27;</span>;<br>flush <span class="hljs-keyword">privileges</span>;<br><br></code></pre></td></tr></table></figure><h3 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h3><h4 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h4><p>MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下面的&#x3D;&#x3D;示意图&#x3D;&#x3D;所示 : </p><p><img src="/images/mysql/1555902055367.png" alt="1555902055367"> </p><p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。</p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。</p><h4 id="2-2-索引优势劣势"><a href="#2-2-索引优势劣势" class="headerlink" title="2.2 索引优势劣势"></a>2.2 索引优势劣势</h4><p>优势</p><p>1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。</p><p>2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</p><p>劣势</p><p>1） 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。</p><p>2） 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</p><h4 id="2-3-索引结构"><a href="#2-3-索引结构" class="headerlink" title="2.3 索引结构"></a>2.3 索引结构</h4><p>索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引：</p><ul><li>BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。</li><li>HASH 索引：只有Memory引擎支持 ， 使用场景简单 。</li><li>R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。</li><li>Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。</li></ul><center><b>MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</b></center><table><thead><tr><th>索引</th><th>InnoDB引擎</th><th>MyISAM引擎</th><th>Memory引擎</th></tr></thead><tbody><tr><td>BTREE索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>HASH 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><p>我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为 索引。</p><h5 id="2-3-1-BTREE-结构"><a href="#2-3-1-BTREE-结构" class="headerlink" title="2.3.1 BTREE 结构"></a>2.3.1 BTREE 结构</h5><p>BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下：</p><ul><li>树中每个节点最多包含m个孩子。</li><li>除根节点与叶子节点外，每个节点至少有[ceil(m&#x2F;2)]个孩子。</li><li>若根节点不是叶子节点，则至少有两个孩子。</li><li>所有的叶子节点都在同一层。</li><li>每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m&#x2F;2)-1] &lt;&#x3D; n &lt;&#x3D; m-1</li></ul><p>以5叉BTree为例，key的数量：公式推导[ceil(m&#x2F;2)-1] &lt;&#x3D; n &lt;&#x3D; m-1。所以 2 &lt;&#x3D; n &lt;&#x3D;4 。当n&gt;4时，中间节点分裂到父节点，两边节点分裂。</p><p>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。</p><p>演变过程如下：</p><p>1). 插入前4个字母 C N G A </p><p><img src="/images/mysql/1555944126588.png" alt="1555944126588"> </p><p>2). 插入H，n&gt;4，中间元素G字母向上分裂到新的节点</p><p><img src="/images/mysql/1555944549825.png" alt="1555944549825"> </p><p>3). 插入E，K，Q不需要分裂</p><p><img src="/images/mysql/1555944596893.png" alt="1555944596893"> </p><p>4). 插入M，中间元素M字母向上分裂到父节点G</p><p><img src="/images/mysql/1555944652560.png" alt="1555944652560"> </p><p>5). 插入F，W，L，T不需要分裂</p><p><img src="/images/mysql/1555944686928.png" alt="1555944686928"> </p><p>6). 插入Z，中间元素T向上分裂到父节点中 </p><p><img src="/images/mysql/1555944713486.png" alt="1555944713486"> </p><p>7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂</p><p><img src="/images/mysql/1555944749984.png" alt="1555944749984"> </p><p>8). 最后插入S，NPQR节点n&gt;5，中间节点Q向上分裂，但分裂后父节点DGMT的n&gt;5，中间节点M向上分裂</p><p><img src="/images/mysql/1555944848294.png" alt="1555944848294"> </p><p>到此，该BTREE树就已经构建完成了， BTREE树 和 二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快。</p><h5 id="2-3-3-B-TREE-结构"><a href="#2-3-3-B-TREE-结构" class="headerlink" title="2.3.3 B+TREE 结构"></a>2.3.3 B+TREE 结构</h5><p>B+Tree为BTree的变种，B+Tree与BTree的区别为：</p><p>1). n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。</p><p>2). B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。</p><p>3). 所有的非叶子节点都可以看作是key的索引部分。</p><p><img src="/images/mysql/00001.jpg" alt="1555906287178"> </p><p>由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定（查询效率相当）。</p><p>B+树的除叶子节点外的节点都不带有任何数据信息，只有索引信息，所有数据信息全部存储在叶子节点里，这样，整个树的每个节点所占的内存空间就变小了，读到内存中的索引信息就会更多一些，相当于减少了磁盘IO次数</p><h5 id="2-3-3-MySQL中的B-Tree"><a href="#2-3-3-MySQL中的B-Tree" class="headerlink" title="2.3.3 MySQL中的B+Tree"></a>2.3.3 MySQL中的B+Tree</h5><p>MySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</p><p>MySQL中的 B+Tree 索引结构示意图: </p><p><img src="/images/mysql/1555906287178.png" alt="1555906287178">  </p><h4 id="2-4-索引分类"><a href="#2-4-索引分类" class="headerlink" title="2.4 索引分类"></a>2.4 索引分类</h4><p>1） 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引</p><p>2） 唯一索引 ：索引列的值必须唯一，但允许有空值</p><p>3） 复合索引 ：即一个索引包含多个列</p><h4 id="2-5-索引语法"><a href="#2-5-索引语法" class="headerlink" title="2.5 索引语法"></a>2.5 索引语法</h4><p>索引在创建表的时候，可以同时创建， 也可以随时增加新的索引。</p><p>准备环境:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> database demo_01 <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8mb4;<br><br>use demo_01;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `city` (<br>  `city_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `city_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `country_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`city_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `country` (<br>  `country_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `country_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`country_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;西安&#x27;</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;NewYork&#x27;</span>,<span class="hljs-number">2</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;北京&#x27;</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;上海&#x27;</span>,<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `country` (`country_id`, `country_name`) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;China&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `country` (`country_id`, `country_name`) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;America&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `country` (`country_id`, `country_name`) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Japan&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `country` (`country_id`, `country_name`) <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;UK&#x27;</span>);<br></code></pre></td></tr></table></figure><h5 id="2-5-1-创建索引"><a href="#2-5-1-创建索引" class="headerlink" title="2.5.1 创建索引"></a>2.5.1 创建索引</h5><p>语法 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span><span class="hljs-operator">|</span>FULLTEXT<span class="hljs-operator">|</span>SPATIAL]  INDEX index_name <br>[<span class="hljs-keyword">USING</span>  index_type]<br><span class="hljs-keyword">ON</span> tbl_name(index_col_name,...)<br><br><br>index_col_name : column_name[(length)][<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>]<br></code></pre></td></tr></table></figure><p>示例 ： 为city表中的city_name字段创建索引 ；</p><p><img src="/images/mysql/1551438009843.png" alt="1551438009843">    ​  </p><p>​</p><h5 id="2-5-2-查看索引"><a href="#2-5-2-查看索引" class="headerlink" title="2.5.2 查看索引"></a>2.5.2 查看索引</h5><p>语法： </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">index</span>  <span class="hljs-keyword">from</span>  <span class="hljs-built_in">table_name</span>;<br></code></pre></td></tr></table></figure><p>示例：查看city表中的索引信息；</p><p><img src="/images/mysql/1551440511890.png" alt="1551440511890"> </p><p><img src="/images/mysql/1551440544483.png" alt="1551440544483">  </p><h5 id="2-5-3-删除索引"><a href="#2-5-3-删除索引" class="headerlink" title="2.5.3 删除索引"></a>2.5.3 删除索引</h5><p>语法 ：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DROP</span>  <span class="hljs-keyword">INDEX</span>  index_name  <span class="hljs-keyword">ON</span>  tbl_name;<br></code></pre></td></tr></table></figure><p>示例 ： 想要删除city表上的索引idx_city_name，可以操作如下：</p><p><img src="/images/mysql/1551438238293.png" alt="1551438238293">  </p><h5 id="2-5-4-ALTER命令"><a href="#2-5-4-ALTER命令" class="headerlink" title="2.5.4 ALTER命令"></a>2.5.4 ALTER命令</h5><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sas">1). <span class="hljs-keyword">alter</span>  <span class="hljs-keyword">table</span>  tb_name  <span class="hljs-keyword">add</span>  <span class="hljs-keyword">primary</span>  <span class="hljs-keyword">key</span>(column_list); <br><br>该语句添加一个主键，这意味着索引值必须是唯一的，且不能为<span class="hljs-keyword">NULL</span><br><br>2). <span class="hljs-keyword">alter</span>  <span class="hljs-keyword">table</span>  tb_name  <span class="hljs-keyword">add</span>  <span class="hljs-keyword">unique</span> index_name(column_list);<br><br>这条语句创建索引的值必须是唯一的（除了<span class="hljs-keyword">NULL</span>外，<span class="hljs-keyword">NULL</span>可能会出现多次）<br><br>3). <span class="hljs-keyword">alter</span>  <span class="hljs-keyword">table</span>  tb_name  <span class="hljs-keyword">add</span>  <span class="hljs-keyword">index</span> index_name(column_list);<br><br>添加普通索引， 索引值可以出现多次。<br><br>4). <span class="hljs-keyword">alter</span>  <span class="hljs-keyword">table</span>  tb_name  <span class="hljs-keyword">add</span>  fulltext  index_name(column_list);<br><br>该语句指定了索引为FULLTEXT， 用于全文索引<br><br></code></pre></td></tr></table></figure><h4 id="2-6-索引设计原则"><a href="#2-6-索引设计原则" class="headerlink" title="2.6 索引设计原则"></a>2.6 索引设计原则</h4><p>​索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。</p><ul><li><p>对查询频次较高，且数据量比较大的表建立索引。</p></li><li><p>索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。</p></li><li><p>使用唯一索引，区分度越高，使用索引的效率越高。</p></li><li><p>索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。</p></li><li><p>使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I&#x2F;O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I&#x2F;O效率。</p></li><li><p>利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran">创建复合索引:<br><br>CREATE <span class="hljs-built_in">INDEX</span> idx_name_email_status ON tb_seller(<span class="hljs-keyword">NAME</span>,email,<span class="hljs-keyword">STATUS</span>);<br><br>就相当于<br>对<span class="hljs-keyword">name</span> 创建索引 ;<br>对<span class="hljs-keyword">name</span> , email 创建了索引 ;<br>对<span class="hljs-keyword">name</span> , email, <span class="hljs-keyword">status</span> 创建了索引 ;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-视图"><a href="#3-视图" class="headerlink" title="3. 视图"></a>3. 视图</h3><h4 id="3-1-视图概述"><a href="#3-1-视图概述" class="headerlink" title="3.1 视图概述"></a>3.1 视图概述</h4><p>​视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><p>视图相对于普通的表的优势主要包括以下几项。</p><ul><li>简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。</li><li>安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。</li><li>数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。</li></ul><h4 id="3-2-创建或者修改视图"><a href="#3-2-创建或者修改视图" class="headerlink" title="3.2 创建或者修改视图"></a>3.2 创建或者修改视图</h4><p>创建视图的语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">OR</span> REPLACE] [ALGORITHM <span class="hljs-operator">=</span> &#123;UNDEFINED <span class="hljs-operator">|</span> <span class="hljs-keyword">MERGE</span> <span class="hljs-operator">|</span> TEMPTABLE&#125;]<br><br><span class="hljs-keyword">VIEW</span> view_name [(column_list)]<br><br><span class="hljs-keyword">AS</span> select_statement<br><br>[<span class="hljs-keyword">WITH</span> [<span class="hljs-keyword">CASCADED</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">LOCAL</span>] <span class="hljs-keyword">CHECK</span> OPTION]<br></code></pre></td></tr></table></figure><p>修改视图的语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> [ALGORITHM <span class="hljs-operator">=</span> &#123;UNDEFINED <span class="hljs-operator">|</span> <span class="hljs-keyword">MERGE</span> <span class="hljs-operator">|</span> TEMPTABLE&#125;]<br><br><span class="hljs-keyword">VIEW</span> view_name [(column_list)]<br><br><span class="hljs-keyword">AS</span> select_statement<br><br>[<span class="hljs-keyword">WITH</span> [<span class="hljs-keyword">CASCADED</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">LOCAL</span>] <span class="hljs-keyword">CHECK</span> OPTION]<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">选项 : <br><span class="hljs-keyword">WITH</span> [<span class="hljs-keyword">CASCADED</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">LOCAL</span>] <span class="hljs-keyword">CHECK</span> OPTION 决定了是否允许更新数据使记录不再满足视图的条件。<br><br><span class="hljs-keyword">LOCAL</span> ： 只要满足本视图的条件就可以更新。<br><span class="hljs-keyword">CASCADED</span> ： 必须满足所有针对该视图的所有视图的条件才可以更新。 默认值.<br></code></pre></td></tr></table></figure><p>示例 , 创建city_country_view视图 , 执行如下SQL : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> replace <span class="hljs-keyword">view</span> city_country_view <br><span class="hljs-keyword">as</span> <br><span class="hljs-keyword">select</span> t.<span class="hljs-operator">*</span>,c.country_name <span class="hljs-keyword">from</span> country c , city t <span class="hljs-keyword">where</span> c.country_id <span class="hljs-operator">=</span> t.country_id;<br><br></code></pre></td></tr></table></figure><p>查询视图 : </p><p><img src="/images/mysql/1551503428635.png" alt="1551503428635"> </p><h4 id="3-3-查看视图"><a href="#3-3-查看视图" class="headerlink" title="3.3 查看视图"></a>3.3 查看视图</h4><p>​从 MySQL 5.1 版本开始，使用 SHOW TABLES 命令的时候不仅显示表的名字，同时也会显示视图的名字，而不存在单独显示视图的 SHOW VIEWS 命令。</p><p><img src="/images/mysql/1551537565159.png" alt="1551537565159"> </p><p>同样，在使用 SHOW TABLE STATUS 命令的时候，不但可以显示表的信息，同时也可以显示视图的信息。</p><p><img src="/images/mysql/1551537646323.png" alt="1551537646323"> </p><p>如果需要查询某个视图的定义，可以使用 SHOW CREATE VIEW 命令进行查看 ： </p><p><img src="/images/mysql/1551588962944.png" alt="1551588962944">  </p><h4 id="3-4-删除视图"><a href="#3-4-删除视图" class="headerlink" title="3.4 删除视图"></a>3.4 删除视图</h4><p>语法 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> [IF <span class="hljs-keyword">EXISTS</span>] view_name [, view_name] ...[RESTRICT <span class="hljs-operator">|</span> CASCADE]<br></code></pre></td></tr></table></figure><p>示例 , 删除视图city_country_view :</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">DROP</span> <span class="hljs-built_in">VIEW</span> city_country_view ;<br></code></pre></td></tr></table></figure><h3 id="4-存储过程和函数"><a href="#4-存储过程和函数" class="headerlink" title="4. 存储过程和函数"></a>4. 存储过程和函数</h3><h4 id="4-1-存储过程和函数概述"><a href="#4-1-存储过程和函数概述" class="headerlink" title="4.1 存储过程和函数概述"></a>4.1 存储过程和函数概述</h4><p>​存储过程和函数是  事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p><p>​存储过程和函数的区别在于函数必须有返回值，而存储过程没有。</p><p>​函数 ： 是一个有返回值的过程 ；</p><p>​过程 ： 是一个没有返回值的函数 ；</p><h4 id="4-2-创建存储过程"><a href="#4-2-创建存储过程" class="headerlink" title="4.2 创建存储过程"></a>4.2 创建存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> procedure_name ([proc_parameter[,...]])<br><span class="hljs-keyword">begin</span><br><span class="hljs-comment">-- SQL语句</span><br><span class="hljs-keyword">end</span> ;<br></code></pre></td></tr></table></figure><p>示例 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test1()<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;Hello Mysql&#x27;</span> ;<br><span class="hljs-keyword">end</span>$<br><br>delimiter ;<br></code></pre></td></tr></table></figure><p><strong><font color="red">知识小贴士</font></strong></p><p>DELIMITER</p><p>​该关键字用来声明SQL语句的分隔符 , 告诉 MySQL 解释器，该段命令是否已经结束了，mysql是否可以执行了。默认情况下，delimiter是分号;。在命令行客户端中，如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。</p><h4 id="4-3-调用存储过程"><a href="#4-3-调用存储过程" class="headerlink" title="4.3 调用存储过程"></a>4.3 调用存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">call</span> procedure_name() ;<br></code></pre></td></tr></table></figure><h4 id="4-4-查看存储过程"><a href="#4-4-查看存储过程" class="headerlink" title="4.4 查看存储过程"></a>4.4 查看存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询db_name数据库中的所有的存储过程</span><br><span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> mysql.proc <span class="hljs-keyword">where</span> db<span class="hljs-operator">=</span><span class="hljs-string">&#x27;db_name&#x27;</span>;<br><br><br><span class="hljs-comment">-- 查询存储过程的状态信息</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">procedure</span> status;<br><br><br><span class="hljs-comment">-- 查询某个存储过程的定义</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> test.pro_test1 \G;<br></code></pre></td></tr></table></figure><h4 id="4-5-删除存储过程"><a href="#4-5-删除存储过程" class="headerlink" title="4.5 删除存储过程"></a>4.5 删除存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span>  [IF <span class="hljs-keyword">EXISTS</span>] sp_name ；<br></code></pre></td></tr></table></figure><h4 id="4-6-语法"><a href="#4-6-语法" class="headerlink" title="4.6 语法"></a>4.6 语法</h4><p>存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。</p><h5 id="4-6-1-变量"><a href="#4-6-1-变量" class="headerlink" title="4.6.1 变量"></a>4.6.1 变量</h5><ul><li>DECLARE</li></ul><p>  通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> var_name[,...] type [<span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">value</span>]<br></code></pre></td></tr></table></figure><p>示例 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test2() <br><span class="hljs-keyword">begin</span> <br><span class="hljs-keyword">declare</span> num <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">select</span> num<span class="hljs-operator">+</span> <span class="hljs-number">10</span>; <br><span class="hljs-keyword">end</span>$<br><br>delimiter ; <br></code></pre></td></tr></table></figure><ul><li>SET</li></ul><p>直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">SET var_name = <span class="hljs-built_in">expr</span> [, var_name = <span class="hljs-built_in">expr</span>] ...<br></code></pre></td></tr></table></figure><p>示例 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><br><span class="hljs-keyword">CREATE</span>  <span class="hljs-keyword">PROCEDURE</span> pro_test3()<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> NAME <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>);<br><span class="hljs-keyword">SET</span> NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;MYSQL&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> NAME ;<br><span class="hljs-keyword">END</span>$<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>也可以通过select … into 方式进行赋值操作 :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SQL">DELIMITER $<br><br><span class="hljs-keyword">CREATE</span>  <span class="hljs-keyword">PROCEDURE</span> pro_test5()<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">declare</span>  countnum <span class="hljs-type">int</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">into</span> countnum <span class="hljs-keyword">from</span> city;<br><span class="hljs-keyword">select</span> countnum;<br><span class="hljs-keyword">END</span>$<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><h5 id="4-6-2-if条件判断"><a href="#4-6-2-if条件判断" class="headerlink" title="4.6.2 if条件判断"></a>4.6.2 if条件判断</h5><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">if search_condition <span class="hljs-keyword">then</span> statement_list<br><br>[elseif search_condition <span class="hljs-keyword">then</span> statement_list] ...<br><br>[<span class="hljs-keyword">else</span> statement_list]<br><br><span class="hljs-keyword">end</span> if;<br></code></pre></td></tr></table></figure><p>需求： </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada">根据定义的身高变量，判定当前身高的所属的身材类型 <br><br><span class="hljs-number">180</span> 及以上 <span class="hljs-comment">----------&gt; 身材高挑</span><br><br><span class="hljs-number">170</span> - <span class="hljs-number">180</span>  <span class="hljs-comment">---------&gt; 标准身材</span><br><br><span class="hljs-number">170</span> 以下  <span class="hljs-comment">----------&gt; 一般身材</span><br></code></pre></td></tr></table></figure><p>示例 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test6()<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span>  height  <span class="hljs-type">int</span>  <span class="hljs-keyword">default</span>  <span class="hljs-number">175</span>; <br>  <span class="hljs-keyword">declare</span>  description  <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>);#<span class="hljs-keyword">desc</span>是<span class="hljs-keyword">SQL</span>关键字<br>  <br>  if  height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">180</span>  <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;身材高挑&#x27;</span>;<br>  elseif height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">170</span> <span class="hljs-keyword">and</span> height <span class="hljs-operator">&lt;</span> <span class="hljs-number">180</span>  <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;标准身材&#x27;</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">set</span> description <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;一般身材&#x27;</span>;#要和<span class="hljs-keyword">else</span>换行写，之前测试不换行一直能结束，输入结束符也不能结束<br>  <span class="hljs-keyword">end</span> if;<br>  <br>  <span class="hljs-keyword">select</span> description ;<br><span class="hljs-keyword">end</span>$<br><br>delimiter ;<br></code></pre></td></tr></table></figure><p>调用结果为 : </p><p><img src="/images/mysql/1552057035580.png" alt="1552057035580"> </p><h5 id="4-6-3-传递参数"><a href="#4-6-3-传递参数" class="headerlink" title="4.6.3 传递参数"></a>4.6.3 传递参数</h5><p>语法格式 : </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> <span class="hljs-title function_">procedure_name</span><span class="hljs-params">([<span class="hljs-keyword">in</span>/<span class="hljs-keyword">out</span>/inout] 参数名   参数类型)</span><br>...<br><br><br><span class="hljs-title function_">IN</span> :   该参数可以作为输入，也就是需要调用方传入值 , 默认<br><span class="hljs-keyword">OUT</span>:   该参数作为输出，也就是该参数可以作为返回值<br>INOUT: 既可以作为输入参数，也可以作为输出参数<br></code></pre></td></tr></table></figure><p><strong>IN - 输入</strong></p><p>需求 :</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">根据定义的身高变量，判定当前身高的所属的身材类型 <br></code></pre></td></tr></table></figure><p>示例  : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test5(<span class="hljs-keyword">in</span> height <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">declare</span> description <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>  if height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">180</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;身材高挑&#x27;</span>;<br>  elseif height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">170</span> <span class="hljs-keyword">and</span> height <span class="hljs-operator">&lt;</span> <span class="hljs-number">180</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;标准身材&#x27;</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;一般身材&#x27;</span>;<br>  <span class="hljs-keyword">end</span> if;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;身高 &#x27;</span>, height , <span class="hljs-string">&#x27;对应的身材类型为:&#x27;</span>,description);<br><span class="hljs-keyword">end</span>$<br><br>delimiter ;<br></code></pre></td></tr></table></figure><p><strong>OUT-输出</strong></p><p> 需求 :</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">根据传入的身高变量，获取当前身高的所属的身材类型  <br></code></pre></td></tr></table></figure><p>示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test5(<span class="hljs-keyword">in</span> height <span class="hljs-type">int</span> , <span class="hljs-keyword">out</span> description <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>))<br><span class="hljs-keyword">begin</span><br>  if height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">180</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;身材高挑&#x27;</span>;<br>  elseif height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">170</span> <span class="hljs-keyword">and</span> height <span class="hljs-operator">&lt;</span> <span class="hljs-number">180</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;标准身材&#x27;</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;一般身材&#x27;</span>;<br>  <span class="hljs-keyword">end</span> if;<br><span class="hljs-keyword">end</span>$<br></code></pre></td></tr></table></figure><p>调用:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">call</span> pro_test5(<span class="hljs-number">168</span>, <span class="hljs-symbol">@description</span>)$<br><br><span class="hljs-keyword">select</span> <span class="hljs-symbol">@description</span>$<br></code></pre></td></tr></table></figure><p><font color='red'><strong>小知识</strong> </font></p><p>@description :  这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。</p><p>@@global.sort_buffer_size : 这种在变量前加上 “@@” 符号, 叫做 系统变量 </p><h5 id="4-6-4-case结构"><a href="#4-6-4-case结构" class="headerlink" title="4.6.4 case结构"></a>4.6.4 case结构</h5><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs SQL">方式一 : <br><br><span class="hljs-keyword">CASE</span> case_value<br><br>  <span class="hljs-keyword">WHEN</span> when_value <span class="hljs-keyword">THEN</span> statement_list<br>  <br>  [<span class="hljs-keyword">WHEN</span> when_value <span class="hljs-keyword">THEN</span> statement_list] ...<br>  <br>  [<span class="hljs-keyword">ELSE</span> statement_list]<br>  <br><span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;<br><br><br>方式二 : <br><br><span class="hljs-keyword">CASE</span><br><br>  <span class="hljs-keyword">WHEN</span> search_condition <span class="hljs-keyword">THEN</span> statement_list<br>  <br>  [<span class="hljs-keyword">WHEN</span> search_condition <span class="hljs-keyword">THEN</span> statement_list] ...<br>  <br>  [<span class="hljs-keyword">ELSE</span> statement_list]<br>  <br><span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;<br><br></code></pre></td></tr></table></figure><p>需求:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">给定一个月份, 然后计算出所在的季度<br></code></pre></td></tr></table></figure><p>示例  :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test9(<span class="hljs-keyword">month</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span> <span class="hljs-keyword">result</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>);<br>  <span class="hljs-keyword">case</span> <br>    <span class="hljs-keyword">when</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&lt;=</span><span class="hljs-number">3</span> <span class="hljs-keyword">then</span> <br>      <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;第一季度&#x27;</span>;<br>    <span class="hljs-keyword">when</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">4</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&lt;=</span><span class="hljs-number">6</span> <span class="hljs-keyword">then</span> <br>      <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;第二季度&#x27;</span>;<br>    <span class="hljs-keyword">when</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">7</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&lt;=</span><span class="hljs-number">9</span> <span class="hljs-keyword">then</span> <br>      <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;第三季度&#x27;</span>;<br>    <span class="hljs-keyword">when</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&lt;=</span><span class="hljs-number">12</span> <span class="hljs-keyword">then</span> <br>      <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;第四季度&#x27;</span>;<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">case</span>;<br>  <br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;您输入的月份为 :&#x27;</span>, <span class="hljs-keyword">month</span> , <span class="hljs-string">&#x27; , 该月份为 : &#x27;</span> , <span class="hljs-keyword">result</span>) <span class="hljs-keyword">as</span> content ;<br>  <br><span class="hljs-keyword">end</span>$<br><br><br>delimiter ;<br></code></pre></td></tr></table></figure><h5 id="4-6-5-while循环"><a href="#4-6-5-while循环" class="headerlink" title="4.6.5 while循环"></a>4.6.5 while循环</h5><p>语法结构: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">while search_condition do<br><br>statement_list<br><br><span class="hljs-keyword">end</span> while;<br></code></pre></td></tr></table></figure><p>需求:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">计算从<span class="hljs-number">1</span>加到<span class="hljs-built_in">n</span>的值<br></code></pre></td></tr></table></figure><p>示例  : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test8(n <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span> total <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">declare</span> num <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>;<br>  while num<span class="hljs-operator">&lt;=</span>n do<br>    <span class="hljs-keyword">set</span> total <span class="hljs-operator">=</span> total <span class="hljs-operator">+</span> num;<br><span class="hljs-keyword">set</span> num <span class="hljs-operator">=</span> num <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">end</span> while;<br>  <span class="hljs-keyword">select</span> total;<br><span class="hljs-keyword">end</span>$<br><br>delimiter ;<br></code></pre></td></tr></table></figure><h5 id="4-6-6-repeat结构"><a href="#4-6-6-repeat结构" class="headerlink" title="4.6.6 repeat结构"></a>4.6.6 repeat结构</h5><p>有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是满足条件就退出循环。</p><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SQL">REPEAT<br><br>  statement_list<br><br>  UNTIL search_condition<br><br><span class="hljs-keyword">END</span> REPEAT;<br></code></pre></td></tr></table></figure><p>需求: </p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">计算从<span class="hljs-number">1</span>加到<span class="hljs-built_in">n</span>的值<br></code></pre></td></tr></table></figure><p>示例  : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test10(n <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span> total <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>  <br>  repeat <br>    <span class="hljs-keyword">set</span> total <span class="hljs-operator">=</span> total <span class="hljs-operator">+</span> n;<br>    <span class="hljs-keyword">set</span> n <span class="hljs-operator">=</span> n <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br>    until n<span class="hljs-operator">=</span><span class="hljs-number">0</span>  <br>  <span class="hljs-keyword">end</span> repeat;<br>  <br>  <span class="hljs-keyword">select</span> total ;<br>  <br><span class="hljs-keyword">end</span>$<br><br><br>delimiter ;<br></code></pre></td></tr></table></figure><h5 id="4-6-7-loop语句"><a href="#4-6-7-loop语句" class="headerlink" title="4.6.7 loop语句"></a>4.6.7 loop语句</h5><p>LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">[begin_label:] LOOP<br><br>  statement_list<br><br><span class="hljs-keyword">END</span> LOOP [end_label]<br></code></pre></td></tr></table></figure><p>如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环。</p><h5 id="4-6-8-leave语句"><a href="#4-6-8-leave语句" class="headerlink" title="4.6.8 leave语句"></a>4.6.8 leave语句</h5><p>用来从标注的流程构造中退出，通常和 BEGIN … END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs SQL">delimiter $<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> pro_test11(n <span class="hljs-type">int</span>)<br><span class="hljs-keyword">BEGIN</span><br>  <span class="hljs-keyword">declare</span> total <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>  <br>  ins: LOOP<br>    <br>    IF n <span class="hljs-operator">&lt;=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>      leave ins;<br>    <span class="hljs-keyword">END</span> IF;<br>    <br>    <span class="hljs-keyword">set</span> total <span class="hljs-operator">=</span> total <span class="hljs-operator">+</span> n;<br>    <span class="hljs-keyword">set</span> n <span class="hljs-operator">=</span> n <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br>  <br>  <span class="hljs-keyword">END</span> LOOP ins;<br>  <br>  <span class="hljs-keyword">select</span> total;<br><span class="hljs-keyword">END</span>$<br><br>delimiter ;<br></code></pre></td></tr></table></figure><h5 id="4-6-9-游标-x2F-光标"><a href="#4-6-9-游标-x2F-光标" class="headerlink" title="4.6.9 游标&#x2F;光标"></a>4.6.9 游标&#x2F;光标</h5><p>游标是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p><p>声明光标：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> cursor_name <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> select_statement ;<br></code></pre></td></tr></table></figure><p>OPEN 光标：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">OPEN</span> cursor_name ;<br></code></pre></td></tr></table></figure><p>FETCH 光标：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">FETCH</span> cursor_name <span class="hljs-keyword">INTO</span> var_name [, var_name] ...<br></code></pre></td></tr></table></figure><p>CLOSE 光标：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CLOSE</span> cursor_name ;<br></code></pre></td></tr></table></figure><p>示例 : </p><p>初始化脚本:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp(<br>  id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment ,<br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  age <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>  salary <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) comment <span class="hljs-string">&#x27;薪水&#x27;</span>,<br>  <span class="hljs-keyword">primary</span> key(`id`)<br>)engine<span class="hljs-operator">=</span>innodb <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8 ;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp(id,name,age,salary) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;金毛狮王&#x27;</span>,<span class="hljs-number">55</span>,<span class="hljs-number">3800</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;白眉鹰王&#x27;</span>,<span class="hljs-number">60</span>,<span class="hljs-number">4000</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;青翼蝠王&#x27;</span>,<span class="hljs-number">38</span>,<span class="hljs-number">2800</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;紫衫龙王&#x27;</span>,<span class="hljs-number">42</span>,<span class="hljs-number">1800</span>);<br><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-comment">-- 查询emp表中数据, 并逐行获取进行展示</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test11()<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span> e_id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">declare</span> e_name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>);<br>  <span class="hljs-keyword">declare</span> e_age <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">declare</span> e_salary <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">declare</span> emp_result <span class="hljs-keyword">cursor</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp;<br>  <br>  <span class="hljs-keyword">open</span> emp_result;<br>  <br>  <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> e_id,e_name,e_age,e_salary;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id=&#x27;</span>,e_id , <span class="hljs-string">&#x27;, name=&#x27;</span>,e_name, <span class="hljs-string">&#x27;, age=&#x27;</span>, e_age, <span class="hljs-string">&#x27;, 薪资为: &#x27;</span>,e_salary);<br>  <br>  <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> e_id,e_name,e_age,e_salary;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id=&#x27;</span>,e_id , <span class="hljs-string">&#x27;, name=&#x27;</span>,e_name, <span class="hljs-string">&#x27;, age=&#x27;</span>, e_age, <span class="hljs-string">&#x27;, 薪资为: &#x27;</span>,e_salary);<br>  <br>  <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> e_id,e_name,e_age,e_salary;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id=&#x27;</span>,e_id , <span class="hljs-string">&#x27;, name=&#x27;</span>,e_name, <span class="hljs-string">&#x27;, age=&#x27;</span>, e_age, <span class="hljs-string">&#x27;, 薪资为: &#x27;</span>,e_salary);<br>  <br>  <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> e_id,e_name,e_age,e_salary;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id=&#x27;</span>,e_id , <span class="hljs-string">&#x27;, name=&#x27;</span>,e_name, <span class="hljs-string">&#x27;, age=&#x27;</span>, e_age, <span class="hljs-string">&#x27;, 薪资为: &#x27;</span>,e_salary);<br>  <br>  <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> e_id,e_name,e_age,e_salary;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id=&#x27;</span>,e_id , <span class="hljs-string">&#x27;, name=&#x27;</span>,e_name, <span class="hljs-string">&#x27;, age=&#x27;</span>, e_age, <span class="hljs-string">&#x27;, 薪资为: &#x27;</span>,e_salary);<br>  <br>  <span class="hljs-keyword">close</span> emp_result;<br><span class="hljs-keyword">end</span>$<br><br></code></pre></td></tr></table></figure><p>通过循环结构 , 获取游标中的数据 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test12()<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">DECLARE</span> id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">DECLARE</span> name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>);<br>  <span class="hljs-keyword">DECLARE</span> age <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">DECLARE</span> salary <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">DECLARE</span> has_data <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>;<br>  <br>  <span class="hljs-keyword">DECLARE</span> emp_result <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp;<br>  <span class="hljs-keyword">DECLARE</span> EXIT HANDLER <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">NOT</span> FOUND <span class="hljs-keyword">set</span> has_data <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-keyword">open</span> emp_result;<br>  <br>  repeat<br>    <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> id , name , age , salary;<br>    <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id为&#x27;</span>,id, <span class="hljs-string">&#x27;, name 为&#x27;</span> ,name , <span class="hljs-string">&#x27;, age为 &#x27;</span> ,age , <span class="hljs-string">&#x27;, 薪水为: &#x27;</span>, salary);<br>    until has_data <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">end</span> repeat;<br>  <br>  <span class="hljs-keyword">close</span> emp_result;<br><span class="hljs-keyword">end</span>$<br><br>DELIMITER ; <br></code></pre></td></tr></table></figure><h4 id="4-7-存储函数"><a href="#4-7-存储函数" class="headerlink" title="4.7 存储函数"></a>4.7 存储函数</h4><p>语法结构:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> function_name([param <span class="hljs-built_in">type</span> ... ]) <br>RETURNS <span class="hljs-built_in">type</span> <br><span class="hljs-keyword">BEGIN</span><br>...<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p>案例 : </p><p>定义一个存储过程, 请求满足条件的总记录数 ;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><br>delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> count_city(countryId <span class="hljs-type">int</span>)<br><span class="hljs-keyword">returns</span> <span class="hljs-type">int</span><br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span> cnum <span class="hljs-type">int</span> ;<br>  <br>  <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">into</span> cnum <span class="hljs-keyword">from</span> city <span class="hljs-keyword">where</span> country_id <span class="hljs-operator">=</span> countryId;<br>  <br>  <span class="hljs-keyword">return</span> cnum;<br><span class="hljs-keyword">end</span>$<br><br>delimiter ;<br></code></pre></td></tr></table></figure><p>调用: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">select</span> <span class="hljs-title">count_city</span>(<span class="hljs-params"><span class="hljs-number">1</span></span>)</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">select</span> <span class="hljs-title">count_city</span>(<span class="hljs-params"><span class="hljs-number">2</span></span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="5-触发器"><a href="#5-触发器" class="headerlink" title="5. 触发器"></a>5. 触发器</h3><h4 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h4><p>触发器是与表有关的数据库对象，指在 insert&#x2F;update&#x2F;delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。</p><p>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><table><thead><tr><th>触发器类型</th><th>NEW 和 OLD的使用</th></tr></thead><tbody><tr><td>INSERT 型触发器</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE 型触发器</td><td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td></tr><tr><td>DELETE 型触发器</td><td>OLD 表示将要或者已经删除的数据</td></tr></tbody></table><h4 id="5-2-创建触发器"><a href="#5-2-创建触发器" class="headerlink" title="5.2 创建触发器"></a>5.2 创建触发器</h4><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> trigger_name <br><br>before<span class="hljs-operator">/</span>after <span class="hljs-keyword">insert</span><span class="hljs-operator">/</span><span class="hljs-keyword">update</span><span class="hljs-operator">/</span><span class="hljs-keyword">delete</span><br><br><span class="hljs-keyword">on</span> tbl_name <br><br>[ <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span> ]  <span class="hljs-comment">-- 行级触发器</span><br><br><span class="hljs-keyword">begin</span><br><br>trigger_stmt ;<br><br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><p>示例 </p><p>需求</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ;<br></code></pre></td></tr></table></figure><p>首先创建一张日志表 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp_logs(<br>  id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment,<br>  operation <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;操作类型, insert/update/delete&#x27;</span>,<br>  operate_time datetime <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;操作时间&#x27;</span>,<br>  operate_id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;操作表的ID&#x27;</span>,<br>  operate_params <span class="hljs-type">varchar</span>(<span class="hljs-number">500</span>) comment <span class="hljs-string">&#x27;操作参数&#x27;</span>,<br>  <span class="hljs-keyword">primary</span> key(`id`)<br>)engine<span class="hljs-operator">=</span>innodb <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p>创建 insert 型触发器，完成插入数据时的日志记录 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> emp_logs_insert_trigger<br>after <span class="hljs-keyword">insert</span> <br><span class="hljs-keyword">on</span> emp <br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span> <br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;insert&#x27;</span>,now(),new.id,concat(<span class="hljs-string">&#x27;插入后(id:&#x27;</span>,new.id,<span class="hljs-string">&#x27;, name:&#x27;</span>,new.name,<span class="hljs-string">&#x27;, age:&#x27;</span>,new.age,<span class="hljs-string">&#x27;, salary:&#x27;</span>,new.salary,<span class="hljs-string">&#x27;)&#x27;</span>));<br><span class="hljs-keyword">end</span> $<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>创建 update 型触发器，完成更新数据时的日志记录 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> emp_logs_update_trigger<br>after <span class="hljs-keyword">update</span> <br><span class="hljs-keyword">on</span> emp <br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span> <br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;update&#x27;</span>,now(),new.id,concat(<span class="hljs-string">&#x27;修改前(id:&#x27;</span>,old.id,<span class="hljs-string">&#x27;, name:&#x27;</span>,old.name,<span class="hljs-string">&#x27;, age:&#x27;</span>,old.age,<span class="hljs-string">&#x27;, salary:&#x27;</span>,old.salary,<span class="hljs-string">&#x27;) , 修改后(id&#x27;</span>,new.id, <span class="hljs-string">&#x27;name:&#x27;</span>,new.name,<span class="hljs-string">&#x27;, age:&#x27;</span>,new.age,<span class="hljs-string">&#x27;, salary:&#x27;</span>,new.salary,<span class="hljs-string">&#x27;)&#x27;</span>));                                                                      <br><span class="hljs-keyword">end</span> $<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>创建delete 行的触发器 , 完成删除数据时的日志记录 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> emp_logs_delete_trigger<br>after <span class="hljs-keyword">delete</span> <br><span class="hljs-keyword">on</span> emp <br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span> <br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;delete&#x27;</span>,now(),old.id,concat(<span class="hljs-string">&#x27;删除前(id:&#x27;</span>,old.id,<span class="hljs-string">&#x27;, name:&#x27;</span>,old.name,<span class="hljs-string">&#x27;, age:&#x27;</span>,old.age,<span class="hljs-string">&#x27;, salary:&#x27;</span>,old.salary,<span class="hljs-string">&#x27;)&#x27;</span>));                                                                      <br><span class="hljs-keyword">end</span> $<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp(id,name,age,salary) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;光明左使&#x27;</span>,<span class="hljs-number">30</span>,<span class="hljs-number">3500</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp(id,name,age,salary) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;光明右使&#x27;</span>,<span class="hljs-number">33</span>,<span class="hljs-number">3200</span>);<br><br><span class="hljs-keyword">update</span> emp <span class="hljs-keyword">set</span> age <span class="hljs-operator">=</span> <span class="hljs-number">39</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h4 id="5-3-删除触发器"><a href="#5-3-删除触发器" class="headerlink" title="5.3 删除触发器"></a>5.3 删除触发器</h4><p>语法结构 : </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">trigger</span> [<span class="hljs-built_in">schema_name</span>.]trigger_name<br></code></pre></td></tr></table></figure><p>如果没有指定 schema_name，默认为当前数据库 。</p><h4 id="5-4-查看触发器"><a href="#5-4-查看触发器" class="headerlink" title="5.4 查看触发器"></a>5.4 查看触发器</h4><p>可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。</p><p>语法结构 ： </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">show</span> triggers ；<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三十五、IoC 之自定义类型转换器</title>
    <link href="/2022/06/11/IoC%20%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%99%A8/"/>
    <url>/2022/06/11/IoC%20%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">IoC 之自定义类型转换器</font></div><p>ConversionService 是 Spring 类型转换器体系中的核心接口，它定义了是否可以完成转换（<code>canConvert(...)</code>） 与类型转换（<code>convert(...)</code>） 两类接口方法。</p><p>ConversionService 有三个子类，每个子类针对不同的类型转换：</p><ul><li>Converter&lt;S,T&gt;: 将 S 类型对象转为 T 类型对象。</li><li>GenericConverter: 会根据源类对象及目标类对象所在的宿主类中的上下文信息进行类型转换。</li><li>ConverterFactory: 将相同系列多个 “同质” Converter 封装在一起。如果希望将一种类型的对象转换为另一种类型及其子类的对象(例如将 String 转换为 Number 及 Number 子类(Integer、Long、Double 等)对象)可使用该转换器工厂类。</li></ul><h4 id="ConversionServiceFactoryBean"><a href="#ConversionServiceFactoryBean" class="headerlink" title="ConversionServiceFactoryBean"></a><code>ConversionServiceFactoryBean</code></h4><p>如何自定义类型转换器：</p><ol><li>实现 Converter &#x2F; GenericConverter &#x2F; ConverterFactory 接口</li><li>将该类注册到 ConversionServiceFactoryBean 中。</li></ol><p>ConversionServiceFactoryBean 实现了 InitializingBean 接口实现 <code>afterPropertiesSet()</code> 方法，之前分析了在 Bean 实例化 Bean 阶段，Spring 容器会检查当前 Bean 是否实现了 InitializingBean 接口，如果是则执行相应的初始化方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConversionServiceFactoryBean.java</span><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建 DefaultConversionService 对象</span><br>    <span class="hljs-built_in">this</span>.conversionService = createConversionService();<br>    <span class="hljs-comment">// 注册到 ConversionServiceFactory 中</span><br>    ConversionServiceFactory.registerConverters(<span class="hljs-built_in">this</span>.converters, <span class="hljs-built_in">this</span>.conversionService);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先调用 <code>createConversionService()</code> 方法，初始化 <code>conversionService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConversionServiceFactoryBean.java</span><br><br><span class="hljs-keyword">protected</span> GenericConversionService <span class="hljs-title function_">createConversionService</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConversionService</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后调用 <code>ConversionServiceFactory.registerConverters(Set converters, ConverterRegistry registry)</code> 方法，将定义的 <code>converters</code> 注入到类型转换体系中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConverterRegistry.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerConverters</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Set&lt;?&gt; converters, ConverterRegistry registry)</span> &#123;<br><span class="hljs-keyword">if</span> (converters != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 遍历 converters 数组，逐个注解</span><br><span class="hljs-keyword">for</span> (Object converter : converters) &#123;<br><span class="hljs-keyword">if</span> (converter <span class="hljs-keyword">instanceof</span> GenericConverter) &#123;<br>registry.addConverter((GenericConverter) converter);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (converter <span class="hljs-keyword">instanceof</span> Converter&lt;?, ?&gt;) &#123;<br>registry.addConverter((Converter&lt;?, ?&gt;) converter);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (converter <span class="hljs-keyword">instanceof</span> ConverterFactory&lt;?, ?&gt;) &#123;<br>registry.addConverterFactory((ConverterFactory&lt;?, ?&gt;) converter);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Each converter object must implement one of the &quot;</span> +<br><span class="hljs-string">&quot;Converter, ConverterFactory, or GenericConverter interfaces&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ConverterRegistry 是一个 Converter 注册器，他定义了一系列注册方法。</li><li>通过调用 ConverterRegistry 的 <code>addConverter(...)</code> 方法将转换器注册到容器中。所以在我们使用 Spring 容器的时候，Spring 将会自动识别出 IOC 容器中注册的 ConversionService 并且在 Bean 属性注入阶段使用自定义的转换器完成属性的转换了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三十二、IoC 之深入分析 PropertyPlaceholderConfigurer</title>
    <link href="/2022/06/11/IoC%20%E4%B9%8B%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20PropertyPlaceholderConfigurer/"/>
    <url>/2022/06/11/IoC%20%E4%B9%8B%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20PropertyPlaceholderConfigurer/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">IoC 之深入分析 PropertyPlaceholderConfigurer</font></div><p>BeanFactoryPostProcessor 作用：在容器启动阶段，可以对解析好的 BeanDefinition 进行定制化处理，而其中 <strong>PropertyPlaceholderConfigurer</strong> 是其一个非常重要的应用，也是其<strong>子类</strong>。</p><p><code>PropertyPlaceholderConfigurer</code> 允许我们用 Properties 文件中的属性，来定义应用上下文（配置文件或者注解），即：我们可以在 XML 配置文件（或者其他方式，如注解方式）中使用<strong>占位符</strong>的方式来定义一些资源，并将这些占位符所代表的资源配置到 Properties 中，这样只需要对 Properties 文件进行修改即可。</p><h4 id="PropertyPlaceholderConfigurer"><a href="#PropertyPlaceholderConfigurer" class="headerlink" title="PropertyPlaceholderConfigurer"></a><code>PropertyPlaceholderConfigurer</code></h4><p>该类间接实现了 Aware 和 BeanFactoryPostProcessor 两大扩展接口，之前介绍BeanFactoryPostProcessor，知道了BeanFactoryPostProcessor 提供了 <code>postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)</code> 接口方法，在这个体系中该方法的是在 <strong>PropertyResourceConfigurer</strong> 中实现，该类为属性资源的配置类，它实现了 BeanFactoryPostProcessor 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// &lt;1&gt; 返回合并的 Properties 实例</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">mergedProps</span> <span class="hljs-operator">=</span> mergeProperties();<br><br>        <span class="hljs-comment">// Convert the merged properties, if necessary.</span><br>        <span class="hljs-comment">// &lt;2&gt; 转换合并属性</span><br>        convertProperties(mergedProps);<br><br>        <span class="hljs-comment">// Let the subclass process the properties.</span><br>        <span class="hljs-comment">// &lt;3&gt; 让子类处理属性</span><br>        processProperties(beanFactory, mergedProps);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInitializationException</span>(<span class="hljs-string">&quot;Could not load properties&quot;</span>, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>&lt;1&gt;</code> 处，调用 <code>mergeProperties()</code> 方法，返回合并的 Properties 实例。Properties 实例维护着<strong>一组</strong> <code>key-value</code> ，其实就是 Properties 配置文件中的内容。</li><li><code>&lt;2&gt;</code> 处，调用 <code>convertProperties(Properties props)</code> 方法，转换合并的值，其实就是将原始值替换为真正的值。</li><li><code>&lt;3&gt;</code> 处，调用 <code>processProperties(ConfigurableListableBeanFactory beanFactory, Properties props)</code> 方法，前面两个步骤已经将配置文件中的值进行了处理，那么该方法就是真正的替换过程，该方法<strong>由子类实现</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PropertyResourceConfigurer.java</span><br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processProperties</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory, Properties props)</span> <span class="hljs-keyword">throws</span> BeansException;<br></code></pre></td></tr></table></figure><p><strong>注：</strong><code>PropertyPlaceholderConfigurer</code>继承了<code>PlaceholderConfigurerSupport</code>，<code>PlaceholderConfigurerSupport</code>继承了<code>PropertyResourceConfigurer</code>。</p><h4 id="PropertyPlaceholderConfigurer-1"><a href="#PropertyPlaceholderConfigurer-1" class="headerlink" title="PropertyPlaceholderConfigurer"></a><code>PropertyPlaceholderConfigurer</code></h4><p>在 PropertyPlaceholderConfigurer 中，重写 <code>processProperties(ConfigurableListableBeanFactory beanFactory, Properties props)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processProperties</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>    <span class="hljs-comment">// &lt;1&gt; 创建 StringValueResolver 对象，PlaceholderResolvingStringValueResolver是个内部类</span><br>    <span class="hljs-type">StringValueResolver</span> <span class="hljs-variable">valueResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PlaceholderResolvingStringValueResolver</span>(props);<br>    <span class="hljs-comment">// &lt;2&gt; 处理</span><br>    doProcessProperties(beanFactoryToProcess, valueResolver);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="PlaceholderResolvingStringValueResolver类"><a href="#PlaceholderResolvingStringValueResolver类" class="headerlink" title="PlaceholderResolvingStringValueResolver类"></a><code>PlaceholderResolvingStringValueResolver</code>类</h5><p>首先，构造一个 PlaceholderResolvingStringValueResolver 类型的 StringValueResolver 实例，该类是个内部类。StringValueResolver 为一个解析 String 类型值的策略接口，该接口提供了 <code>resolveStringValue(String strVal)</code> 方法，用于解析 String 值。PlaceholderResolvingStringValueResolver 为其一个解析策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PropertyPlaceholderConfigurer.java</span><br>    <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PlaceholderResolvingStringValueResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StringValueResolver</span> &#123;<br>    <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PropertyPlaceholderHelper helper;<br>    <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PlaceholderResolver resolver;<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">PlaceholderResolvingStringValueResolver</span><span class="hljs-params">(Properties props)</span> &#123;<br><span class="hljs-built_in">this</span>.helper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyPlaceholderHelper</span>(<br>placeholderPrefix, placeholderSuffix, valueSeparator, ignoreUnresolvablePlaceholders);<br><span class="hljs-built_in">this</span>.resolver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyPlaceholderConfigurerResolver</span>(props);<br>&#125;<br><br><span class="hljs-comment">// ... 省略 resolveStringValue 方法</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在构造 String 值解析器 StringValueResolver 时，将已经解析的 Properties 实例对象封装在 PlaceholderResolver 实例 <code>resolver</code> 中。PlaceholderResolver 是一个用于解析字符串中包含占位符的替换值的策略接口，该接口有一个 <code>resolvePlaceholder(String strVa)</code> 方法，用于返回占位符的替换值。</li><li>还有一个 PropertyPlaceholderHelper 工具 <code>helper</code> ，从名字上面看应该是进行替换的工具类。</li></ul><h5 id="doProcessProperties-方法"><a href="#doProcessProperties-方法" class="headerlink" title="doProcessProperties()方法"></a><code>doProcessProperties()</code>方法</h5><p>得到 String 解析器的实例 <code>valueResolver</code> 后，则会调用 <code>doProcessProperties(ConfigurableListableBeanFactory beanFactoryToProcess, StringValueResolver valueResolver)</code> 方法，来进行真值的替换操作。该方法在父类 PlaceholderConfigurerSupport 中实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PlaceholderConfigurerSupport.java</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doProcessProperties</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactoryToProcess,</span><br><span class="hljs-params">                                   StringValueResolver valueResolver)</span> &#123;<br><br>    <span class="hljs-comment">// &lt;1&gt; 创建 BeanDefinitionVisitor 对象</span><br>    <span class="hljs-type">BeanDefinitionVisitor</span> <span class="hljs-variable">visitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionVisitor</span>(valueResolver);<br><br>    <span class="hljs-comment">// &lt;2&gt; 得到该容器的所有 BeanName</span><br>    String[] beanNames = beanFactoryToProcess.getBeanDefinitionNames();<br>    <span class="hljs-keyword">for</span> (String curName : beanNames) &#123;<br>        <span class="hljs-comment">// 校验</span><br>        <span class="hljs-comment">//检查我们是否没有解析我们自己的bean定义，以避免在属性文件位置中无法解析的占位符失败。</span><br>        <span class="hljs-keyword">if</span> (!(curName.equals(<span class="hljs-built_in">this</span>.beanName)<span class="hljs-comment">// 1. 当前实例 PlaceholderConfigurerSupport 不在解析范围内</span><br>              &amp;&amp; beanFactoryToProcess.equals(<span class="hljs-built_in">this</span>.beanFactory))) &#123;<span class="hljs-comment">// 2. 同一个 Spring 容器</span><br>            <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> beanFactoryToProcess.getBeanDefinition(curName);<br>            <span class="hljs-keyword">try</span> &#123;<br>                visitor.visitBeanDefinition(bd);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(bd.getResourceDescription(), curName, ex.getMessage(), ex);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;3&gt; Spring 2.5的新功能：解析别名目标名称和别名中的占位符。</span><br>    beanFactoryToProcess.resolveAliases(valueResolver);<br><br>    <span class="hljs-comment">// &lt;4&gt; Spring 3.0的新功能：解决嵌入值（例如注释属性）中的占位符。</span><br>    beanFactoryToProcess.addEmbeddedValueResolver(valueResolver);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>&lt;1&gt; 处，根据 String 值解析策略 <code>valueResolver</code> 得到 BeanDefinitionVisitor 实例。BeanDefinitionVisitor 是 BeanDefinition 的访问者，我们通过它可以实现对 BeanDefinition 内容的进行访问，内容很多，例如 Scope、PropertyValues、FactoryMethodName 等等。</li><li>&lt;2&gt; 处，得到该容器的所有 BeanName，然后对其进行访问（ <code>visitBeanDefinition(BeanDefinition beanDefinition)</code> 方法）。</li><li>&lt;3&gt; 处，解析别名的占位符。</li><li>&lt;4&gt; 处，解析嵌入值的占位符，例如注释属性。</li></ul><h6 id="visitBeanDefinition-方法"><a href="#visitBeanDefinition-方法" class="headerlink" title="visitBeanDefinition()方法"></a><code>visitBeanDefinition()</code>方法</h6><p><code>doProcessProperties()</code>的<strong>核心</strong>在于 <code>visitBeanDefinition(BeanDefinition beanDefinition)</code> 方法的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//BeanDefinitionVisitor.java</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *遍历给定的BeanDefinition对象以及其中包含的MutablePropertyValues和ConstructorArgumentValues。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitBeanDefinition</span><span class="hljs-params">(BeanDefinition beanDefinition)</span> &#123;<br>    visitParentName(beanDefinition);<br>    visitBeanClassName(beanDefinition);<br>    visitFactoryBeanName(beanDefinition);<br>    visitFactoryMethodName(beanDefinition);<br>    visitScope(beanDefinition);<br>    <span class="hljs-keyword">if</span> (beanDefinition.hasPropertyValues()) &#123;<br>        <span class="hljs-comment">//本篇重点</span><br>        visitPropertyValues(beanDefinition.getPropertyValues());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (beanDefinition.hasConstructorArgumentValues()) &#123;<br>        <span class="hljs-type">ConstructorArgumentValues</span> <span class="hljs-variable">cas</span> <span class="hljs-operator">=</span> beanDefinition.getConstructorArgumentValues();<br>        visitIndexedArgumentValues(cas.getIndexedArgumentValues());<br>        visitGenericArgumentValues(cas.getGenericArgumentValues());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法基本访问了 BeanDefinition 中所有比较有用的东西了，包括 parent 、class 、factory-bean 、factory-method 、scope 、property 、constructor-arg 。</p><h6 id="visitPropertyValues-方法"><a href="#visitPropertyValues-方法" class="headerlink" title="visitPropertyValues()方法"></a><code>visitPropertyValues()</code>方法</h6><p>因为该篇主要内容是<code>property</code>，所以重点只看<code>visitPropertyValues()</code>方法。</p><p>过程就是对属性数组进行遍历，调用 <code>resolveValue(Object value)</code>方法，对属性进行解析获取最新值，如果新值和旧值不等，则用新值替换旧值。：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//BeanDefinitionVisitor.java</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitPropertyValues</span><span class="hljs-params">(MutablePropertyValues pvs)</span> &#123;<br>    PropertyValue[] pvArray = pvs.getPropertyValues();<br>    <span class="hljs-comment">// 遍历 PropertyValue 数组</span><br>    <span class="hljs-keyword">for</span> (PropertyValue pv : pvArray) &#123;<br>        <span class="hljs-comment">// 解析真值</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">newVal</span> <span class="hljs-operator">=</span> resolveValue(pv.getValue());<br>        <span class="hljs-keyword">if</span> (!ObjectUtils.nullSafeEquals(newVal, pv.getValue())) &#123;<br>            <span class="hljs-comment">// 设置到 PropertyValue 中</span><br>            pvs.add(pv.getName(), newVal);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>resolveValue()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//BeanDefinitionVisitor.java</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">resolveValue</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object value)</span> &#123;<br>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> BeanDefinition) &#123;<br>        visitBeanDefinition((BeanDefinition) value);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> BeanDefinitionHolder) &#123;<br>        visitBeanDefinition(((BeanDefinitionHolder) value).getBeanDefinition());<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> RuntimeBeanReference) &#123;<br>        <span class="hljs-type">RuntimeBeanReference</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> (RuntimeBeanReference) value;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">newBeanName</span> <span class="hljs-operator">=</span> resolveStringValue(ref.getBeanName());<br>        <span class="hljs-keyword">if</span> (newBeanName == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!newBeanName.equals(ref.getBeanName())) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeBeanReference</span>(newBeanName);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> RuntimeBeanNameReference) &#123;<br>        <span class="hljs-type">RuntimeBeanNameReference</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> (RuntimeBeanNameReference) value;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">newBeanName</span> <span class="hljs-operator">=</span> resolveStringValue(ref.getBeanName());<br>        <span class="hljs-keyword">if</span> (newBeanName == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!newBeanName.equals(ref.getBeanName())) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeBeanNameReference</span>(newBeanName);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Object[]) &#123;<br>        visitArray((Object[]) value);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> List) &#123;<br>        visitList((List) value);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Set) &#123;<br>        visitSet((Set) value);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Map) &#123;<br>        visitMap((Map) value);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> TypedStringValue) &#123;<br>        <span class="hljs-type">TypedStringValue</span> <span class="hljs-variable">typedStringValue</span> <span class="hljs-operator">=</span> (TypedStringValue) value;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">stringValue</span> <span class="hljs-operator">=</span> typedStringValue.getValue();<br>        <span class="hljs-keyword">if</span> (stringValue != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">visitedString</span> <span class="hljs-operator">=</span> resolveStringValue(stringValue);<br>            typedStringValue.setValue(visitedString);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 由于 Properties 中的是 String，所以重点在此处</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> String) &#123;<br>        <span class="hljs-keyword">return</span> resolveStringValue((String) value);<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>resolveStringValue()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 解决给定的String值，例如解析占位符。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> String <span class="hljs-title function_">resolveStringValue</span><span class="hljs-params">(String strVal)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.valueResolver == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No StringValueResolver specified - pass a resolver object into the constructor or override the &#x27;resolveStringValue&#x27; method&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 解析真值</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resolvedValue</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.valueResolver.resolveStringValue(strVal);<br>    <span class="hljs-comment">// Return original String if not modified.</span><br>    <span class="hljs-keyword">return</span> (strVal.equals(resolvedValue) ? strVal : resolvedValue);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>valueResolver</code> 是我们在构造 BeanDefinitionVisitor 实例时传入的 String 类型解析器 PlaceholderResolvingStringValueResolver，调用其 <code>resolveStringValue(String strVal)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PropertyPlaceholderConfigurer.java</span><br><span class="hljs-comment">// 内部类 PlaceholderResolvingStringValueResolver.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">PlaceholderResolvingStringValueResolver</span><span class="hljs-params">(Properties props)</span> &#123;<br>    <span class="hljs-built_in">this</span>.helper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyPlaceholderHelper</span>(placeholderPrefix, placeholderSuffix, valueSeparator, ignoreUnresolvablePlaceholders);<br>    <span class="hljs-built_in">this</span>.resolver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyPlaceholderConfigurerResolver</span>(props);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">resolveStringValue</span><span class="hljs-params">(String strVal)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-comment">// 解析真值</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resolved</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.helper.replacePlaceholders(strVal, <span class="hljs-built_in">this</span>.resolver);<br>    <span class="hljs-keyword">if</span> (trimValues) &#123;<br>        resolved = resolved.trim();<br>    &#125;<br>    <span class="hljs-comment">// 返回真值</span><br>    <span class="hljs-keyword">return</span> (resolved.equals(nullValue) ? <span class="hljs-literal">null</span> : resolved);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>helper</code> 为 PropertyPlaceholderHelper 实例对象，而 PropertyPlaceholderHelper 则是处理应用程序中包含占位符的字符串工具类。在构造 <code>helper</code> 实例对象时需要传入了几个参数：<code>placeholderPrefix</code>、<code>placeholderSuffix</code>、<code>valueSeparator</code>，这些值在 PlaceholderConfigurerSupport 中定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PlaceholderConfigurerSupport.java</span><br><br><span class="hljs-comment">/** Default placeholder prefix: &#123;<span class="hljs-doctag">@value</span>&#125;. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_PLACEHOLDER_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;$&#123;&quot;</span>;<br><span class="hljs-comment">/** Default placeholder suffix: &#123;<span class="hljs-doctag">@value</span>&#125;. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_PLACEHOLDER_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#125;&quot;</span>;<br><span class="hljs-comment">/** Default value separator: &#123;<span class="hljs-doctag">@value</span>&#125;. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_VALUE_SEPARATOR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;:&quot;</span>;<br><br><span class="hljs-comment">/** Defaults to &#123;<span class="hljs-doctag">@value</span> #DEFAULT_PLACEHOLDER_PREFIX&#125;. */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">String</span> <span class="hljs-variable">placeholderPrefix</span> <span class="hljs-operator">=</span> DEFAULT_PLACEHOLDER_PREFIX;<br><span class="hljs-comment">/** Defaults to &#123;<span class="hljs-doctag">@value</span> #DEFAULT_PLACEHOLDER_SUFFIX&#125;. */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">String</span> <span class="hljs-variable">placeholderSuffix</span> <span class="hljs-operator">=</span> DEFAULT_PLACEHOLDER_SUFFIX;<br><span class="hljs-comment">/** Defaults to &#123;<span class="hljs-doctag">@value</span> #DEFAULT_VALUE_SEPARATOR&#125;. */</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">String</span> <span class="hljs-variable">valueSeparator</span> <span class="hljs-operator">=</span> DEFAULT_VALUE_SEPARATOR;<br></code></pre></td></tr></table></figure><p><code>replacePlaceholders()</code>方法</p><p>调用 PropertyPlaceholderHelper 的 <code>replacePlaceholders(String value, PlaceholderResolver placeholderResolver)</code> 方法，进行占位符替换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PropertyPlaceholderHelper.java</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">replacePlaceholders</span><span class="hljs-params">(String value, PlaceholderResolver placeholderResolver)</span> &#123;<br>    Assert.notNull(value, <span class="hljs-string">&quot;&#x27;value&#x27; must not be null&quot;</span>);<br>    <span class="hljs-keyword">return</span> parseStringValue(value, placeholderResolver, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 <code>parseStringValue(String value, PlaceholderResolver placeholderResolver, Set visitedPlaceholders)</code> 方法，<strong>该方法是本篇最核心的地方</strong>，<code>$&#123;&#125;</code> 占位符的替换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> String <span class="hljs-title function_">parseStringValue</span><span class="hljs-params">(String value, PlaceholderResolver placeholderResolver, <span class="hljs-meta">@Nullable</span> Set&lt;String&gt; visitedPlaceholders)</span> &#123;<br><br>    <span class="hljs-comment">// 获取前缀 &quot;$&#123;&quot; 的索引位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">startIndex</span> <span class="hljs-operator">=</span> value.indexOf(<span class="hljs-built_in">this</span>.placeholderPrefix);<br>    <span class="hljs-keyword">if</span> (startIndex == -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(value);<br>    <span class="hljs-keyword">while</span> (startIndex != -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 获取 后缀 &quot;&#125;&quot; 的索引位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">endIndex</span> <span class="hljs-operator">=</span> findPlaceholderEndIndex(result, startIndex);<br>        <span class="hljs-keyword">if</span> (endIndex != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 截取 &quot;$&#123;&quot; 和 &quot;&#125;&quot; 中间的内容，这也就是我们在配置文件中对应的值</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">placeholder</span> <span class="hljs-operator">=</span> result.substring(startIndex + <span class="hljs-built_in">this</span>.placeholderPrefix.length(), endIndex);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">originalPlaceholder</span> <span class="hljs-operator">=</span> placeholder;<br>            <span class="hljs-keyword">if</span> (visitedPlaceholders == <span class="hljs-literal">null</span>) &#123;<br>                visitedPlaceholders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(<span class="hljs-number">4</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!visitedPlaceholders.add(originalPlaceholder)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>                    <span class="hljs-string">&quot;Circular placeholder reference &#x27;&quot;</span> + originalPlaceholder + <span class="hljs-string">&quot;&#x27; in property definitions&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 解析占位符键中包含的占位符，真正的值</span><br>            placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders);<br>            <span class="hljs-comment">// 从 Properties 中获取 placeHolder 对应的值 propVal</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">propVal</span> <span class="hljs-operator">=</span> placeholderResolver.resolvePlaceholder(placeholder);<br>            <span class="hljs-comment">// 如果不存在</span><br>            <span class="hljs-keyword">if</span> (propVal == <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">this</span>.valueSeparator != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 查询 : 的位置</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">separatorIndex</span> <span class="hljs-operator">=</span> placeholder.indexOf(<span class="hljs-built_in">this</span>.valueSeparator);<br>                <span class="hljs-comment">// 如果存在 :</span><br>                <span class="hljs-keyword">if</span> (separatorIndex != -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-comment">// 获取 : 前面部分 actualPlaceholder</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">actualPlaceholder</span> <span class="hljs-operator">=</span> placeholder.substring(<span class="hljs-number">0</span>, separatorIndex);<br>                    <span class="hljs-comment">// 获取 : 后面部分 defaultValue</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">defaultValue</span> <span class="hljs-operator">=</span> placeholder.substring(separatorIndex + <span class="hljs-built_in">this</span>.valueSeparator.length());<br>                    <span class="hljs-comment">// 从 Properties 中获取 actualPlaceholder 对应的值</span><br>                    propVal = placeholderResolver.resolvePlaceholder(actualPlaceholder);<br>                    <span class="hljs-comment">// 如果不存在 则返回 defaultValue</span><br>                    <span class="hljs-keyword">if</span> (propVal == <span class="hljs-literal">null</span>) &#123;<br>                        propVal = defaultValue;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (propVal != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 递归调用，解析先前解析的占位符值中包含的占位符。</span><br>                propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders);<br>                result.replace(startIndex, endIndex + <span class="hljs-built_in">this</span>.placeholderSuffix.length(), propVal);<br>                <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                    logger.trace(<span class="hljs-string">&quot;Resolved placeholder &#x27;&quot;</span> + placeholder + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                &#125;<br>                startIndex = result.indexOf(<span class="hljs-built_in">this</span>.placeholderPrefix, startIndex + propVal.length());<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.ignoreUnresolvablePlaceholders) &#123;<br>                <span class="hljs-comment">// 忽略值</span><br>                startIndex = result.indexOf(<span class="hljs-built_in">this</span>.placeholderPrefix, endIndex + <span class="hljs-built_in">this</span>.placeholderSuffix.length());<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Could not resolve placeholder &#x27;&quot;</span> +<br>                                                   placeholder + <span class="hljs-string">&quot;&#x27;&quot;</span> + <span class="hljs-string">&quot; in value \&quot;&quot;</span> + value + <span class="hljs-string">&quot;\&quot;&quot;</span>);<br>            &#125;<br>            visitedPlaceholders.remove(originalPlaceholder);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            startIndex = -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 返回propVal，就是替换之后的值</span><br>    <span class="hljs-keyword">return</span> result.toString();<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>获取占位符前缀 <code>&quot;$&#123;&quot;</code> 的索引位置 <code>startIndex</code> 。</li><li>如果前缀 <code>&quot;$&#123;&quot;</code> 存在，则从 <code>“&#123;”</code> 后面开始获取占位符后缀 “}” 的索引位置 <code>endIndex</code> 。</li><li>如果前缀 <code>“$&#123;”</code> 和后缀 <code>&quot;&#125;&quot;</code> 都存在，则截取中间部分 <code>placeholder</code> 。</li><li>从 Properties 中获取 <code>placeHolder</code> 对应的值 <code>propVal</code> 。</li><li>如果 <code>propVal</code> 为空，则判断占位符中是否存在 <code>&quot;:&quot;</code>，如果存在则对占位符进行分割处理，前面部分为 <code>actualPlaceholder</code>，后面部分 <code>defaultValue</code>，尝试从 Properties 中获取 <code>actualPlaceholder</code> 对应的值 <code>propVal</code>，如果不存在，则将 <code>defaultValue</code> 的值赋值给 <code>propVal</code></li><li>返回 <code>propVal</code>，也就是 Properties 中对应的值。</li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mongodb安装</title>
    <link href="/2022/06/11/MongodbInstall/"/>
    <url>/2022/06/11/MongodbInstall/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">mongodb安装配置</font></div><h4 id="mongodb的安装"><a href="#mongodb的安装" class="headerlink" title="mongodb的安装"></a>mongodb的安装</h4><h5 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h5><p><img src="/images/mongodb/mongodbdownload.png" alt="Resource"></p><p>随意找个目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-5.0.2.tgz<br>tar -xzvf mongodb-linux-x86_64-rhel70-5.0.2.tgz<br>mv mongodb-linux-x86_64-rhel70-5.0.2.tgz /usr/local/mongodb5 #可不移动<br></code></pre></td></tr></table></figure><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">进入编辑页面</span><br>sudo vim /etc/profile<br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加如下内容</span><br>MONGODB_HOME=/usr/local/mongodb5   #自己上步的安装目录<br>PATH=$PATH:MONGODB_HOME/bin  #如果已有java之类的PATH，可接着后边添加，以:分割<br>export PATH MONGODB_HOME  #保存退出<br><span class="hljs-meta prompt_">#</span><span class="language-bash">重新加载</span><br>sudo source /etc/profile<br></code></pre></td></tr></table></figure><h5 id="创建数据库目录和日志目录"><a href="#创建数据库目录和日志目录" class="headerlink" title="创建数据库目录和日志目录"></a>创建数据库目录和日志目录</h5><p>默认情况下 MongoDB 启动后会初始化以下两个目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/var/lib/mongodb     /var/log/mongodb<br></code></pre></td></tr></table></figure><p>也可自己随意指定，但是启动的时候要指向自己的目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir -p /var/lib/mongodb5<br>sudo mkdir -p /var/log/mongodb5<br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置操作权限，也可<span class="hljs-built_in">chown</span>设置用户的权限</span><br>sudo chmod -ax /var/lib/mongodb5<br>sudo chmod -ax /var/log/mongodb5<br></code></pre></td></tr></table></figure><p>添加启动配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /usr/local/mongodb5/bin/mongodb.conf<br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加如下内容</span><br>bind_ip=0.0.0.0<br>dbpath=/var/lib/mongodb<br>logpath=/var/log/mongodb/mongod.log<br>fork=true<br>logappend=true<br></code></pre></td></tr></table></figure><p>注：如果远程连接，记得放开启动端口27017（默认端口，可配置文件指定端口号）或者关闭防火墙。</p><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/mongodb5/bin<br>mongod -f mongodb.conf<br></code></pre></td></tr></table></figure><p>假如一直报创建子进程(child…)类的错</p><p><img src="/images/mongodb/startfail.png" alt="Resource"></p><ol><li><p>要么已经启动了一个mongodb</p></li><li><p>因为某些原因被锁了（删掉&#x2F;var&#x2F;lib&#x2F;mongodb5和&#x2F;var&#x2F;log&#x2F;mongodb5中后缀为.sock文件）</p></li><li><p>当前用户没有执行权限，切到有执行权限的用户</p></li></ol><p>启动成功，配置的日志文件里会有如下内容（版本不一样，可能显示不一样，但主要内容一样）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;&quot;t&quot;:&#123;&quot;$date&quot;:&quot;2021-08-09T21:26:30.601+08:00&quot;&#125;,&quot;s&quot;:&quot;I&quot;,  &quot;c&quot;:&quot;NETWORK&quot;,  &quot;id&quot;:23015,   &quot;ctx&quot;:&quot;listener&quot;,&quot;msg&quot;:&quot;Listening on&quot;,&quot;attr&quot;:&#123;&quot;address&quot;:&quot;/tmp/mongodb-27017.sock&quot;&#125;&#125;<br>&#123;&quot;t&quot;:&#123;&quot;$date&quot;:&quot;2021-08-09T21:26:30.601+08:00&quot;&#125;,&quot;s&quot;:&quot;I&quot;,  &quot;c&quot;:&quot;NETWORK&quot;,  &quot;id&quot;:23015,   &quot;ctx&quot;:&quot;listener&quot;,&quot;msg&quot;:&quot;Listening on&quot;,&quot;attr&quot;:&#123;&quot;address&quot;:&quot;0.0.0.0&quot;&#125;&#125;<br>&#123;&quot;t&quot;:&#123;&quot;$date&quot;:&quot;2021-08-09T21:26:30.601+08:00&quot;&#125;,&quot;s&quot;:&quot;I&quot;,  &quot;c&quot;:&quot;NETWORK&quot;,  &quot;id&quot;:23016,   &quot;ctx&quot;:&quot;listener&quot;,&quot;msg&quot;:&quot;Waiting for connections&quot;,&quot;attr&quot;:&#123;&quot;port&quot;:27017,&quot;ssl&quot;:&quot;off&quot;&#125;&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/mongodb/startsuccess.png" alt="Resource"></p><h5 id="启动成功可进入后台管理"><a href="#启动成功可进入后台管理" class="headerlink" title="启动成功可进入后台管理"></a>启动成功可进入后台管理</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/mongodb5/bin<br><span class="hljs-meta prompt_">#</span><span class="language-bash">启动后台管理</span><br>./mongo<br><span class="hljs-meta prompt_">#</span><span class="language-bash">会打印一段话，出现 &gt; ，即可操作</span><br>...<br><span class="hljs-meta prompt_">&gt;</span><br></code></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li><p>用navicat进行身份验证连接出现cannot connect to Mongodb authentication failed</p><p>第一次安装mongodb，是不需要密码，也没有用户的。所以需要创建用户再连接。</p><p>#第一次用，具体的还不是很清楚，先创建使用，role有各种对应的权限，自行google百度。</p><p><img src="/images/mongodb/createUser.png" alt="Resource"></p></li><li><p>用navicat进行身份验证 serverselectiontimeouttms 异常</p><p>极大概率端口，防火墙问题，需要确认端口号是否放开或者防火墙是否关闭，还有配置文件是否正确。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>mongodb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mongodb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS</title>
    <link href="/2022/06/11/JUC%E4%B9%8BAQS%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/06/11/JUC%E4%B9%8BAQS%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">AQS简介</font></div><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>AQS，AbstractQueudSynchronizer，即队列同步器。</p><hr><blockquote><table><tr><td bgcolor="#6495ED"><font color="#FFF">可一并参考<strong>ReentrantLock</strong>，其内部底层是：定义一个内部类<strong>Sync</strong>（<u>继承了AQS</u>），公平锁<strong>FairSync</strong>和非公平锁<strong>NonfairSync</strong>又继承了<strong>Sync</strong>。</font></td></tr></table></blockquote><hr><p><img src="/images/JUC/AQS/AQS%E6%9E%B6%E6%9E%84.png" alt="AQS架构"></p><ul><li>上图中有颜色的为Method，无颜色的为Attribution。</li><li>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</li><li>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>AQS使用一个<kbd>int</kbd>类型的成员变量<code>state</code>来表示同步状态，当<kbd>state>0</kbd>时表示已经获取了锁，当<kbd>state = 0</kbd>时表示释放了锁。它提供了三个方法（getState()、setState(int newState)、compareAndSetState(int expect,int update)）来对同步状态state进行操作，当然AQS可以确保对state的<em><strong>操作是安全</strong></em>的。 AQS通过<em><strong>内置的FIFO同步队列</strong></em>来完成资源获取线程的排队工作，如果当前线程获取同步状态失败（锁）时，AQS则会将<em><strong>当前线程以及等待状态等信息构造成一个节点（Node）</strong></em>并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。</p><p>AQS内部变量都被<code>volatile</code>修饰了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br></code></pre></td></tr></table></figure><p>同时变量的操作都会经过<code>CAS</code>来保证操作安全。（CAS原理查看CAS.md篇）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//其中一个方法</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetState</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, expect, update);<br>&#125;<br></code></pre></td></tr></table></figure><p>同时内部节点<code>node</code>内部变量也被<code>volatile</code>修饰了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br><span class="hljs-keyword">volatile</span> Node prev;<br><span class="hljs-keyword">volatile</span> Node next;<br><span class="hljs-keyword">volatile</span> Thread thread;<br></code></pre></td></tr></table></figure><h5 id="内置的FIFO队列就是CLH-Craig-Landin-and-Hagersten-同步队列"><a href="#内置的FIFO队列就是CLH-Craig-Landin-and-Hagersten-同步队列" class="headerlink" title="内置的FIFO队列就是CLH(Craig, Landin, and Hagersten) 同步队列"></a>内置的FIFO队列就是CLH(Craig, Landin, and Hagersten) 同步队列</h5><p>该队列是一个FIFO双向队列</p><p><em><strong>入队</strong></em>，调用的是<kbd>addWaiter(Node node)</kbd>，尝试快速(相当于执行了一次)将该节点设置尾成尾节点，设置失败内部调用<kbd>enq(final Node node)</kbd>方法。<kbd>enq(final Node node)</kbd>通过<em><strong>“自旋”</strong></em>也就是死循环的方式来保证该节点能顺利的加入到队列尾部，只有加入成功才会退出循环，否则会一直循序直到成功。上述两方法都是通过<em><strong>CAS</strong></em>保证节点的添加的原子性。</p><p><em><strong>出队</strong></em>，首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节点，这个过程是不需要使用CAS来保证的，因为只有一个线程能够成功获取到同步状态。</p><h5 id="AQS数据结构："><a href="#AQS数据结构：" class="headerlink" title="AQS数据结构："></a>AQS数据结构：</h5><p>如果当前线程获取同步状态失败（锁）时，当前线程以及等待状态等信息构造成一个节点（Node）</p><p>解释一下几个方法和属性值的含义：</p><table><thead><tr><th align="left">方法和属性值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">waitStatus</td><td align="left">当前节点在队列中的状态</td></tr><tr><td align="left">thread</td><td align="left">表示处于该节点的线程</td></tr><tr><td align="left">prev</td><td align="left">前驱指针</td></tr><tr><td align="left">predecessor</td><td align="left">返回前驱节点，没有的话抛出npe</td></tr><tr><td align="left">nextWaiter</td><td align="left">指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）</td></tr><tr><td align="left">next</td><td align="left">后继指针</td></tr></tbody></table><p>线程两种锁的模式：</p><table><thead><tr><th align="left">模式</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">SHARED</td><td align="left">表示线程以共享的模式等待锁</td></tr><tr><td align="left">EXCLUSIVE</td><td align="left">表示线程正在以独占的方式等待锁</td></tr></tbody></table><p>waitStatus有下面几个枚举值：</p><table><thead><tr><th align="left">枚举</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">当一个Node被初始化的时候的默认值</td></tr><tr><td align="left">CANCELLED</td><td align="left">为1，表示线程获取锁的请求已经取消了</td></tr><tr><td align="left">CONDITION</td><td align="left">为-2，表示节点在等待队列中，节点线程等待唤醒</td></tr><tr><td align="left">PROPAGATE</td><td align="left">为-3，当前线程处在SHARED情况下，该字段才会使用</td></tr><tr><td align="left">SIGNAL</td><td align="left">为-1，表示线程已经准备好了，就等资源释放了</td></tr></tbody></table><h5 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h5><p>通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。</p><p><img src="/images/JUC/AQS/%E7%8B%AC%E5%8D%A0%E9%94%81.png" alt="独占锁"></p><p><img src="/images/JUC/AQS/%E5%85%B1%E4%BA%AB%E9%94%81.png" alt="共享锁"></p><h4 id="AQS的应用场景："><a href="#AQS的应用场景：" class="headerlink" title="AQS的应用场景："></a>AQS的应用场景：</h4><table><thead><tr><th align="left">同步工具</th><th align="left">同步工具与AQS的关联</th></tr></thead><tbody><tr><td align="left">ReentrantLock</td><td align="left">使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td></tr><tr><td align="left">Semaphore</td><td align="left">使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</td></tr><tr><td align="left">CountDownLatch</td><td align="left">使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td></tr><tr><td align="left">ReentrantReadWriteLock</td><td align="left">使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</td></tr><tr><td align="left">ThreadPoolExecutor</td><td align="left">Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>JUC</category>
      
      <category>基础原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三十四、IoC 之深入分析 Bean 的类型转换体系</title>
    <link href="/2022/06/11/IoC%20%E4%B9%8B%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20Bean%20%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%BD%93%E7%B3%BB/"/>
    <url>/2022/06/11/IoC%20%E4%B9%8B%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20Bean%20%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">IoC 之深入分析 Bean 的类型转换体系</font></div><p>不管 Bean 对象里面的属性是什么类型，它们都是通过 XML 、Properties 或者其他方式来配置这些<strong>属性</strong>对象类型的。在 Spring 容器加载过程中，这些属性都是以 String 类型加载进容器的，但是最终都需要将这些 String 类型的属性转换为 Bean 对象属性所对应真正的类型，要想完成这种由字符串到具体对象的转换，就需要这种转换规则相关的信息，而这些信息以及转换过程由 <strong>Spring 类型转换体系</strong>来完成。</p><p>以 XML 为例，在 Spring 容器加载阶段，容器将 xml 文件中定义的 <code>&lt;bean&gt;</code> 解析为 BeanDefinition，BeanDefinition 中存储着我们定义一个 bean 需要的所有信息，包括属性，这些属性是以 String 类型的存储的。当用户触发 Bean 实例化阶段时，Spring 容器会将这些属性转换为这些属性真正对应的类型。我们知道在 Bean 实例化阶段，属性的注入是在实例化 Bean 阶段的属性注入阶段，即 AbstractAutowireCapableBeanFactory 的 <code>populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</code> 方法。</p><p>在 <code>populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</code> 方法中，会将 BeanDefinition 中定义的属性值翻译为 PropertyValue ，然后调用 <code>applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</code> 方法，进行属性应用。其中 PropertyValue 用于保存单个 bean 属性的信息和值的对象。</p><h4 id="convertForProperty-方法"><a href="#convertForProperty-方法" class="headerlink" title="convertForProperty()方法"></a><code>convertForProperty()</code>方法</h4><p>在 <code>applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</code> 方法中，会调用 <code>convertForProperty(Object value, String propertyName, BeanWrapper bw, TypeConverter converter)</code> 进行属性转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory。java</span><br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">convertForProperty</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-meta">@Nullable</span> Object value, String propertyName, BeanWrapper bw, TypeConverter converter)</span> &#123;<br>    <span class="hljs-comment">// 若 TypeConverter 为 BeanWrapperImpl 类型，则使用 BeanWrapperImpl 来进行类型转换</span><br>    <span class="hljs-comment">// 这里主要是因为 BeanWrapperImpl 实现了 PropertyEditorRegistry 接口</span><br>    <span class="hljs-keyword">if</span> (converter <span class="hljs-keyword">instanceof</span> BeanWrapperImpl) &#123;<br>        <span class="hljs-keyword">return</span> ((BeanWrapperImpl) converter).convertForProperty(value, propertyName);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 获得属性对应的 PropertyDescriptor 对象</span><br>        <span class="hljs-type">PropertyDescriptor</span> <span class="hljs-variable">pd</span> <span class="hljs-operator">=</span> bw.getPropertyDescriptor(propertyName);<br>        <span class="hljs-comment">// 获得属性对应的 setting MethodParameter 对象</span><br>        <span class="hljs-type">MethodParameter</span> <span class="hljs-variable">methodParam</span> <span class="hljs-operator">=</span> BeanUtils.getWriteMethodParameter(pd);<br>        <span class="hljs-comment">// 执行转换</span><br>        <span class="hljs-keyword">return</span> converter.convertIfNecessary(value, pd.getPropertyType(), methodParam);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>若 TypeConverter 为 BeanWrapperImpl 类型，则使用 BeanWrapperImpl 来进行类型转换，这里主要是因为 BeanWrapperImpl 实现了 PropertyEditorRegistry 接口。</li><li>否则，调用 TypeConverter 的 <code>convertIfNecessary(Object value, Class requiredType, MethodParameter methodParam)</code> 方法，进行类型转换。TypeConverter 是定义类型转换方法的接口，通常情况下与 PropertyEditorRegistry 配合使用实现类型转换。</li></ul><h5 id="convertIfNecessary-方法"><a href="#convertIfNecessary-方法" class="headerlink" title="convertIfNecessary()方法"></a><code>convertIfNecessary()</code>方法</h5><p><code>convertIfNecessary(Object value, Class requiredType, MethodParameter methodParam)</code> 方法的实现者有两个：DataBinder 和 TypeConverterSupport 类。</p><ul><li>DataBinder 主要用于参数绑定（熟悉 Spring MVC 的都应该知道这个类）</li><li>TypeConverterSupport 则是 TypeConverter 的基本实现，使用的是 <code>typeConverterDelegate</code></li></ul><p>这里只需要关注 TypeConverterSupport 的 <code>convertIfNecessary(Object value, Class requiredType, MethodParameter methodParam)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TypeConverterSupport.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">convertIfNecessary</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object value, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType,</span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> MethodParameter methodParam)</span> <span class="hljs-keyword">throws</span> TypeMismatchException &#123;<br>    <span class="hljs-keyword">return</span> convertIfNecessary(value, requiredType,(methodParam != <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span>      <span class="hljs-title class_">TypeDescriptor</span>(methodParam) : TypeDescriptor.valueOf(requiredType)));<br>&#125;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">convertIfNecessary</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object value, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType,</span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> TypeDescriptor typeDescriptor)</span> <span class="hljs-keyword">throws</span> TypeMismatchException &#123;<br><br>    Assert.state(<span class="hljs-built_in">this</span>.typeConverterDelegate != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;No TypeConverterDelegate&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.typeConverterDelegate.convertIfNecessary(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, value, requiredType, typeDescriptor);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (ConverterNotFoundException | IllegalStateException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConversionNotSupportedException</span>(value, requiredType, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (ConversionException | IllegalArgumentException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeMismatchException</span>(value, requiredType, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后执行TypeConverterDelegate 的 <code>convertIfNecessary(Object newValue, @Nullable Class requiredType, ...)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TypeConverterDelegate.java</span><br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">convertIfNecessary</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String propertyName, <span class="hljs-meta">@Nullable</span> Object oldValue, <span class="hljs-meta">@Nullable</span> Object newValue,<span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="hljs-meta">@Nullable</span> TypeDescriptor typeDescriptor)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException &#123;<br><br>        <span class="hljs-comment">// ... 省略暂时非关键的代码</span><br><br>    <span class="hljs-comment">//如果没有自定义的编辑器则使用 ConversionService</span><br>        <span class="hljs-type">ConversionService</span> <span class="hljs-variable">conversionService</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.propertyEditorRegistry.getConversionService();<br>        <span class="hljs-keyword">if</span> (editor == <span class="hljs-literal">null</span> &amp;&amp; conversionService != <span class="hljs-literal">null</span> &amp;&amp; newValue != <span class="hljs-literal">null</span> &amp;&amp; typeDescriptor != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">TypeDescriptor</span> <span class="hljs-variable">sourceTypeDesc</span> <span class="hljs-operator">=</span> TypeDescriptor.forObject(newValue);<br>            <span class="hljs-keyword">if</span> (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">return</span> (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);<br>                &#125; <span class="hljs-keyword">catch</span> (ConversionFailedException ex) &#123;<br>                    conversionAttemptEx = ex;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// ... 省略暂时非关键的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConversionService.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ConversionService</span> &#123;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">canConvert</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">canConvert</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span>;<br><br>    <span class="hljs-meta">@Nullable</span><br>    &lt;T&gt; T <span class="hljs-title function_">convert</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object source, Class&lt;T&gt; targetType)</span>;<br><br>    <span class="hljs-meta">@Nullable</span><br>    Object <span class="hljs-title function_">convert</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object source, <span class="hljs-meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>ConfigurableConversionService</strong>：ConversionService 的配置接口，继承 ConversionService 和 ConverterRegistry 两个接口，用于合并他们两者的操作，以便于通过 add 和 remove 的方式添加和删除转换器。</li><li><strong>GenericConversionService</strong>：ConversionService 接口的基础实现，适用于大部分条件下的转换工作，通过 ConfigurableConversionService 接口间接地将 ConverterRegistry 实现为注册 API 。</li><li><strong>DefaultConversionService</strong>：ConversionService 接口的默认实现，适用于大部分条件下的转换工作。</li></ul><p>回到 TypeConverterDelegate 的 <code>convertIfNecessary(String propertyName, Object oldValue, @Nullable Object newValue, Class requiredType, TypeDescriptor typeDescriptor)</code> 方法，在该方法中，如果没有自定义的属性编辑器，则调用 ConversionService 接口的 <code>convert(...)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConversionService.java</span><br><br>Object <span class="hljs-title function_">convert</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object source, <span class="hljs-meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>source</code> ：要转换的源对象，可以为 <code>null</code> 。</li><li><code>sourceType</code>：<code>source</code> 的类型的上下文，如果 <code>source</code> 为 <code>null</code> ，则可以为 <code>null</code> 。</li><li><code>targetType</code> ：<code>source</code> 要转换的类型的上下文。</li></ul><p><code>convert(...)</code> 方法，将给定的源对象 <code>source</code> 转换为指定的 <code>targetType</code> 。TypeDescriptors 提供有关发生转换的源位置和目标位置的附加上下文，通常是对象字段或属性位置。该方法由子类 GenericConversionService 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// GenericConversionService.java</span><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">convert</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object source, <span class="hljs-meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;<br>    Assert.notNull(targetType, <span class="hljs-string">&quot;Target type to convert to cannot be null&quot;</span>);<br>    <span class="hljs-comment">// &lt;1&gt; 如果 sourceType 为空，则直接处理结果</span><br>    <span class="hljs-keyword">if</span> (sourceType == <span class="hljs-literal">null</span>) &#123;<br>        Assert.isTrue(source == <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Source must be [null] if source type == [null]&quot;</span>);<br>        <span class="hljs-keyword">return</span> handleResult(<span class="hljs-literal">null</span>, targetType, convertNullSource(<span class="hljs-literal">null</span>, targetType));<br>    &#125;<br>    <span class="hljs-comment">// &lt;2&gt; 如果类型不对，抛出 IllegalArgumentException 异常</span><br>    <span class="hljs-keyword">if</span> (source != <span class="hljs-literal">null</span> &amp;&amp; !sourceType.getObjectType().isInstance(source)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Source to convert from must be an instance of [&quot;</span> +<br>                sourceType + <span class="hljs-string">&quot;]; instead it was a [&quot;</span> + source.getClass().getName() + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// &lt;3&gt; 获得对应的 GenericConverter 对象</span><br>    <span class="hljs-type">GenericConverter</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> getConverter(sourceType, targetType);<br>    <span class="hljs-comment">// &lt;4&gt; 如果 converter 非空，则进行转换，然后再处理结果</span><br>    <span class="hljs-keyword">if</span> (converter != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// &lt;4.1&gt; 执行转换</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> ConversionUtils.invokeConverter(converter, source, sourceType, targetType);<br>        <span class="hljs-comment">// &lt;4.2&gt; 处理器结果</span><br>        <span class="hljs-keyword">return</span> handleResult(sourceType, targetType, result);<br>    &#125;<br>    <span class="hljs-comment">// &lt;5&gt; 处理 converter 为空的情况</span><br>    <span class="hljs-keyword">return</span> handleConverterNotFound(source, sourceType, targetType);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>&lt;1&gt;</code> 处，如果 <code>sourceType</code> 为空，则直接处理结果。</p></li><li><p><code>&lt;2&gt;</code> 处，如果类型不对，抛出 IllegalArgumentException 异常。</p></li><li><p><code>&lt;3&gt;</code> 处，调用 <code>getConverter(TypeDescriptor sourceType, TypeDescriptor targetType)</code> 方法，获取 GenericConverter 对象 <code>converter</code> 。</p></li><li><p><code>&lt;4&gt;</code> 处，如果 <code>converter</code> 非空，则进行转换，然后再处理结果。</p><p><code>&lt;4.1&gt;</code> 处，调用 <code>ConversionUtils#invokeConverter(GenericConverter converter, Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</code> 方法，执行转换：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConversionUtils.java</span><br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeConverter</span><span class="hljs-params">(GenericConverter converter, <span class="hljs-meta">@Nullable</span> Object source,</span><br><span class="hljs-params">        TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 执行转换</span><br>        <span class="hljs-keyword">return</span> converter.convert(source, sourceType, targetType);<br>    &#125; <span class="hljs-keyword">catch</span> (ConversionFailedException ex) &#123;<br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConversionFailedException</span>(sourceType, targetType, source, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&lt;4.2&gt;</code> 处，调用 <code>handleResult(TypeDescriptor sourceType, TypeDescriptor targetType, Object result)</code> 方法，处理结果，实际上就是<strong>校验</strong>结果。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// GenericConversionService.java</span><br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">handleResult</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType, <span class="hljs-meta">@Nullable</span> Object result)</span> &#123;<br><span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>assertNotPrimitiveTargetType(sourceType, targetType);<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">assertNotPrimitiveTargetType</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;<br><span class="hljs-keyword">if</span> (targetType.isPrimitive()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConversionFailedException</span>(sourceType, targetType, <span class="hljs-literal">null</span>,<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;A null value cannot be assigned to a primitive type&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>&lt;5&gt;</code> 处，调用 <code>handleConverterNotFound(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</code> 方法，处理 <code>converter</code> 为空的情况：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// GenericConversionService.java</span><br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">handleConverterNotFound</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-meta">@Nullable</span> Object source, <span class="hljs-meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;<br>    <span class="hljs-comment">// 情况一，如果 source 为空，则返回空</span><br>    <span class="hljs-keyword">if</span> (source == <span class="hljs-literal">null</span>) &#123;<br>        assertNotPrimitiveTargetType(sourceType, targetType);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 情况二，如果 sourceType 为空，或者 targetType 是 sourceType 的子类，则返回 source</span><br>    <span class="hljs-keyword">if</span> ((sourceType == <span class="hljs-literal">null</span> || sourceType.isAssignableTo(targetType)) &amp;&amp;<br>            targetType.getObjectType().isInstance(source)) &#123;<br>        <span class="hljs-keyword">return</span> source;<br>    &#125;<br>    <span class="hljs-comment">// 抛出 ConverterNotFoundException 异常</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConverterNotFoundException</span>(sourceType, targetType);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getConverter-方法"><a href="#getConverter-方法" class="headerlink" title="getConverter()方法"></a><code>getConverter()</code>方法</h4><p>先从 <code>getConverter(TypeDescriptor sourceType, TypeDescriptor targetType)</code> 方法，获取 GenericConverter 对象 <code>converter</code> 开始，即上边**&lt;3&gt;**。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// GenericConversionService.java</span><br><br><span class="hljs-comment">// 所有 Converter 集合的封装对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Converters</span> <span class="hljs-variable">converters</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Converters</span>();<br><br><span class="hljs-comment">// GenericConverter 缓存</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;ConverterCacheKey, GenericConverter&gt; converterCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentReferenceHashMap</span>&lt;&gt;(<span class="hljs-number">64</span>);<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> GenericConverter <span class="hljs-title function_">getConverter</span><span class="hljs-params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;<br>    <span class="hljs-comment">// 创建 ConverterCacheKey 对象</span><br>    <span class="hljs-type">ConverterCacheKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConverterCacheKey</span>(sourceType, targetType);<br>    <span class="hljs-comment">// 从 converterCache 缓存中，获得 GenericConverter 对象 converter</span><br>    <span class="hljs-type">GenericConverter</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.converterCache.get(key);<br>    <span class="hljs-comment">// 如果获得到，则返回 converter</span><br>    <span class="hljs-keyword">if</span> (converter != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> (converter != NO_MATCH ? converter : <span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-comment">// 如果获取不到，则从 converters 中查找</span><br>    converter = <span class="hljs-built_in">this</span>.converters.find(sourceType, targetType);<br>    <span class="hljs-comment">// 如果查找不到，则获得默认的 Converter 对象</span><br>    <span class="hljs-keyword">if</span> (converter == <span class="hljs-literal">null</span>) &#123;<br>        converter = getDefaultConverter(sourceType, targetType);<br>    &#125;<br>    <span class="hljs-comment">// 如果找到 converter ，则添加 converter 到 converterCache 中，并返回 converter</span><br>    <span class="hljs-keyword">if</span> (converter != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.converterCache.put(key, converter);<br>        <span class="hljs-keyword">return</span> converter;<br>    &#125;<br>    <span class="hljs-comment">// 如果找不到 converter ，则添加 NO_MATCH 占位符到 converterCache 中，并返回 null</span><br>    <span class="hljs-built_in">this</span>.converterCache.put(key, NO_MATCH);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑比较简单：从 <code>converterCache</code> 缓存中获取，如果存在返回，否则从 <code>converters</code> 中获取，然后加入到 <code>converterCache</code> 缓存中。</p><p>Converters 是 GenericConversionService 内部类，用于管理所有注册的转换器，其内部维护一个 Set 和 Map 的数据结构用于管理转换器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// GenericConversionService.java#Converters</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;GenericConverter&gt; globalConverters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;ConvertiblePair, ConvertersForPair&gt; converters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(<span class="hljs-number">36</span>);<br></code></pre></td></tr></table></figure><p>在 <code>getConverter(TypeDescriptor sourceType, TypeDescriptor targetType)</code> 方法中，如果缓存 <code>converterCache</code> 中不存在，则调用 Converters 对象的 <code>find(TypeDescriptor sourceType, TypeDescriptor targetType)</code> 方法，查找相应的 GenericConverter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// GenericConversionService.java#Converters</span><br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> GenericConverter <span class="hljs-title function_">find</span><span class="hljs-params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;<br>    <span class="hljs-comment">// Search the full type hierarchy</span><br>    List&lt;Class&lt;?&gt;&gt; sourceCandidates = getClassHierarchy(sourceType.getType());<br>    List&lt;Class&lt;?&gt;&gt; targetCandidates = getClassHierarchy(targetType.getType());<br>    <span class="hljs-comment">// 遍历 sourceCandidates 数组</span><br>    <span class="hljs-keyword">for</span> (Class&lt;?&gt; sourceCandidate : sourceCandidates) &#123;<br>        <span class="hljs-comment">// 遍历 targetCandidates 数组</span><br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; targetCandidate : targetCandidates) &#123;<br>            <span class="hljs-comment">// 创建 ConvertiblePair 对象</span><br>            <span class="hljs-type">ConvertiblePair</span> <span class="hljs-variable">convertiblePair</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConvertiblePair</span>(sourceCandidate, targetCandidate);<br>            <span class="hljs-comment">// 获得 GenericConverter 对象</span><br>            <span class="hljs-type">GenericConverter</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> getRegisteredConverter(sourceType, targetType, convertiblePair);<br>            <span class="hljs-keyword">if</span> (converter != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> converter;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> GenericConverter <span class="hljs-title function_">getRegisteredConverter</span><span class="hljs-params">(TypeDescriptor sourceType,</span><br><span class="hljs-params">        TypeDescriptor targetType, ConvertiblePair convertiblePair)</span> &#123;<br>    <span class="hljs-comment">// Check specifically registered converters</span><br>    <span class="hljs-comment">// 从 converters 中，获得 converter</span><br>    <span class="hljs-type">ConvertersForPair</span> <span class="hljs-variable">convertersForPair</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.converters.get(convertiblePair);<br>    <span class="hljs-keyword">if</span> (convertersForPair != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">GenericConverter</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> convertersForPair.getConverter(sourceType, targetType);<br>        <span class="hljs-keyword">if</span> (converter != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> converter;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Check ConditionalConverters for a dynamic match</span><br>    <span class="hljs-comment">// 从 globalConverters 中，获得 globalConverter</span><br>    <span class="hljs-keyword">for</span> (GenericConverter globalConverter : <span class="hljs-built_in">this</span>.globalConverters) &#123;<br>        <span class="hljs-keyword">if</span> (((ConditionalConverter) globalConverter).matches(sourceType, targetType)) &#123;<br>            <span class="hljs-keyword">return</span> globalConverter;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>find(TypeDescriptor sourceType, TypeDescriptor targetT)</code> 方法中，会根据 <code>sourceType</code> 和 <code>targetType</code> 去查询 Converters 中维护的 Map 中是否包括支持的注册类型。如果存在返回 GenericConverter ，如果没有存在返回 <code>null</code> 。</p><h4 id="convert-方法"><a href="#convert-方法" class="headerlink" title="convert()方法"></a><code>convert()</code>方法</h4><p>当得到 GenericConverter 后，则调用其 <code>convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</code> 方法，进行类型转换，即**&lt;4.1&gt;**处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// &lt;4.1&gt; 执行转换</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> ConversionUtils.invokeConverter(converter, source, sourceType, targetType);<br></code></pre></td></tr></table></figure><p>该方法内部调用的就是<code>GenericConverter.convert()</code>，这里就可以得到 Bean 属性定义的真正类型了。</p><h4 id="GenericConverter接口"><a href="#GenericConverter接口" class="headerlink" title="GenericConverter接口"></a><code>GenericConverter</code>接口</h4><p>GenericConverter 是一个转换接口，一个用于在两种或更多种类型之间转换的通用型转换器接口。它是 Converter SPI 体系中最灵活的，也是最复杂的接口，灵活性在于 GenericConverter 可以支持在多个源&#x2F;目标类型对之间进行转换，同时也可以在类型转换过程中访问源&#x2F;目标字段上下文。由于该接口足够复杂，所有当更简单的 Converter 或 ConverterFactory 接口足够使用时，通常不应使用此接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// GenericConverter.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GenericConverter</span> &#123;<br>    <span class="hljs-meta">@Nullable</span><br>    Set&lt;ConvertiblePair&gt; <span class="hljs-title function_">getConvertibleTypes</span><span class="hljs-params">()</span>;<br>    <span class="hljs-meta">@Nullable</span><br>    Object <span class="hljs-title function_">convert</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在类型转换体系中，Spring 提供了非常多的类型转换器，除了上面的 GenericConverter，还有 Converter、ConditionalConverter、ConverterFactory。</p><h4 id="Converter接口"><a href="#Converter接口" class="headerlink" title="Converter接口"></a><code>Converter</code>接口</h4><p>Converter 是一个将 <code>类型的源对象转换为</code> 类型的目标对象的转换器。该接口是线程安全的，所以可以共享：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Converter.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Converter</span>&lt;S, T&gt; &#123;<br>    <span class="hljs-meta">@Nullable</span><br>    T <span class="hljs-title function_">convert</span><span class="hljs-params">(S source)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ConditionalConverter接口"><a href="#ConditionalConverter接口" class="headerlink" title="ConditionalConverter接口"></a><code>ConditionalConverter</code>接口</h4><p>ConditionalConverter 接口用于表示有条件的类型转换，通过转入的<code>sourceType</code> 与 <code>targetType</code> 判断转换能否匹配，只有可匹配的转换才会调用convert 方法进行转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConditionalConverter.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ConditionalConverter</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ConverterFactory接口"><a href="#ConverterFactory接口" class="headerlink" title="ConverterFactory接口"></a><code>ConverterFactory</code>接口</h4><p>一个用于“远程”转换的转换工厂，可以将对象从 <code>转换为</code> 的子类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConverterFactory.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ConverterFactory</span>&lt;S, R&gt; &#123;<br>    &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">R</span>&gt; Converter&lt;S, T&gt; <span class="hljs-title function_">getConverter</span><span class="hljs-params">(Class&lt;T&gt; targetType)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>四种不同的转换器承载着不同的转换过程：</p><ul><li>Converter：用于 <code>1:1</code> 的 <code>source -&gt; target</code> 类型转换。</li><li>ConverterFactory：用于 <code>1:N</code> 的 <code>source -&gt; target</code> 类型转换。</li><li>GenericConverter用于 <code>N:N</code> 的 <code>source -&gt; target</code> 类型转换。</li><li>ConditionalConverter：有条件的 <code>source -&gt; target</code> 类型转换。</li></ul><h4 id="GenericConversionService-接口"><a href="#GenericConversionService-接口" class="headerlink" title="GenericConversionService()接口"></a><code>GenericConversionService()</code>接口</h4><p>ConversionService 接口中定义了两类方法：</p><ul><li><code>canConvert(sourceType, targetType)</code> 方法，用于判 <code>sourceType</code> 能否转成 <code>targetType</code> 。</li><li><code>convert(source, targetType)</code> 方法，用于将 <code>source</code> 转成转入的 TargetType 类型实例。</li></ul><p>这两类方法都是在 GenericConversionService 中实现。<br>类 GenericConversionService 实现 ConfigurableConversionService 接口，而 ConfigurableConversionService 接口继承 ConversionService 和 ConverterRegistry。<br>ConverterRegistry 提供了类型转换器的管理功能，他提供了四个 add 和一个 remove 方法，支持注册&#x2F;删除相应的类型转换器。</p><p>GenericConversionService 作为一个基础实现类，它即支持了不同类型之间的转换，也对各类型转换器进行管理，主要是通过一个 Map 类型的 <code>converterCache</code> 和一个内部类 Converters 。在上面已经分析了 GenericConversionService 执行类型转换的过程 <code>cover(...)</code> 方法。下面我们就一个 <code>addConverter(Converter converter)</code> 方法，来看看它是如何完成转换器的注入的工作的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// GenericConversionService.java</span><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addConverter</span><span class="hljs-params">(Converter&lt;?, ?&gt; converter)</span> &#123;<br>    <span class="hljs-comment">// &lt;1&gt; 获取 ResolvableType 对象，基于 converter.getClass() 类</span><br>    ResolvableType[] typeInfo = getRequiredTypeInfo(converter.getClass(), Converter.class);<br>    <span class="hljs-comment">// &lt;1&gt; 如果获取不到，并且 converter 是 DecoratingProxy 类型，则基于 ((DecoratingProxy) converter).getDecoratedClass() 类</span><br>    <span class="hljs-keyword">if</span> (typeInfo == <span class="hljs-literal">null</span> &amp;&amp; converter <span class="hljs-keyword">instanceof</span> DecoratingProxy) &#123;<br>        typeInfo = getRequiredTypeInfo(((DecoratingProxy) converter).getDecoratedClass(), Converter.class);<br>    &#125;<br>    <span class="hljs-comment">// 如果获取不到，抛出 IllegalArgumentException 异常</span><br>    <span class="hljs-keyword">if</span> (typeInfo == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unable to determine source type &lt;S&gt; and target type &lt;T&gt; for your Converter [&quot;</span> + converter.getClass().getName() + <span class="hljs-string">&quot;]; does the class parameterize those types?&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// &lt;2&gt; 封装成 ConverterAdapter 对象，添加到 converters 中</span><br>    addConverter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConverterAdapter</span>(converter, typeInfo[<span class="hljs-number">0</span>], typeInfo[<span class="hljs-number">1</span>]));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>&lt;1&gt;</code> 首先，根据 <code>converter</code> 获取 ResolvableType 数组。</li><li><code>&lt;2&gt;</code> 然后，将其与 <code>converter</code> 封装成一个 ConverterAdapter 实例。</li><li><code>&lt;2&gt;</code> 最后，调用 <code>addConverter(GenericConverter converter)</code> 方法，添加到 <code>converters</code> 中。</li><li>ResolvableType 用于封装 Java 的 Type类型。</li><li>ConverterAdapter 则是 Converter 的一个适配器， 它实现了 GenericConverter 和 ConditionalConverter 两个类型转换器。</li></ul><p><code>addConverter(GenericConverter converter)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// GenericConversionService.java</span><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addConverter</span><span class="hljs-params">(GenericConverter converter)</span> &#123;<br>    <span class="hljs-comment">// 添加到 converters 中</span><br>    <span class="hljs-built_in">this</span>.converters.add(converter);<br>    <span class="hljs-comment">// 过期缓存</span><br>    invalidateCache();<br>&#125;<br></code></pre></td></tr></table></figure><p>直接调用内部类 Converters 的 <code>add(GenericConverter converter)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// GenericConversionService.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(GenericConverter converter)</span> &#123;<br>    <span class="hljs-comment">// 获得 ConvertiblePair 集合</span><br>    Set&lt;ConvertiblePair&gt; convertibleTypes = converter.getConvertibleTypes();<br>    <span class="hljs-comment">// 如果为空，并且 converter 是 ConditionalConverter 类型，则添加到 【globalConverters】 中</span><br>    <span class="hljs-keyword">if</span> (convertibleTypes == <span class="hljs-literal">null</span>) &#123;<br>        Assert.state(converter <span class="hljs-keyword">instanceof</span> ConditionalConverter,<br>                     <span class="hljs-string">&quot;Only conditional converters may return null convertible types&quot;</span>);<br>        <span class="hljs-built_in">this</span>.globalConverters.add(converter);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 通过迭代的方式依次添加【converters】中</span><br>        <span class="hljs-keyword">for</span> (ConvertiblePair convertiblePair : convertibleTypes) &#123;<br>            <span class="hljs-comment">// 从 converters 中，获得 ConvertersForPair 对象，添加 converter 到 ConvertersForPair 中</span><br>            getMatchableConverters(convertiblePair).add(converter);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先调用 GenericConverter 的 <code>getConvertibleTypes()</code> 方法，获取 ConvertiblePair 集合。如果为空，则加入到 <code>globalConverters</code> 集合中，否则通过迭代的方式依次添加 <code>converters</code> 中。</li><li>ConvertiblePair 为 source-to-target 的持有者，它持有 <code>source</code> 和 <code>target</code> 的 class 类型，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// GenericConverter.java#ConvertiblePair</span><br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConvertiblePair</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; sourceType;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; targetType;<br>    <span class="hljs-comment">// 省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在迭代过程中会根据 ConvertiblePair 获取相应的 ConvertersForPair 对象，然后添加 <code>converter</code> 转换器加入其中。ConvertiblePair 用于管理使用特定GenericConverter.ConvertiblePair 注册的转换器，也是个内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// GenericConversionService.java#ConvertersForPair</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConvertersForPair</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedList&lt;GenericConverter&gt; converters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(GenericConverter converter)</span> &#123;<br>        <span class="hljs-built_in">this</span>.converters.addFirst(converter);<br>    &#125;<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">public</span> GenericConverter <span class="hljs-title function_">getConverter</span><span class="hljs-params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;<br>        <span class="hljs-keyword">for</span> (GenericConverter converter : <span class="hljs-built_in">this</span>.converters) &#123;<br>            <span class="hljs-keyword">if</span> (!(converter <span class="hljs-keyword">instanceof</span> ConditionalGenericConverter) ||<br>                    ((ConditionalGenericConverter) converter).matches(sourceType, targetType)) &#123;<br>                <span class="hljs-keyword">return</span> converter;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其实内部就是维护一个 LinkedList 集合。他内部有两个方法：<code>add(GenericConverter converter)</code> 和 <code>getConverter(TypeDescriptor sourceType, TypeDescriptor targetType)</code>，实现较为简单。</p><h4 id="DefaultConversionService"><a href="#DefaultConversionService" class="headerlink" title="DefaultConversionService"></a><code>DefaultConversionService</code></h4><p>DefaultConversionService 是 ConversionService 的默认实现，它继承 GenericConversionService，GenericConversionService 主要用于转换器的注册和调用，DefaultConversionService 则是为 ConversionService 体系提供一些默认的转换器。在 DefaultConversionService 构造方法中就会添加默认的 Converter ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultConversionService.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultConversionService</span><span class="hljs-params">()</span> &#123;<br>    addDefaultConverters(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addDefaultConverters</span><span class="hljs-params">(ConverterRegistry converterRegistry)</span> &#123;<br>    addScalarConverters(converterRegistry);<br>    addCollectionConverters(converterRegistry);<br><br>    converterRegistry.addConverter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBufferConverter</span>((ConversionService) converterRegistry));<br>    converterRegistry.addConverter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringToTimeZoneConverter</span>());<br>    converterRegistry.addConverter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ZoneIdToTimeZoneConverter</span>());<br>    converterRegistry.addConverter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ZonedDateTimeToCalendarConverter</span>());<br><br>    converterRegistry.addConverter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectToObjectConverter</span>());<br>    converterRegistry.addConverter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IdToEntityConverter</span>((ConversionService) converterRegistry));<br>    converterRegistry.addConverter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FallbackObjectToStringConverter</span>());<br>    converterRegistry.addConverter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectToOptionalConverter</span>((ConversionService) converterRegistry));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Bean的属性转换大致调用流程：</p><p>TypeConverterSupport &#x3D;&gt; ConversionService &#x3D;&gt; Converter</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二十九、IOC之InitializingBean 和 init-method</title>
    <link href="/2022/06/11/IOC%E4%B9%8BInitializingBean%20%E5%92%8C%20init-method/"/>
    <url>/2022/06/11/IOC%E4%B9%8BInitializingBean%20%E5%92%8C%20init-method/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">IOC之InitializingBean 和 init-method</font></div><p>Spring在初始化时进行三个检测扩展：之前说到的<code>Aware</code>和<code>BeanPostProcessor</code>，还有本篇<code>InitializingBean</code>接口和<code>init-method</code>。</p><p>因为<code>DisposableBean</code>接口 和 <code>destroy-method</code>与初始化的时候逻辑一样，故只分析<code>InitializingBean</code>接口和<code>init-method</code>。</p><h4 id="InitializingBean接口"><a href="#InitializingBean接口" class="headerlink" title="InitializingBean接口"></a><code>InitializingBean</code>接口</h4><p><code>InitializingBean</code>接口只提供了一个方法<code>afterPropertiesSet()</code>，用来为bean提供定义初始化方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br><span class="hljs-comment">//该方法在 BeanFactory 设置完了所有属性之后被调用</span><br><span class="hljs-comment">//  该方法允许 bean 实例设置了所有 bean 属性时执行初始化工作，如果该过程出现了错误则需要抛出异常</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring 在完成实例化后，设置完所有属性，进行 <code>Aware</code>接口和 <code>BeanPostProcessor</code>前置处理之后，会接着检测当前 bean 对象是否实现了 <code>InitializingBean</code> 接口。如果是，则会调用其 <code>afterPropertiesSet()</code> 方法，进一步调整 bean 实例对象的状态，最后会执行<code>BeanPostProcessor</code>后置处理。</p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestInitializingBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;InitializingBean init...&quot;</span>);<br><span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;jievhahaTest&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><span class="hljs-type">TestInitializingBean</span> <span class="hljs-variable">testInitializingBean</span> <span class="hljs-operator">=</span> (TestInitializingBean) applicationContext.getBean(<span class="hljs-string">&quot;testInitializingBean&quot;</span>);<br>System.out.println(testInitializingBean.getName());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testInitializingBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jievhaha.TestInitializingBean&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;test&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最后执行结果为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">Bean[testInitializingBean]开始初始化<br>InitializingBean init...<br>Bean[testInitializingBean]完成初始化<br>jievhahaTest  //假如在afterPropertiesSet中没有设置，最后结果为test<br></code></pre></td></tr></table></figure><h5 id="invokeInitMethods"><a href="#invokeInitMethods" class="headerlink" title="invokeInitMethods"></a><code>invokeInitMethods</code></h5><p>在<code>Bean</code>初始化阶段， Spring 容器会主动检查当前 bean 是否已经实现了 InitializingBean 接口，如果实现了，则会掉用其 <code>afterPropertiesSet()</code> 方法。这个主动检查、调用的动作是由 <code>invokeInitMethods(String beanName, final Object bean, @Nullable RootBeanDefinition mbd)</code> 方法来完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeInitMethods</span><span class="hljs-params">(String beanName, <span class="hljs-keyword">final</span> Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span><br>        <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// 首先会检查是否是 InitializingBean ，如果是的话需要调用 afterPropertiesSet()</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isInitializingBean</span> <span class="hljs-operator">=</span> (bean <span class="hljs-keyword">instanceof</span> InitializingBean);<br>    <span class="hljs-keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="hljs-literal">null</span> || !mbd.isExternallyManagedInitMethod(<span class="hljs-string">&quot;afterPropertiesSet&quot;</span>))) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 安全模式</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;<br>                    <span class="hljs-comment">// 属性初始化的处理</span><br>                    ((InitializingBean) bean).afterPropertiesSet();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;, getAccessControlContext());<br>            &#125; <span class="hljs-keyword">catch</span> (PrivilegedActionException pae) &#123;<br>                <span class="hljs-keyword">throw</span> pae.getException();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 属性初始化的处理</span><br>            ((InitializingBean) bean).afterPropertiesSet();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mbd != <span class="hljs-literal">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;<br>        <span class="hljs-comment">// 判断是否指定了 init-method()，</span><br>        <span class="hljs-comment">// 如果指定了 init-method()，则再调用制定的init-method</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">initMethodName</span> <span class="hljs-operator">=</span> mbd.getInitMethodName();<br>        <span class="hljs-keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;<br>                !(isInitializingBean &amp;&amp; <span class="hljs-string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;<br>                !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;<br>            <span class="hljs-comment">// 激活用户自定义的初始化方法</span><br>            <span class="hljs-comment">// 利用反射机制执行</span><br>            invokeCustomInitMethod(beanName, bean, mbd);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先，检测当前 bean 是否实现了 InitializingBean 接口，如果实现了则调用其 <code>afterPropertiesSet()</code> 方法。</li><li>然后，再检查是否也指定了 <code>init-method</code>，如果指定了则通过反射机制调用指定的 <code>init-method</code> 方法。</li></ul><h4 id="init-method属性"><a href="#init-method属性" class="headerlink" title="init-method属性"></a><code>init-method</code>属性</h4><p>直接实现<code>InitializingBean</code>接口破坏了Spring的核心理念：无侵入性，故有另一种实现方式：<code>init-method</code>。</p><p>即spring配置文件注册bean时，给<code>&lt;bean&gt;</code>标签添加<code>init-method</code>属性，也可以直接使用<code>&lt;beans&gt;</code>标签的<code>default-init-method</code>属性来统一指定初始化方法，不用每个<code>&lt;bean&gt;</code>标签指定<code>init-method</code>属性。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从 <code>invokeInitMethods(...)</code> 方法中，我们知道 <code>init-method</code> 指定的方法会在 <code>afterPropertiesSet()</code> 方法之后执行，如果 <code>afterPropertiesSet()</code> 方法的执行的过程中出现了异常，则 <code>init-method</code> 是不会执行的，而且由于 <code>init-method</code> 采用的是反射执行的方式，所以 <code>afterPropertiesSet()</code> 方法的执行效率一般会高些，但是并不能排除我们要优先使用 <code>init-method</code>，主要是因为它消除了 bean 对 Spring 的依赖，Spring 没有侵入到我们业务代码，这样会更加符合 Spring 的理念。诚然，<code>init-method</code> 是基于 xml 配置文件的，就目前而言，我们的工程几乎都摒弃了配置，而采用注释的方式，那么 <code>@PreDestory</code> 可能比较适合。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三十三、IOC之深入分析 PropertyOverrideConfigurer</title>
    <link href="/2022/06/11/IOC%E4%B9%8B%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20PropertyOverrideConfigurer/"/>
    <url>/2022/06/11/IOC%E4%B9%8B%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20PropertyOverrideConfigurer/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">IOC之深入分析 PropertyOverrideConfigurer</font></div><p>BeanFactoryPostProcessor 作用于 BeanDefinition 完成加载之后与 Bean 实例化之前，是 Spring 提供的一种强大的扩展机制。它有两个重要的子类，一个是 PropertyPlaceholderConfigurer，另一个是 PropertyOverrideConfigurer ，其中 PropertyPlaceholderConfigurer 允许我们通过配置 Properties 的方式来取代 Bean 中定义的占位符，PropertyOverrideConfigurer 允许我们对 Spring 容器中配置的任何我们想处理的 bean 定义的 property 信息进行覆盖替换。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>UML图：</p><p><img src="/images/spring_IOC/propertyOverrideConfigurer%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="propertyOverrideConfigurer结构图"></p><p>与 PropertyPlaceholderConfigurer 一样，也是继承 PropertyResourceConfigurer，我们知道 PropertyResourceConfigurer 对 BeanFactoryPostProcessor 的 <code>postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)</code> 方法提供了实现，在该实现中它会去读取指定配置文件中的内容，然后调用 <code>processProperties(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props)</code> 方法。该方法是一个抽象方法，具体的实现由子类来实现，所以这里我们只需要看 PropertyOverrideConfigurer 中 <code>processProperties(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props)</code> 方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PropertyOverrideConfigurer.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processProperties</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory, Properties props)</span><br>    <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>    <span class="hljs-comment">// 迭代配置文件中的内容</span><br>    <span class="hljs-keyword">for</span> (Enumeration&lt;?&gt; names = props.propertyNames(); names.hasMoreElements();) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (String) names.nextElement();<br>        <span class="hljs-keyword">try</span> &#123;<br>            processKey(beanFactory, key, props.getProperty(key));<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Could not process key &#x27;&quot;</span> + key + <span class="hljs-string">&quot;&#x27; in PropertyOverrideConfigurer&quot;</span>;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.ignoreInvalidKeys) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInitializationException</span>(msg, ex);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                logger.debug(msg, ex);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代 <code>props</code> 数组，依次调用 <code>processKey(ConfigurableListableBeanFactory factory, String key, String value)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PropertyOverrideConfigurer.java</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Bean 名字的分隔符</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_BEAN_NAME_SEPARATOR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">beanNameSeparator</span> <span class="hljs-operator">=</span> DEFAULT_BEAN_NAME_SEPARATOR;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processKey</span><span class="hljs-params">(ConfigurableListableBeanFactory factory, String key, String value)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>    <span class="hljs-comment">// 判断是否存在 &quot;.&quot;，即获取其索引位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">separatorIndex</span> <span class="hljs-operator">=</span> key.indexOf(<span class="hljs-built_in">this</span>.beanNameSeparator);<br>    <span class="hljs-keyword">if</span> (separatorIndex == -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInitializationException</span>(<span class="hljs-string">&quot;Invalid key &#x27;&quot;</span> + key +<br>                                              <span class="hljs-string">&quot;&#x27;: expected &#x27;beanName&quot;</span> + <span class="hljs-built_in">this</span>.beanNameSeparator + <span class="hljs-string">&quot;property&#x27;&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 得到 beanName</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> key.substring(<span class="hljs-number">0</span>, separatorIndex);<br>    <span class="hljs-comment">// 得到属性名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">beanProperty</span> <span class="hljs-operator">=</span> key.substring(separatorIndex + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">this</span>.beanNames.add(beanName);<br>    <span class="hljs-comment">// 替换</span><br>    applyPropertyValue(factory, beanName, beanProperty, value);<br>    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>        logger.debug(<span class="hljs-string">&quot;Property &#x27;&quot;</span> + key + <span class="hljs-string">&quot;&#x27; set to value [&quot;</span> + value + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取分割符 <code>“.”</code> 的索引位置，得到 <code>beanName</code> 以及相应的属性，然后调用 <code>applyPropertyValue(ConfigurableListableBeanFactory factory, String beanName, String property, String value)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PropertyOverrideConfigurer.java</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyPropertyValue</span><span class="hljs-params">(ConfigurableListableBeanFactory factory, String beanName, String property, String value)</span> &#123;<br><br>    <span class="hljs-comment">// 获得 BeanDefinition 对象</span><br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> factory.getBeanDefinition(beanName);<br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">bdToUse</span> <span class="hljs-operator">=</span> bd;<br>    <span class="hljs-keyword">while</span> (bd != <span class="hljs-literal">null</span>) &#123;<br>        bdToUse = bd;<br>        bd = bd.getOriginatingBeanDefinition();<br>    &#125;<br>    <span class="hljs-comment">// 设置 PropertyValue 到 BeanDefinition 中</span><br>    <span class="hljs-type">PropertyValue</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyValue</span>(property, value);<br>    pv.setOptional(<span class="hljs-built_in">this</span>.ignoreInvalidKeys);<br>    bdToUse.getPropertyValues().addPropertyValue(pv);<br>&#125;<br></code></pre></td></tr></table></figure><p>从容器中获取 BeanDefinition ，然后根据属性 <code>property</code> 和其值 <code>value</code> 构造成一个 PropertyValue 对象，最后调用 <code>addPropertyValue(PropertyValue pv )</code> 方法。PropertyValue 是用于保存一组bean属性的信息和值的对像：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MutablePropertyValues.java</span><br><span class="hljs-keyword">public</span> MutablePropertyValues <span class="hljs-title function_">addPropertyValue</span><span class="hljs-params">(PropertyValue pv)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.propertyValueList.size(); i++) &#123;<br>        <span class="hljs-type">PropertyValue</span> <span class="hljs-variable">currentPv</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.propertyValueList.get(i);<br>        <span class="hljs-comment">// 匹配</span><br>        <span class="hljs-keyword">if</span> (currentPv.getName().equals(pv.getName())) &#123;<br>            <span class="hljs-comment">// 合并属性</span><br>            pv = mergeIfRequired(pv, currentPv);<br>            <span class="hljs-comment">// 覆盖属性</span><br>            setPropertyValueAt(pv, i);<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 未匹配到，添加到 propertyValueList 中</span><br>    <span class="hljs-built_in">this</span>.propertyValueList.add(pv);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加 PropertyValue 对象，替换或者合并相同的属性值。</p><h4 id="propertyOverride和PropertyPlaceholder"><a href="#propertyOverride和PropertyPlaceholder" class="headerlink" title="propertyOverride和PropertyPlaceholder"></a>propertyOverride和PropertyPlaceholder</h4><p><img src="/images/spring_IOC/propertyOverride%E5%92%8CPropertyPlaceholder.png" alt="propertyOverride和PropertyPlaceholder"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一、IOC概要</title>
    <link href="/2022/06/11/IOC%E7%90%86%E8%AE%BA/"/>
    <url>/2022/06/11/IOC%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">IOC概要</font></div><blockquote><table><tr><td bgcolor="#6495ED"><font color="#FFF">IOC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系.</font></td></tr></table></blockquote><p>控制反转，是一种设计思想，依赖注入<code>DI</code>是一种具体实现。IOC意味着将设计好的对象交给容器控制，由容器帮我们查找及注入依赖对象（所以对象和对象之间是松散耦合的），对象只是被动的接受依赖对象，即为反转。</p><p>在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说依赖的对象直接由我们自己控制，但是有了 IoC 容器后，则直接由 IoC 容器来控制。</p><p>没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。</p><h4 id="IOC注入方式"><a href="#IOC注入方式" class="headerlink" title="IOC注入方式"></a>IOC注入方式</h4><ol><li>构造器注入</li><li>setter注入</li><li>接口注入</li></ol><h4 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h4><p>主要有五个体系：<code>Resource</code>、<code>BeanFactory</code>、<code>BeanDefinition</code>、<code>BeanDefinitionReader</code>、<code>ApplicationContext</code>。</p><h5 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h5><p>对资源的抽象，它的每一个实现类都代表了一种资源的访问策略。</p><p><img src="/images/spring_IOC/Resource.png" alt="Resource"></p><p>有了资源，就应该有资源加载，<code>ResourceLoader</code>就是进行统一资源加载。</p><p><img src="/images/spring_IOC/ResourceLoader.png" alt="ResourceLoader"></p><h5 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h5><p>是bean容器，<code>BeanDefinition</code> 是它的基本结构，它内部维护着一个 <code>BeanDefinition map </code>，并可根据 <code>BeanDefinition</code> 的描述进行 bean 的创建和管理。</p><p><img src="/images/spring_IOC/BeanFactory.png" alt="BeanFactory"></p><p><code>BeanFacoty</code> 有三个直接子类 <code>ListableBeanFactory</code>、<code>HierarchicalBeanFactory</code> 和 <code>AutowireCapableBeanFactory</code>，<code>DefaultListableBeanFactory</code> 为最终默认实现，它实现了所有接口。</p><h5 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h5><p>用来描述Spring中Bean对象。</p><p><img src="/images/spring_IOC/BeanDefinition.png" alt="BeanDefinition"></p><h5 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h5><p>读取Spring配置文件内容，并将其转换成IOC容器内部的<code>BeanDefinition</code>。</p><p><img src="/images/spring_IOC/BeanDefinitionReader.png" alt="BeanDefinitionReader"></p><h5 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h5><p>Spring容器，也叫<em><strong>应用上下文</strong></em>，继承自BeanFactory，二者主要区别：</p><ol><li>继承 <code>MessageSource</code>，提供国际化的标准访问策略。</li><li>继承 <code>ApplicationEventPublisher </code>，提供强大的事件机制。</li><li>扩展 <code>ResourceLoader</code>，可以用来加载多个 Resource，可以灵活访问不同的资源。</li><li>对 Web 应用的支持。</li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三十一、IOC之BeanFactoryPostProcessor</title>
    <link href="/2022/06/11/IOC%E4%B9%8BBeanFactoryPostProcessor/"/>
    <url>/2022/06/11/IOC%E4%B9%8BBeanFactoryPostProcessor/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">IOC之BeanFactoryPostProcessor</font></div><p>BeanPostProcessor 是 Spring 提供一种扩展机制，该机制允许我们在 Bean <strong>实例化之后初始化之际</strong>对 Bean 进行增强处理（前、后置处理）。</p><p>同样在 Spring 容器<strong>启动</strong>阶段，Spring 也提供了一种容器扩展机制：<strong>BeanFactoryPostProcessor</strong>，该机制作用于容器启动阶段，允许我们在容器实例化 Bean 之前对注册到该容器的 BeanDefinition 做出修改。</p><h4 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a><code>BeanFactoryPostProcessor</code></h4><p>BeanFactoryPostProcessor 的机制，就相当于给了我们在 Bean 实例化之前最后一次修改 BeanDefinition 的机会，我们可以利用这个机会对 BeanDefinition 来进行一些额外的操作，比如更改某些 bean 的一些属性，给某些 Bean 增加一些其他的信息等等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>BeanFactoryPostProcessor</code>是个函数式接口，仅有一个 <code>postProcessBeanFactory(...)</code> 方法，该方法接收一个 ConfigurableListableBeanFactory 类型的 <code>beanFactory</code> 参数。</p><p><code>postProcessBeanFactory(...)</code> 方法，工作于 BeanDefinition 加载完成之后，Bean 实例化之前，其主要作用是对加载 BeanDefinition 进行修改。有一点需要需要<strong>注意</strong>的是在 <code>postProcessBeanFactory(...)</code> 方法中，千万不能进行 Bean 的实例化工作，因为这样会导致 Bean 过早实例化，会产生严重后果，<strong>我们始终需要注意的是 BeanFactoryPostProcessor 是与 BeanDefinition 打交道的，如果想要与 Bean 打交道，请使用 BeanPostProcessor</strong> 。</p><p>与 BeanPostProcessor 一样，BeanFactoryPostProcessor 同样支持<strong>排序</strong>，一个容器可以同时拥有多个 BeanFactoryPostProcessor ，这个时候如果我们比较在乎他们的顺序的话，可以实现 Ordered 接口。</p><p>如果要自定义 BeanFactoryPostProcessor ，直接实现该接口即可。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>直接提<code>git</code>了。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>对于 ApplicationContext 来说，使用 BeanFactoryPostProcessor 非常方便，因为他会自动识别配置文件中的 BeanFactoryPostProcessor 并且完成注册和调用，我们只需要简单的配置声明即可。而对于 BeanFactory 容器来说则不行，他和 BeanPostProcessor 一样需要容器主动去进行注册调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//T_BeanFactoryPostProcessor实现了BeanFactoryPostProcessor</span><br><span class="hljs-type">T_BeanFactoryPostProcessor</span> <span class="hljs-variable">beanFactoryPostProcessor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T_BeanFactoryPostProcessor</span>();<br>beanFactoryPostProcessor.postProcessBeanFactory(factory);<br></code></pre></td></tr></table></figure><p>一般情况下我们是不会主动去自定义 BeanFactoryPostProcessor ，其实 Spring 为我们提供了几个常用的 BeanFactoryPostProcessor，他们是<code>PropertyPlaceholderConfigurer</code> 和 <code>PropertyOverrideConfigurer</code> ，其中 <code>PropertyPlaceholderConfigurer</code> 允许我们在 XML 配置文件中使用占位符并将这些占位符所代表的资源单独配置到简单的 properties 文件中来加载，<code>PropertyOverrideConfigurer</code> 则允许我们使用占位符来明确表明bean 定义中的 property 与 properties 文件中的各配置项之间的对应关系，这两个类在我们大型项目中有非常重要的作用。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三十、IOC之Bean的生命周期</title>
    <link href="/2022/06/11/IOC%E4%B9%8BBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/06/11/IOC%E4%B9%8BBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">IOC之Bean的生命周期</font></div><p>Spring 并不是一启动容器就开启 bean 的实例化进程，只有当客户端通过显示或者隐式的方式调用 BeanFactory 的 <code>getBean(...)</code> 方法来请求某个实例对象的时候，它才会触发相应 bean 的实例化进程。当然，也可以选择直接使用 ApplicationContext 容器，因为该容器启动的时候会立刻调用注册到该容器所有 bean 定义的实例化方法。当然，对于 BeanFactory 容器而言，并不是所有的 <code>getBean(...)</code> 方法都会触发实例化进程，比如 singleton 类型的 bean，该类型的 bean 只会在第一次调用 <code>getBean()</code> 的时候才会触发，而后续的调用则会直接返回容器缓存中的实例对象。</p><p><code>getBean(...)</code> 方法，只是 bean 实例化进程的入口，真正的实现逻辑其实是在 AbstractAutowireCapableBeanFactory 的 <code>doCreateBean(...)</code> 中实现，实例化过程如下图：</p><p><img src="/images/spring_IOC/bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="bean实例化过程"></p><p>原来我们采用 new 的方式创建一个对象，用完该对象在其脱离作用域后就会被回收，对于后续操作我们无权也没法干涉，但是采用 Spring 容器后，我们完全摆脱了这种命运，Spring 容器将会对其所有管理的 Bean 对象全部给予一个<strong>统一的生命周期管理</strong>，同时在这个阶段我们也可以对其进行干涉。</p><h4 id="Bean实例化"><a href="#Bean实例化" class="headerlink" title="Bean实例化"></a>Bean实例化</h4><p>在 <code>doCreateBean(...)</code> 方法中，首先进行 bean 实例化工作，主要由 <code>createBeanInstance(...)</code> 方法实现，该方法返回一个 BeanWrapper 对象。BeanWrapper 对象是 Spring 的一个低级 Bean 基础结构的核心接口，为什么说是<strong>低级</strong>呢？因为这个时候的 Bean 还不能够被我们使用，连最基本的属性都没有设置。而且在我们实际开发过程中，一般都不会直接使用该类，而是通过 BeanFactory 隐式使用。</p><p>BeanWrapper 接口有一个默认实现类 BeanWrapperImpl，其主要作用是对 Bean 进行“包裹”，然后对这个包裹的 bean 进行操作，比如后续注入 bean 属性。</p><p>在实例化 bean 过程中，Spring 采用“<code>策略模式</code>”来决定采用哪种方式来实例化 bean，一般有<code>反射</code>和 <code>CGLIB</code> 动态字节码两种方式。</p><p>InstantiationStrategy 定义了 Bean 实例化策略的抽象接口，其子类 SimpleInstantiationStrategy 提供了基于反射来实例化对象的功能，但是不支持方法注入方式的对象实例化。CglibSubclassingInstantiationStrategy 继承 SimpleInstantiationStrategy，他除了拥有父类以反射实例化对象的功能外，还提供了通过 CGLIB 的动态字节码的功能进而支持方法注入所需的对象实例化需求。默认情况下，Spring 采用 CglibSubclassingInstantiationStrategy。</p><p>查看<code>20-25</code>。</p><h4 id="激活Aware"><a href="#激活Aware" class="headerlink" title="激活Aware"></a>激活Aware</h4><p>当 Spring 完成 bean 对象实例化并且设置完相关属性和依赖后，则会开始 bean 的初始化进程（ <code>initializeBean()</code> ），初始化第一个阶段是检查当前 bean 对象是否实现了一系列以 Aware 结尾的的接口。</p><p>Aware 接口为 Spring 容器的核心接口，是一个具有标识作用的超级接口，实现了该接口的 bean 是具有被 Spring 容器通知的能力，通知的方式是采用回调的方式。</p><p>在初始化阶段主要是感知 BeanNameAware、BeanClassLoaderAware、BeanFactoryAware 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeAwareMethods</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> Object bean)</span> &#123;<br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Aware) &#123;<br>    <span class="hljs-comment">// BeanNameAware</span><br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanNameAware) &#123;<br>((BeanNameAware) bean).setBeanName(beanName);<br>&#125;<br><span class="hljs-comment">// BeanClassLoaderAware</span><br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanClassLoaderAware) &#123;<br><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">bcl</span> <span class="hljs-operator">=</span> getBeanClassLoader();<br><span class="hljs-keyword">if</span> (bcl != <span class="hljs-literal">null</span>) &#123;<br>((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);<br>&#125;<br>&#125;<br><span class="hljs-comment">// BeanFactoryAware</span><br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanFactoryAware) &#123;<br>((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="hljs-built_in">this</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>BeanNameAware：对该 bean 对象定义的 beanName 设置到当前对象实例中</li><li>BeanClassLoaderAware：将当前 bean 对象相应的 ClassLoader 注入到当前对象实例中</li><li>BeanFactoryAware：BeanFactory 容器会将自身注入到当前对象实例中，这样当前对象就会拥有一个 BeanFactory 容器的引用。</li></ul><p>当然，Spring 不仅仅只是提供了上面三个 Aware 接口，而是一系列：</p><ul><li>LoadTimeWeaverAware：加载Spring Bean时织入第三方模块，如AspectJ</li><li>BootstrapContextAware：资源适配器BootstrapContext，如JCA,CCI</li><li>ResourceLoaderAware：底层访问资源的加载器</li><li>PortletConfigAware：PortletConfig</li><li>PortletContextAware：PortletContext</li><li>ServletConfigAware：ServletConfig</li><li>ServletContextAware：ServletContext</li><li>MessageSourceAware：国际化</li><li>ApplicationEventPublisherAware：应用事件</li><li>NotificationPublisherAware：JMX通知</li></ul><h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a><code>BeanPostProcessor</code></h4><p>初始化第二个阶段则是 BeanPostProcessor 增强处理，在该阶段 BeanPostProcessor 会处理当前容器内所有符合条件的实例化后的 bean 对象。它主要是对 Spring 容器提供��� bean 实例对象进行有效的扩展，允许 Spring 在初始化 bean 阶段对其进行定制化修改，如处理标记接口或者为其提供代理实现。</p><p>BeanPostProcessor 接口提供了两个方法，在不同的时机执行，分别对应上图的前置处理和后置处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">default</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">default</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="InitializingBean-和-init-method"><a href="#InitializingBean-和-init-method" class="headerlink" title="InitializingBean 和 init-method"></a><code>InitializingBean</code> 和 <code>init-method</code></h4><p>InitializingBean 是一个接口，它为 Spring Bean 的初始化提供了一种方式，它有一个 <code>afterPropertiesSet()</code> 方法，在 bean 的初始化进程中会判断当前 bean 是否实现了 InitializingBean，如果实现了则调用 <code>afterPropertiesSet()</code> 方法，进行初始化工作。然后再检查是否也指定了 <code>init-method</code> ，如果指定了则通过反射机制调用指定的 <code>init-method</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeInitMethods</span><span class="hljs-params">(String beanName, <span class="hljs-keyword">final</span> Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span><br><span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// 首先会检查是否是 InitializingBean ，如果是的话需要调用 afterPropertiesSet()</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isInitializingBean</span> <span class="hljs-operator">=</span> (bean <span class="hljs-keyword">instanceof</span> InitializingBean);<br><span class="hljs-keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="hljs-literal">null</span> || !mbd.isExternallyManagedInitMethod(<span class="hljs-string">&quot;afterPropertiesSet&quot;</span>))) &#123;<br><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>logger.trace(<span class="hljs-string">&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 安全模式</span><br><span class="hljs-keyword">try</span> &#123;<br>AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;<br>                    <span class="hljs-comment">// 属性初始化的处理</span><br>((InitializingBean) bean).afterPropertiesSet();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;, getAccessControlContext());<br>&#125; <span class="hljs-keyword">catch</span> (PrivilegedActionException pae) &#123;<br><span class="hljs-keyword">throw</span> pae.getException();<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 属性初始化的处理</span><br>((InitializingBean) bean).afterPropertiesSet();<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (mbd != <span class="hljs-literal">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;<br>        <span class="hljs-comment">// 判断是否指定了 init-method()，</span><br>        <span class="hljs-comment">// 如果指定了 init-method()，则再调用制定的init-method</span><br><span class="hljs-type">String</span> <span class="hljs-variable">initMethodName</span> <span class="hljs-operator">=</span> mbd.getInitMethodName();<br><span class="hljs-keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;<br>!(isInitializingBean &amp;&amp; <span class="hljs-string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;<br>!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;<br>            <span class="hljs-comment">// 激活用户自定义的初始化方法</span><br>            <span class="hljs-comment">// 利用反射机制执行</span><br>invokeCustomInitMethod(beanName, bean, mbd);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 Spring 而言，虽然上面两种方式都可以实现初始化定制化，但是更加推崇 <code>init-method</code> 方式，因为对于 InitializingBean 接口而言，他需要 bean 去实现接口，这样就会污染我们的应用程序，显得 Spring 具有一定的侵入性。但是由于 <code>init-method</code> 是采用反射的方式，所以执行效率上相对于 InitializingBean 接口回调的方式可能会低一些。</p><h4 id="DisposableBean-和-destroy-method"><a href="#DisposableBean-和-destroy-method" class="headerlink" title="DisposableBean 和 destroy-method"></a><code>DisposableBean</code> 和 <code>destroy-method</code></h4><p>与 InitializingBean 和 <code>init-method</code> 用于对象的自定义初始化工作相似，DisposableBean和 <code>destroy-method</code> 则用于对象的自定义销毁工作。</p><p>当一个 bean 对象经历了实例化、设置属性、初始化阶段，那么该 bean 对象就可以供容器使用了（调用的过程）。当完成调用后，如果是 singleton 类型的 bean ，则会看当前 bean 是否应实现了 DisposableBean 接口或者配置了 <code>destroy-method</code> 属性，如果是的话，则会为该实例注册一个用于对象销毁的回调方法，便于在这些 singleton 类型的 bean 对象销毁之前执行销毁逻辑。</p><p>但是，并不是对象完成调用后就会立刻执行销毁方法，因为这个时候 Spring 容器还处于运行阶段，只有当 Spring 容器关闭的时候才会去调用。但是， Spring 容器不会这么聪明会自动去调用这些销毁方法，而是需要我们主动去告知 Spring 容器。</p><ul><li>对于 BeanFactory 容器而言，我们需要主动调用 <code>destroySingletons()</code> 方法，通知 BeanFactory 容器去执行相应的销毁方法。</li><li>对于 ApplicationContext 容器而言，调用 <code>registerShutdownHook()</code> 方法。</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LifeCycleBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanNameAware</span>, BeanFactoryAware, BeanClassLoaderAware, BeanPostProcessor, InitializingBean, DisposableBean &#123;<br><span class="hljs-keyword">private</span> String test;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTest</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> test;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTest</span><span class="hljs-params">(String test)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;属性注入....&quot;</span>);<br><span class="hljs-built_in">this</span>.test = test;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LifeCycleBean</span><span class="hljs-params">(String test)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;有参构造函数调用...&quot;</span>);<br><span class="hljs-built_in">this</span>.test = test;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LifeCycleBean</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;无参构造函数调用...&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;方法调用...&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanClassLoader</span><span class="hljs-params">(ClassLoader classLoader)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;BeanClassLoaderAware 被调用...&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>System.out.println(<span class="hljs-string">&quot;BeanFactoryAware 被调用...&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanName</span><span class="hljs-params">(String name)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;BeanNameAware 被调用...&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;DisposableBean destroy 被调动...&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;InitializingBean afterPropertiesSet 被调动...&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>System.out.println(<span class="hljs-string">&quot;BeanPostProcessor postProcessBeforeInitialization 被调用...&quot;</span>);<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>System.out.println(<span class="hljs-string">&quot;BeanPostProcessor postProcessAfterInitialization 被调用...&quot;</span>);<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initMethod</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;init-method 被调用...&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroyMethod</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;destroy-method 被调用...&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lifeCycle&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jievhaha.LifeCycleBean&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;initMethod&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroyMethod&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;test&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">ClassPathResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultListableBeanFactory</span>();<br><span class="hljs-type">XmlBeanDefinitionReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanDefinitionReader</span>(factory);<br><span class="hljs-type">LifeCycleBean</span> <span class="hljs-variable">lifeCycleBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LifeCycleBean</span>();<br>        <span class="hljs-comment">// BeanFactory 容器一定要调用该方法进行 BeanPostProcessor 注册</span><br>factory.addBeanPostProcessor(lifeCycleBean);<br>reader.loadBeanDefinitions(resource);<br><span class="hljs-type">LifeCycleBean</span> <span class="hljs-variable">lifeCycleBean1</span> <span class="hljs-operator">=</span> (LifeCycleBean) factory.getBean(<span class="hljs-string">&quot;lifeCycle&quot;</span>);<br>lifeCycleBean1.display();<br>System.out.println(<span class="hljs-string">&quot;方法调用完成，容器开始关闭....&quot;</span>);<br>        <span class="hljs-comment">// 关闭容器</span><br>factory.destroySingletons();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml">无参构造函数调用...//要注入BeanPostProcessor<br>无参构造函数调用...//自己getBean<br>属性注入....<br>BeanNameAware 被调用...<br>BeanClassLoaderAware 被调用...<br>BeanFactoryAware 被调用...<br>BeanPostProcessor postProcessBeforeInitialization 被调用...<br>InitializingBean afterPropertiesSet 被调动...<br>init-method 被调用...<br>BeanPostProcessor postProcessAfterInitialization 被调用...<br>方法调用...<br>方法调用完成，容器开始关闭....<br>DisposableBean destroy 被调动...<br>destroy-method 被调用...<br></code></pre></td></tr></table></figure><p>总结，Spring Bean 的声明周期过程如下：</p><ol><li>Spring 容器根据实例化策略对 Bean 进行实例化。</li><li>实例化完成后，如果该 bean 设置了一些属性的话，则利用 set 方法设置一些属性。</li><li>如果该 Bean 实现了 BeanNameAware 接口，则调用 <code>setBeanName(String beanName)</code> 方法。</li><li>如果该 bean 实现了 BeanClassLoaderAware 接口，则调用 <code>setBeanClassLoader(ClassLoader classLoader)</code> 方法。</li><li>如果该 bean 实现了 BeanFactoryAware接口，则调用 <code>setBeanFactory(BeanFactory beanFactory)</code> 方法。</li><li>如果该容器注册了 BeanPostProcessor，则会调用<code>postProcessBeforeInitialization(Object bean, String beanName)</code> 方法,完成 bean 前置处理</li><li>如果该 bean 实现了 InitializingBean 接口，则调用<code>afterPropertiesSet()</code> 方法。</li><li>如果该 bean 配置了 <code>init-method</code> 方法，则调用其指定的方法。</li><li>初始化完成后，如果该容器注册了 BeanPostProcessor 则会调用 <code>postProcessAfterInitialization(Object bean, String beanName)</code> 方法,完成 bean 的后置处理。</li><li>对象完成初始化，开始方法调用。</li><li>在容器进行关闭之前，如果该 bean 实现了 DisposableBean 接口，则调用 <code>destroy()</code> 方法。</li><li>在容器进行关闭之前，如果该 bean 配置了 <code>destroy-method</code> ，则调用其指定的方法。</li><li>到这里一个 bean 也就完成了它的一生。</li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二十八、IOC之BeanPostProcessor</title>
    <link href="/2022/06/11/IOC%E4%B9%8BBeanPostProcessor/"/>
    <url>/2022/06/11/IOC%E4%B9%8BBeanPostProcessor/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">IOC之BeanPostProcessor</font></div><h4 id="BeanPostProcessor接口"><a href="#BeanPostProcessor接口" class="headerlink" title="BeanPostProcessor接口"></a><code>BeanPostProcessor</code>接口</h4><p>除了<code>Aware</code>这个扩展点，还有<code>BeanPostProcessor</code>，BeanPostProcessor 的作用：在 Bean 完成实例化后，如果我们需要对其进行一些配置、增加一些自己的处理逻辑，那么请使用 BeanPostProcessor。</p><h4 id="BeanPostProcessor实例"><a href="#BeanPostProcessor实例" class="headerlink" title="BeanPostProcessor实例"></a><code>BeanPostProcessor</code>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>System.out.println(<span class="hljs-string">&quot;Bean[&quot;</span> + beanName + <span class="hljs-string">&quot;]开始初始化&quot;</span>);<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>System.out.println(<span class="hljs-string">&quot;Bean[&quot;</span> + beanName + <span class="hljs-string">&quot;]完成初始化&quot;</span>);<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Hello BeanPostProcessor...&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testBeanPostProcessor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jievhaha.TestBeanPostProcessor&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">ClassPathResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultListableBeanFactory</span>();<br><span class="hljs-type">XmlBeanDefinitionReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanDefinitionReader</span>(factory);<br>reader.loadBeanDefinitions(resource);<br><span class="hljs-type">TestBeanPostProcessor</span> <span class="hljs-variable">testBeanPostProcessor</span> <span class="hljs-operator">=</span> (TestBeanPostProcessor) factory.getBean(<span class="hljs-string">&quot;testBeanPostProcessor&quot;</span>);<br>testBeanPostProcessor.display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">Hello BeanPostProcessor...<br></code></pre></td></tr></table></figure><p>并没有执行前置、后置处理器。</p><p>在<code>AbstractAutowireCapableBeanFactory.initializeBean()</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">initializeBean</span><span class="hljs-params">(String beanName, Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;<br>    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 安全模式</span><br>        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;<br>            <span class="hljs-comment">// &lt;1&gt; 激活 Aware 方法，对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware</span><br>            invokeAwareMethods(beanName, bean);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;, getAccessControlContext());<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// &lt;1&gt; 激活 Aware 方法，对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware</span><br>        invokeAwareMethods(beanName, bean);<br>    &#125;<br>    <span class="hljs-comment">// &lt;2&gt; 后置处理器，before</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">wrappedBean</span> <span class="hljs-operator">=</span> bean;<br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;3&gt; 激活用户自定义的 init 方法</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        invokeInitMethods(beanName, wrappedBean, mbd);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>            (mbd != <span class="hljs-literal">null</span> ? mbd.getResourceDescription() : <span class="hljs-literal">null</span>),<br>            beanName, <span class="hljs-string">&quot;Invocation of init method failed&quot;</span>, ex);<br>    &#125;<br>    <span class="hljs-comment">// &lt;2&gt; 后置处理器，after</span><br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> wrappedBean;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">applyBeanPostProcessorsBeforeInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> existingBean;<br>    <span class="hljs-comment">// 遍历 BeanPostProcessor 数组</span><br>    <span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;<br>        <span class="hljs-comment">// 处理</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> processor.postProcessBeforeInitialization(result, beanName);<br>        <span class="hljs-comment">// 返回空，则返回 result</span><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-comment">// 修改 result</span><br>        result = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><span class="hljs-keyword">public</span> List&lt;BeanPostProcessor&gt; <span class="hljs-title function_">getBeanPostProcessors</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.beanPostProcessors;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;BeanPostProcessor&gt; beanPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanPostProcessorCacheAwareList</span>();<br></code></pre></td></tr></table></figure><p>断点中可以查看到<code>getBeanPostProcessors()</code>的<code>size</code>为0。 </p><p>所以要想执行前置处理器就要保证该<code>List</code>不为空，那就要有<code>this.beanPostProcessors.add()</code>的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractBeanFactory.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBeanPostProcessor</span><span class="hljs-params">(BeanPostProcessor beanPostProcessor)</span> &#123;<br>    Assert.notNull(beanPostProcessor, <span class="hljs-string">&quot;BeanPostProcessor must not be null&quot;</span>);<br>    <span class="hljs-built_in">this</span>.beanPostProcessors.remove(beanPostProcessor);<br>    <span class="hljs-built_in">this</span>.beanPostProcessors.add(beanPostProcessor);<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法是由 AbstractBeanFactory 的父类 <code>org.springframework.beans.factory.config.ConfigurableBeanFactory</code> 接口定义，它的核心意思就是将指定 BeanPostProcessor 注册到该 BeanFactory 创建的 bean 中，同时它是<strong>按照插入的顺序进行注册的</strong>，完全忽略 Ordered 接口所表达任何排序语义（在 BeanPostProcessor 中我们提供一个 Ordered 顺序）。</p><p>所以要可以执行前后置处理器，只需增加如下步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TestBeanPostProcessor</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestBeanPostProcessor</span>();<br>factory.addBeanPostProcesssor(test)。<br>    <br>    <br><span class="hljs-type">ClassPathResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultListableBeanFactory</span>();<br><span class="hljs-type">XmlBeanDefinitionReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanDefinitionReader</span>(factory);<br><span class="hljs-type">TestBeanPostProcessor</span> <span class="hljs-variable">beanPostProcessor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestBeanPostProcessor</span>();<br>factory.addBeanPostProcessor(beanPostProcessor);<br>reader.loadBeanDefinitions(resource);<br><span class="hljs-type">TestBeanPostProcessor</span> <span class="hljs-variable">testBeanPostProcessor</span> <span class="hljs-operator">=</span> (TestBeanPostProcessor) factory.getBean(<span class="hljs-string">&quot;testBeanPostProcessor&quot;</span>);<br>testBeanPostProcessor.display();<br></code></pre></td></tr></table></figure><p>这样，使用该factory创建任何Bean都会执行前后置处理器，ApplicationContext方法不需手动注册，会自动检测所有BeanPostProcessor然后进行自动注册（都已测试）。</p><p>总结：一般普通的 BeanFactory 是不支持自动注册 BeanPostProcessor 的，需要我们手动调用 <code>addBeanPostProcessor(BeanPostProcessor beanPostProcessor)</code> 方法进行注册。注册后的 BeanPostProcessor 适用于所有该 BeanFactory 创建的 bean，但是 <strong>ApplicationContext 可以在其 bean 定义中自动检测所有的 BeanPostProcessor 并自动完成注册，同时将他们应用到随后创建的任何 Bean 中</strong>。</p><h4 id="BeanPostProcessor基本原理"><a href="#BeanPostProcessor基本原理" class="headerlink" title="BeanPostProcessor基本原理"></a><code>BeanPostProcessor</code>基本原理</h4><p><code>BeanPostProcessor</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">default</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">default</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>BeanPostProcessor 可以理解为是 Spring 的一个工厂钩子（其实 Spring 提供一系列的钩子，如 Aware 、InitializingBean、DisposableBean），它是 Spring 提供的对象实例化阶段强有力的扩展点，允许 Spring 在实例化 bean 阶段对其进行定制化修改，比较常见的使用场景是处理标记接口实现类或者为当前对象提供代理实现（例如 AOP）。</p><p><code>postProcessBeforeInitialization(Object bean, String beanName)</code> 和 <code>postProcessAfterInitialization(Object bean, String beanName)</code> 两个方法，都接收一个 Object 类型的 <code>bean</code> ，一个 String 类型的 <code>beanName</code> ，其中 <code>bean</code> 是已经实例化了的 <code>instanceBean</code> ，能拿到这个你是不是可以对它为所欲为了？ 这两个方法是初始化 <code>bean</code> 的前后置处理器，他们应用 <code>invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)</code> 方法的前后。</p><p><img src="/images/spring_IOC/%E5%89%8D%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8.png" alt="前后置处理器"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">initializeBean</span><span class="hljs-params">(String beanName, Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;<br>    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 安全模式</span><br>        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;<br>            <span class="hljs-comment">// &lt;1&gt; 激活 Aware 方法，对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware</span><br>            invokeAwareMethods(beanName, bean);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;, getAccessControlContext());<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// &lt;1&gt; 激活 Aware 方法，对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware</span><br>        invokeAwareMethods(beanName, bean);<br>    &#125;<br>    <span class="hljs-comment">// &lt;2&gt; 后置处理器，before</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">wrappedBean</span> <span class="hljs-operator">=</span> bean;<br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>    &#125;<br><br>    <span class="hljs-comment">// &lt;3&gt; 激活用户自定义的 init 方法</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        invokeInitMethods(beanName, wrappedBean, mbd);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>            (mbd != <span class="hljs-literal">null</span> ? mbd.getResourceDescription() : <span class="hljs-literal">null</span>),<br>            beanName, <span class="hljs-string">&quot;Invocation of init method failed&quot;</span>, ex);<br>    &#125;<br>    <span class="hljs-comment">// &lt;2&gt; 后置处理器，after</span><br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> wrappedBean;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">applyBeanPostProcessorsBeforeInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> existingBean;<br>    <span class="hljs-comment">// 遍历 BeanPostProcessor 数组</span><br>    <span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;<br>        <span class="hljs-comment">// 处理</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> processor.postProcessBeforeInitialization(result, beanName);<br>        <span class="hljs-comment">// 返回空，则返回 result</span><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-comment">// 修改 result</span><br>        result = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">applyBeanPostProcessorsAfterInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span><br>    <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> existingBean;<br>    <span class="hljs-comment">// 遍历 BeanPostProcessor</span><br>    <span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;<br>        <span class="hljs-comment">// 处理</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> processor.postProcessAfterInitialization(result, beanName);<br>        <span class="hljs-comment">// 返回空，则返回 result</span><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        result = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="自动检测并注册"><a href="#自动检测并注册" class="headerlink" title="自动检测并注册"></a>自动检测并注册</h5><p><code>getBeanPostProcessors()</code> 方法，返回的是 <code>beanPostProcessors</code> 集合，该集合里面存放就是我们自定义的 BeanPostProcessor ，如果该集合中存在元素则调用相应的方法，否则就直接返回 bean 了。这也是为什么使用 BeanFactory 容器是无法输出自定义 BeanPostProcessor 里面的内容，因为在 <code>BeanFactory.getBean(...)</code> 方法的过程中根本就没有将我们自定义的 BeanPostProcessor 注入进来，所以要想 BeanFactory 容器 的 BeanPostProcessor 生效我们必须手动调用 <code>addBeanPostProcessor(BeanPostProcessor beanPostProcessor)</code> 方法，将定义的 BeanPostProcessor 注册到相应的 BeanFactory 中。<strong>但是 ApplicationContext 不需要手动，因为 ApplicationContext 会自动检测并完成注册</strong>。</p><p>ApplicationContext 实现自动注册的原因，在于我们构造一个 ApplicationContext 实例对象的时候会调用 <code>AbstractApplicationContext.registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory)</code> 方法，将检测到的 BeanPostProcessor 注入到 ApplicationContext 容器中，同时应用到该容器创建的 bean 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractApplicationContext.java</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实例化并调用已经注入的 BeanPostProcessor</span><br><span class="hljs-comment"> * 必须在应用中 bean 实例化之前调用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanPostProcessors</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;<br>    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// PostProcessorRegistrationDelegate.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanPostProcessors</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> &#123;<br>    <span class="hljs-comment">// 获取所有的 BeanPostProcessor 的 beanName</span><br>    <span class="hljs-comment">// 这些 beanName 都已经全部加载到容器中去，但是没有实例化</span><br>    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-comment">// 记录所有的beanProcessor数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">beanProcessorTargetCount</span> <span class="hljs-operator">=</span> beanFactory.getBeanPostProcessorCount() + <span class="hljs-number">1</span> + postProcessorNames.length;<br>    <span class="hljs-comment">// 注册 BeanPostProcessorChecker，它主要是用于在 BeanPostProcessor 实例化期间记录日志</span><br>    <span class="hljs-comment">// 当 Spring 中高配置的后置处理器还没有注册就已经开始了 bean 的实例化过程，这个时候便会打印 BeanPostProcessorChecker 中的内容</span><br>    beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanPostProcessorChecker</span>(beanFactory, beanProcessorTargetCount));<br><br>    <span class="hljs-comment">// PriorityOrdered 保证顺序</span><br>    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 使用 Ordered 保证顺序</span><br>    List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 没有顺序</span><br>    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>        <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>            <span class="hljs-comment">// 调用 getBean 获取 bean 实例对象</span><br>            <span class="hljs-type">BeanPostProcessor</span> <span class="hljs-variable">pp</span> <span class="hljs-operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);<br>            priorityOrderedPostProcessors.add(pp);<br>            <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;<br>                internalPostProcessors.add(pp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br>            <span class="hljs-comment">// 有序 Ordered</span><br>            orderedPostProcessorNames.add(ppName);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 无序</span><br>            nonOrderedPostProcessorNames.add(ppName);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 第一步，注册所有实现了 PriorityOrdered 的 BeanPostProcessor</span><br>    <span class="hljs-comment">// 先排序</span><br>    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);<br>    <span class="hljs-comment">// 后注册</span><br>    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);<br><br>    <span class="hljs-comment">// 第二步，注册所有实现了 Ordered 的 BeanPostProcessor</span><br>    List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());<br>    <span class="hljs-keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;<br>        <span class="hljs-type">BeanPostProcessor</span> <span class="hljs-variable">pp</span> <span class="hljs-operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);<br>        orderedPostProcessors.add(pp);<br>        <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;<br>            internalPostProcessors.add(pp);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 先排序</span><br>    sortPostProcessors(orderedPostProcessors, beanFactory);<br>    <span class="hljs-comment">// 后注册</span><br>    registerBeanPostProcessors(beanFactory, orderedPostProcessors);<br><br>    <span class="hljs-comment">// 第三步注册所有无序的 BeanPostProcessor</span><br>    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());<br>    <span class="hljs-keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;<br>        <span class="hljs-type">BeanPostProcessor</span> <span class="hljs-variable">pp</span> <span class="hljs-operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);<br>        nonOrderedPostProcessors.add(pp);<br>        <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;<br>            internalPostProcessors.add(pp);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 注册，无需排序</span><br>    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);<br><br>    <span class="hljs-comment">// 最后，注册所有的 MergedBeanDefinitionPostProcessor 类型的 BeanPostProcessor</span><br>    sortPostProcessors(internalPostProcessors, beanFactory);<br>    registerBeanPostProcessors(beanFactory, internalPostProcessors);<br><br>    <span class="hljs-comment">// 加入ApplicationListenerDetector（探测器）</span><br>    <span class="hljs-comment">// 重新注册 BeanPostProcessor 以检测内部 bean，因为 ApplicationListeners 将其移动到处理器链的末尾</span><br>    beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationListenerDetector</span>(applicationContext));<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑：</p><ul><li>首先 <code>beanFactory</code> 获取注册到该 BeanFactory 中所有 BeanPostProcessor 类型的 <code>beanName</code> 数组，其实就是找所有实现了 BeanPostProcessor 接口的 bean ，然后迭代这些 bean ，将其按照 PriorityOrdered、Ordered、无序的顺序，添加至相应的 List 集合中，最后依次调用 <code>sortPostProcessors(List postProcessors, ConfigurableListableBeanFactory beanFactory)</code> 方法来进行排序处理、 <code>registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory, List postProcessors)</code> 方法来完成注册。</li><li><strong>排序</strong>很简单，如果 <code>beanFactory</code> 为 DefaultListableBeanFactory ，则返回 BeanFactory 所依赖的比较器，否则反正默认的比较器(OrderComparator)，然后调用 <code>Listsort(Comparator c)</code> 方法即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PostProcessorRegistrationDelegate.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortPostProcessors</span><span class="hljs-params">(List&lt;?&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)</span> &#123;<br>    <span class="hljs-comment">// Nothing to sort?</span><br>    <span class="hljs-keyword">if</span> (postProcessors.size() &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获得 Comparator 对象</span><br>    Comparator&lt;Object&gt; comparatorToUse = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> DefaultListableBeanFactory) &#123;<span class="hljs-comment">// 依赖的 Comparator 对象</span><br>        comparatorToUse = ((DefaultListableBeanFactory) beanFactory).getDependencyComparator();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (comparatorToUse == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 默认 Comparator 对象</span><br>        comparatorToUse = OrderComparator.INSTANCE;<br>    &#125;<br>    <span class="hljs-comment">// 排序</span><br>    postProcessors.sort(comparatorToUse);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>注册</strong>同样是调用 <code>AbstractBeanFactory.addBeanPostProcessor(BeanPostProcessor beanPostProcessor)</code> 方法完成注册。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanPostProcessors</span><span class="hljs-params">(</span><br><span class="hljs-params">    ConfigurableListableBeanFactory beanFactory, List&lt;BeanPostProcessor&gt; postProcessors)</span> &#123;<br><br>    <span class="hljs-comment">// 如果是AbstractBeanFactory，直接全部注册</span><br>    <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory) &#123;<br>        <span class="hljs-comment">// Bulk addition is more efficient against our CopyOnWriteArrayList there</span><br>        ((AbstractBeanFactory) beanFactory).addBeanPostProcessors(postProcessors);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 遍历 BeanPostProcessor 数组，注册</span><br>        <span class="hljs-keyword">for</span> (BeanPostProcessor postProcessor : postProcessors) &#123;<br>            beanFactory.addBeanPostProcessor(postProcessor);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>BeanPostProcessor 的作用域是容器级别的，它只和所在的容器相关 ，当 BeanPostProcessor 完成注册后，它会应用于所有跟它在同一个容器内的 bean 。</li><li>BeanFactory 和 ApplicationContext 对 BeanPostProcessor 的处理不同，ApplicationContext 会自动检测所有实现了 BeanPostProcessor 接口的 bean，并完成注册，但是使用 BeanFactory 容器时则需要手动调用 <code>AbstractBeanFactory.addBeanPostProcessor(BeanPostProcessor beanPostProcessor)</code> 方法来完成注册</li><li>ApplicationContext 的 BeanPostProcessor 支持 Ordered，而 BeanFactory 的 BeanPostProcessor 是不支持的，原因在于ApplicationContext 会对 BeanPostProcessor 进行 Ordered 检测并完成排序，而 BeanFactory 中的 BeanPostProcessor 只跟注册的顺序有关。</li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装</title>
    <link href="/2022/06/11/Docker%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/"/>
    <url>/2022/06/11/Docker%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">Docker安装</font></div><h4 id="移除旧版本"><a href="#移除旧版本" class="headerlink" title="移除旧版本"></a>移除旧版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-selinux \<br>                  docker-engine-selinux \<br>                  docker-engine<br></code></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h5 id="安装所需的软件包，并配置仓库。"><a href="#安装所需的软件包，并配置仓库。" class="headerlink" title="安装所需的软件包，并配置仓库。"></a>安装所需的软件包，并配置仓库。</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install -y yum-utils device-mapper-persistent-data lvm2<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><h5 id="更新yum缓存"><a href="#更新yum缓存" class="headerlink" title="更新yum缓存"></a>更新yum缓存</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum makecache fast<br></code></pre></td></tr></table></figure><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl start docker<br><span class="hljs-meta prompt_">#</span><span class="language-bash">或者</span><br>sudo service docker start<br></code></pre></td></tr></table></figure><p>运行hello-world，第一次运行会提示本地没有该镜像，然后会自动下载运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run hello-world<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">Unable to find image &#x27;hello-world:latest&#x27; locally    //本地没有这个镜像<br>latest: Pulling from library/hello-world   //从远程拉取镜像<br><br>c04b14da8d14: Pull complete<br>Digest: sha256:0256e8a36e2070f7bf2d0b0763dbabdd67798512411de4cdcf9431a1feb60fd9<br>Status: Downloaded newer image for hello-world:latest<br></code></pre></td></tr></table></figure><h4 id="卸载Docker"><a href="#卸载Docker" class="headerlink" title="卸载Docker"></a>卸载Docker</h4><p>卸载依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum remove docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><p>删除资源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf /var/lib/docker<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker容器修改映射路径</title>
    <link href="/2022/06/11/Docker%E5%AE%B9%E5%99%A8%E4%BF%AE%E6%94%B9%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/06/11/Docker%E5%AE%B9%E5%99%A8%E4%BF%AE%E6%94%B9%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">Docker容器修改映射路径</font></div><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>容器已安装运行，后续想要更改映射目录，但又不想删除容器重新运行。</p><p><strong>注：</strong> <em>切记一定先关闭docker（已测试，单独关闭容器，或者关闭容器，修改完成后再重启docker都会导致修改不生效）。</em></p><p>以下以修改mongodb容器为例。</p><h3 id="查看容器id"><a href="#查看容器id" class="headerlink" title="查看容器id"></a>查看容器id</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker ps</span><br></code></pre></td></tr></table></figure><p><img src="/images/docker/%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8id.jpg" alt="查看容器id"></p><h3 id="根据容器id查看容器在宿主机的目录"><a href="#根据容器id查看容器在宿主机的目录" class="headerlink" title="根据容器id查看容器在宿主机的目录"></a>根据容器id查看容器在宿主机的目录</h3><p>如果知道具体的容器，不需查看容器id，直接执行如下：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker inspect mongodb</span><br></code></pre></td></tr></table></figure><p><img src="/images/docker/%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%9C%A8%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%9B%AE%E5%BD%95.jpg" alt="查看容器在宿主机的目录"></p><p>根据结果可以看到容器id为<kbd>95ccc7be...</kbd>，接着往下可以看到容器在宿主机的映射目录<kbd>/var/lib/docker/containers/95ccc7be33f964...</kbd>。</p><h3 id="修改配置文件中的映射目录"><a href="#修改配置文件中的映射目录" class="headerlink" title="修改配置文件中的映射目录"></a>修改配置文件中的映射目录</h3><ol><li><p>进入上步查询到的目录，查看内容列表。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/docker/</span>containers/<span class="hljs-number">95</span>ccc7be33f96443c98c4c4f0b57d8631b2dab9f6e0903fc5fc8ba5f4bf45612<br><br>ll或者ls<br></code></pre></td></tr></table></figure><p>可以查看到<kbd>config.v2.json</kbd>和<kbd>hostconfig.json</kbd>两个文件，也是本次需要修改的两个配置文件，切记备份再修改。</p><p><img src="/images/docker/%E6%9F%A5%E7%9C%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.jpg" alt="查看配置文件"></p></li><li><p>修改<kbd>config.v2.json</kbd>文件</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">vim config.v2.json<br></code></pre></td></tr></table></figure><p>可以看到文件内容没有格式，故需在查看模式下格式化该文件内容。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">:%!<span class="hljs-keyword">python</span> -m json.tool<br></code></pre></td></tr></table></figure><p>找到映射目录模块，<kbd>MountPoints</kbd>处即为映射目录，映射内容如下</p><p><img src="/images/docker/%E4%BF%AE%E6%94%B9config.v2.png" alt="修改config.v2"></p><p>根据标记的内容，根据所需修改对应路径（宿主机目录，还是容器内部路径）</p></li><li><p>修改<kbd>hostconfig.json</kbd>文件</p><p>执行如上命令，可查看内容如下。</p><p><img src="/images/docker/%E4%BF%AE%E6%94%B9hostconfig.jpg" alt="修改hostconfig"></p><p>修改映射目录和<kbd>config.v2.json</kbd>目录一致。</p></li></ol><h3 id="重启docker及容器"><a href="#重启docker及容器" class="headerlink" title="重启docker及容器"></a>重启docker及容器</h3><p><strong>注：</strong> <em>重启备份文件内容</em></p><p>因为我是修改了对应的容器数据目录，故先把容器待映射目录数据拷贝出来。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker cp mongodb:<span class="hljs-regexp">/data/</span>db <span class="hljs-regexp">/etc/</span>local<span class="hljs-regexp">/docker/m</span>ongodb/data<br></code></pre></td></tr></table></figure><p>重启即可，重新查看修改后目录。</p><p><img src="/images/docker/%E4%BF%AE%E6%94%B9%E6%88%90%E5%8A%9F.jpg" alt="修改成功"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二十七、IOC之Aware接口</title>
    <link href="/2022/06/11/IOC%E4%B9%8BAware%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/06/11/IOC%E4%B9%8BAware%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">IOC之Aware接口</font></div><p>AbstractAutowireCapableBeanFactory 的 <code>doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)</code> 方法，主要干三件事情：</p><ol><li>实例化 bean 对象：<code>createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args)</code> 方法。</li><li>属性注入：<code>populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</code> 方法。</li><li>初始化 bean 对象：<code>initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd)</code> 方法。</li></ol><p>而初始化 bean 对象时，也是干了三件事情：</p><ol><li>激活 Aware 方法</li><li>后置处理器的应用</li><li>激活自定义的 init 方法</li></ol><h4 id="Aware接口"><a href="#Aware接口" class="headerlink" title="Aware接口"></a><code>Aware</code>接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Aware</span> &#123;<br>    <span class="hljs-comment">// 空接口</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Aware 接口为 Spring 容器的核心接口，是一个具有标识作用的超级接口，实现了该接口的 bean 是具有被 Spring 容器通知的能力，通知的方式是采用<strong>回调</strong>的方式。</p><p>Aware 接口为 Spring 容器的核心接口，是一个具有标识作用的超级接口，实现了该接口的 bean 是具有被 Spring 容器通知的能力，通知的方式是采用<strong>回调</strong>的方式。</p><p>Aware 的子接口需要提供一个 <code>setXxx</code> 方法，我们知道 set 是设置属性值的方法，即 Aware 类接口的 <code>setXxx</code> 方法其实就是设置 xxx 属性值的。 Aware 的含义是感知的、感应的，那么在 Spring 容器中是如何实现感知并设置属性值得呢？我们可以从初始化 bean 中的激活 Aware 的方法 <code>invokeAwareMethods(final String beanName, final Object bean)</code> 中看到一点点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeAwareMethods</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> Object bean)</span> &#123;<br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Aware) &#123;<br>    <span class="hljs-comment">// BeanNameAware</span><br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanNameAware) &#123;<br>((BeanNameAware) bean).setBeanName(beanName);<br>&#125;<br><span class="hljs-comment">// BeanClassLoaderAware</span><br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanClassLoaderAware) &#123;<br><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">bcl</span> <span class="hljs-operator">=</span> getBeanClassLoader();<br><span class="hljs-keyword">if</span> (bcl != <span class="hljs-literal">null</span>) &#123;<br>((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);<br>&#125;<br>&#125;<br><span class="hljs-comment">// BeanFactoryAware</span><br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanFactoryAware) &#123;<br>((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="hljs-built_in">this</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先，判断 bean 实例是否属于 Aware 接口的范畴，如果是的话，则调用实例的 <code>setXxx()</code> 方法给实例设置 xxx 属性值，在 <code>invokeAwareMethods(...)</code> 方法，主要是设置 beanName，beanClassLoader、BeanFactory 中三个属性值。</li></ul><h4 id="Aware子类"><a href="#Aware子类" class="headerlink" title="Aware子类"></a><code>Aware子类</code></h4><p><code>Aware</code>有诸多子类，比较熟悉的<code>BeanClassLoaderAware</code>、<code>BeanFactoryAware</code>、<code>BeanNameAware</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanClassLoaderAware</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Aware</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 将 BeanClassLoader 提供给 bean 实例回调</span><br><span class="hljs-comment">    * 在 bean 属性填充之后、初始化回调之前回调，</span><br><span class="hljs-comment">    * 例如InitializingBean的InitializingBean.afterPropertiesSet（）方法或自定义init方法</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanClassLoader</span><span class="hljs-params">(ClassLoader classLoader)</span>;<br><br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactoryAware</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Aware</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 将 BeanFactory 提供给 bean 实例回调</span><br><span class="hljs-comment">    * 调用时机和 setBeanClassLoader 一样</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanNameAware</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Aware</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 在创建此 bean 的 bean工厂中设置 beanName</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanName</span><span class="hljs-params">(String name)</span>;<br><br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApplicationContextAware</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Aware</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置此 bean 对象的 ApplicationContext，通常，该方法用于初始化对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span><br>        <span class="hljs-keyword">throws</span> BeansException;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p><code>JavaBean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAware</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span>,BeanNameAware, BeanClassLoaderAware, BeanFactoryAware &#123;<br><span class="hljs-keyword">private</span> ClassLoader classLoader;<br><span class="hljs-keyword">private</span> String beanName;<br><span class="hljs-keyword">private</span> BeanFactory beanFactory;<br><span class="hljs-keyword">private</span> ApplicationContext applicationContext;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanName</span><span class="hljs-params">(String name)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;调用了BeanNameAware的setBeanName...&quot;</span>);<br><span class="hljs-built_in">this</span>.beanName = name;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanClassLoader</span><span class="hljs-params">(ClassLoader classLoader)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;调用了BeanClassLoaderAware的setBeanClassLoader...&quot;</span>);<br><span class="hljs-built_in">this</span>.classLoader = classLoader;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>System.out.println(<span class="hljs-string">&quot;调用了BeanFactoryAware的setBeanFactory&quot;</span>);<br><span class="hljs-built_in">this</span>.beanFactory =beanFactory;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>System.out.println(<span class="hljs-string">&quot;调用了ApplicationContextAware的setApplicationContext&quot;</span>);<br><span class="hljs-built_in">this</span>.applicationContext = applicationContext;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;beanName:&quot;</span> + <span class="hljs-built_in">this</span>.beanName);<br>System.out.println(<span class="hljs-string">&quot;是否为单例：&quot;</span> + <span class="hljs-built_in">this</span>.beanFactory.isPrototype(<span class="hljs-built_in">this</span>.beanName));<br><span class="hljs-comment">//System.out.println(&quot;系统环境为：&quot; + applicationContext.getEnvironment());</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>spring配置文件</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testAware&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.jievhaha.TestAware&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ClassPathResource</span> <span class="hljs-variable">classPathResource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        <span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">defaultListableBeanFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultListableBeanFactory</span>();<br>        <span class="hljs-type">XmlBeanDefinitionReader</span> <span class="hljs-variable">xmlBeanDefinitionReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanDefinitionReader</span>(defaultListableBeanFactory);<br>        xmlBeanDefinitionReader.loadBeanDefinitions(classPathResource);<br>        <span class="hljs-type">TestAware</span> <span class="hljs-variable">testAware</span> <span class="hljs-operator">=</span> (TestAware) defaultListableBeanFactory.getBean(<span class="hljs-string">&quot;testAware&quot;</span>);<br>        testAware.display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">调用了BeanNameAware的setBeanName...<br>调用了BeanClassLoaderAware的setBeanClassLoader...<br>调用了BeanFactoryAware的setBeanFactory<br>beanName:testAware<br>是否为单例：true<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><br><span class="hljs-type">TestAware</span> <span class="hljs-variable">testAware</span> <span class="hljs-operator">=</span> (TestAware) app.getBean(<span class="hljs-string">&quot;testAware&quot;</span>);<br>testAware.display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果，较上边的测试多调用了<code>setApplicationContext()</code>方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">调用了BeanNameAware的setBeanName...<br>调用了BeanClassLoaderAware的setBeanClassLoader...<br>调用了BeanFactoryAware的setBeanFactory<br>调用了ApplicationContextAware的setApplicationContext<br>beanName:testAware<br>是否为单例：true<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>常见<code>Aware</code>子接口</p><ul><li>LoadTimeWeaverAware：加载Spring Bean时织入第三方模块，如AspectJ</li><li>BeanClassLoaderAware：加载Spring Bean的类加载器</li><li>BootstrapContextAware：资源适配器BootstrapContext，如JCA,CCI</li><li>ResourceLoaderAware：底层访问资源的加载器</li><li>BeanFactoryAware：声明BeanFactory</li><li>PortletConfigAware：PortletConfig</li><li>PortletContextAware：PortletContext</li><li>ServletConfigAware：ServletConfig</li><li>ServletContextAware：ServletContext</li><li>MessageSourceAware：国际化</li><li>ApplicationEventPublisherAware：应用事件</li><li>NotificationPublisherAware：JMX通知</li><li>BeanNameAware：声明Spring Bean的名字</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>spring</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Condition</title>
    <link href="/2022/06/11/Condition/"/>
    <url>/2022/06/11/Condition/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">Condition</font></div><blockquote><table><tr><td bgcolor="#6495ED"><font color="#FFF">在没有Lock之前，我们使用synchronized来控制同步，配合<kbd>Object</kbd>的wait()、notify()系列方法可以实现等待/通知模式。在Java SE5后，Java提供了Lock接口，配合<kbd>Condition</kbd>的await()、signal() 实现等待/通知模式。</font></td></tr></table></blockquote><h4 id="Condition的实现"><a href="#Condition的实现" class="headerlink" title="Condition的实现"></a>Condition的实现</h4><p><strong>Condition必须要配合锁一起使用</strong>，一个Condition的实例必须与一个Lock绑定，因此<strong>Condition一般都是作为Lock的内部实现</strong>。获取一个Condition必须要通过Lock的newCondition()方法。该方法定义在接口Lock下面，返回的结果是绑定到此 Lock 实例的<strong>新 Condition 实例</strong>。Condition为一个接口，其下仅有一个实现类ConditionObject，由于Condition的操作需要获取相关的锁，而AQS则是同步锁的实现基础，所以ConditionObject则定义为AQS的内部类。</p><p><img src="/images/JUC/Condition/Condition.png" alt="Condition"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br>    ...<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-comment">/** Marker to indicate a node is waiting in shared mode */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        <span class="hljs-comment">/** Marker to indicate a node is waiting in exclusive mode */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">/** waitStatus value to indicate thread has cancelled */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">/** waitStatus value to indicate thread is waiting on condition */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * waitStatus value to indicate the next acquireShared should</span><br><span class="hljs-comment">         * unconditionally propagate</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br>        <span class="hljs-keyword">volatile</span> Node prev;<br>        <span class="hljs-keyword">volatile</span> Node next;<br>        <span class="hljs-keyword">volatile</span> Thread thread;<br>        Node nextWaiter;<br>        ...<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span>, java.io.Serializable &#123;<br>        <span class="hljs-comment">/** First node of condition queue. */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br>        <span class="hljs-comment">/** Last node of condition queue. */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a><font style="color:rgb(69, 182, 247)">等待队列</font></h5><p>每个Condition对象都包含着一个FIFO队列，在队列中每一个节点都包含着一个线程引用，该线程就是在该Condition对象上等待的线程。</p><p>当前线程调用await()方法，将会以当前线程构成一个节点（Node），并将节点加入到该队列的尾部。</p><p>Node里面包含了当前线程的引用。Node定义与AQS的CLH同步队列的Node使用的都是同一个类（AbstractQueuedSynchronized.Node静态内部类）。</p><h5 id="等待"><a href="#等待" class="headerlink" title="等待"></a><font style="color:rgb(69, 182, 247)">等待</font></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 当前线程中断</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-comment">//当前线程加入等待队列</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>    <span class="hljs-comment">//释放锁</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 检测此节点的线程是否在同步队上，如果不在，则说明该线程还不具备竞争锁的资格，则继续等待</span><br><span class="hljs-comment">         * 直到检测到此节点在同步队列上</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        <span class="hljs-comment">//线程挂起</span><br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">//如果已经中断了，则退出</span><br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;Semaphore默认选择非公平锁。<br>    <span class="hljs-comment">//竞争同步状态</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-comment">//清理下条件队列中的不是在等待条件的节点</span><br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>        unlinkCancelledWaiters();<br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用Condition的await()方法会使当前线程进入等待状态，同时会调用<kbd>addConditionWaiter()</kbd>加入到Condition等待队列同时调用<kbd>fullyRelease(Node node)</kbd>释放该线程持有的锁。当从await()方法返回时，当前线程一定是获取了Condition相关连的锁。</p><p><kbd>isOnSyncQueue(Node node)</kbd>：如果一个节点刚开始在条件队列上，现在在同步队列上获取锁则返回true。</p><p><kbd>unlinkCancelledWaiters()</kbd>：负责将条件队列中状态不为Condition的节点删除。</p><h5 id="通知"><a href="#通知" class="headerlink" title="通知"></a><font style="color:rgb(69, 182, 247)">通知</font></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//检测是否是当前线程获得了锁</span><br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-comment">//头节点，唤醒条件队列中的第一个节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>        doSignal(first);    <span class="hljs-comment">//唤醒</span><br>&#125;<br></code></pre></td></tr></table></figure><p>调用Condition的signal()方法，将会唤醒在等待队列中<em><strong>等待最长时间</strong></em>的节点（条件队列里的<strong>首节点</strong>），在唤醒节点前，会将节点移到CLH同步队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Sync实现，检测是否是当前线程获得了锁</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// While we must in general read state before owner,</span><br>    <span class="hljs-comment">// we don&#x27;t need to do so to check if current thread is owner</span><br>    <span class="hljs-keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();<br>&#125;<br></code></pre></td></tr></table></figure><p><kbd>doSignal(Node first)</kbd>主要是做两件事：1.修改头节点，2.调用transferForSignal(Node first) 方法将节点移动到CLH同步队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//唤醒节点，修改头结点，完成旧头结点的移出工作</span><br>        <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)<br>            lastWaiter = <span class="hljs-literal">null</span>;<br>        first.nextWaiter = <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;<br>             (first = firstWaiter) != <span class="hljs-literal">null</span>);<br>&#125;<br><span class="hljs-comment">//将节点移动到CLH同步队列中</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">//将该节点从状态CONDITION改变为初始状态0,</span><br>    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">//将节点加入到syn队列中去，返回的是syn队列中node节点前面的一个节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;<br>    <span class="hljs-comment">//如果结点p的状态为cancel 或者修改waitStatus失败，则直接唤醒</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))<br>        LockSupport.unpark(node.thread);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>整个通知过程：</p><ol><li>判断当前线程是否已经获取了锁，如果没有获取则直接抛出异常，因为获取锁为通知的前置条件。</li><li>如果线程已经获取了锁，则将唤醒条件队列的首节点。</li><li>唤醒首节点是先将条件队列中的头节点移出，然后调用AQS的enq(Node node)方法将其安全地移到CLH同步队列中。</li><li>最后判断如果该节点的同步状态是否为Cancel，或者修改状态为Signal失败时，则直接调用LockSupport唤醒该节点的线程。</li></ol><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>一个线程获取锁后，通过调用Condition的await()方法，会将当前线程先加入到条件队列中，然后释放锁，最后通过isOnSyncQueue(Node node)方法不断自检看节点是否已经在CLH同步队列了，如果是则尝试获取锁，否则一直挂起。当线程调用signal()方法后，程序首先检查当前线程是否获取了锁，然后通过doSignal(Node first)方法唤醒CLH同步队列的首节点。被唤醒的线程，将从await()方法中的while循环中退出来，然后调用acquireQueued()方法竞争同步状态。</p><h4 id="Condition实现的生产消费者"><a href="#Condition实现的生产消费者" class="headerlink" title="Condition实现的生产消费者"></a>Condition实现的生产消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionTest</span> &#123;<br>    <span class="hljs-keyword">private</span> LinkedList&lt;String&gt; buffer;    <span class="hljs-comment">//容器</span><br>    <span class="hljs-keyword">private</span> Lock lock;<br>    <span class="hljs-keyword">private</span> Condition fullCondition;<br>    <span class="hljs-keyword">private</span> Condition notFullCondition;<br><br>    ConditionTest()&#123;<br>        buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;();<br>        lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        fullCondition = lock.newCondition();<br>        notFullCondition = lock.newCondition();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String string)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();    <span class="hljs-comment">//获取锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (buffer.size() != <span class="hljs-number">0</span>)&#123;<br>                notFullCondition.await();       <span class="hljs-comment">//满了，添加的线程进入等待状态</span><br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;生产了&quot;</span> + string);<br>            buffer.add(string);<br>            fullCondition.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();      <span class="hljs-comment">//记得释放锁</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        String string;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (buffer.size() == <span class="hljs-number">0</span>)&#123;<br>                fullCoSemaphore默认选择非公平锁。ndition.await();<br>            &#125;<br>            string = buffer.poll();<br>            System.out.println(<span class="hljs-string">&quot;消费了&quot;</span> + string);<br>            notFullCondition.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>        <span class="hljs-keyword">return</span> string;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ConditionTest</span> <span class="hljs-variable">conditionTest</span>  <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionTest</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    conditionTest.set(<span class="hljs-string">&quot;消息&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    conditionTest.get();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span>bin/java ...<br>生产了消息<br>消费了消息<br>生产了消息<br>消费了消息<br>生产了消息<br>消费了消息<br>生产了消息<br>消费了消息<br>生产了消息<br>消费了消息<br><br>进程已结束,退出代码<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CyclicBarrier</title>
    <link href="/2022/06/11/CyclicBarrier/"/>
    <url>/2022/06/11/CyclicBarrier/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">CyclicBarrier</font></div><blockquote><table><tr><td bgcolor="#6495ED"><font color="#FFF">CyclicBarrier，字面意思回环栅栏。通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。</font></td></tr></table></blockquote><h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><hr><p>CyclicBarrier的内部是使用重入锁ReentrantLock和Condition。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">trip</span> <span class="hljs-operator">=</span> lock.newCondition();<br></code></pre></td></tr></table></figure><p> 两个构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable barrierCommand;<span class="hljs-comment">//自己定义的Runnable，用于在parties数量线程到达屏障时，优先执行barrierAction </span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties)</span> &#123;<br>    <span class="hljs-built_in">this</span>(parties, <span class="hljs-literal">null</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties, Runnable barrierAction)</span> &#123;<br>    <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.parties = parties;<span class="hljs-comment">//要拦截的线程数</span><br>    <span class="hljs-built_in">this</span>.count = parties;<br>    <span class="hljs-built_in">this</span>.barrierCommand = barrierAction;<br>&#125;<br></code></pre></td></tr></table></figure><p>在CyclicBarrier中最重要的方法莫过于await()方法，在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> dowait(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<span class="hljs-comment">//不超时等待</span><br>    &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(toe); <span class="hljs-comment">// cannot happen</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dowait</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException,<br>TimeoutException &#123;<br>    <span class="hljs-comment">//获取锁</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//分代</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> generation;<br><br>        <span class="hljs-comment">//当前generation“已损坏”，抛出BrokenBarrierException异常</span><br>        <span class="hljs-comment">//抛出该异常一般都是某个线程在等待某个处于“断开”状态的CyclicBarrie</span><br>        <span class="hljs-keyword">if</span> (g.broken)<br>            <span class="hljs-comment">//当某个线程试图等待处于断开状态的 barrier 时，或者 barrier 进入断开状态而线程处于等待状态时，抛出该异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();<br><br>        <span class="hljs-comment">//如果线程中断，终止CyclicBarrier</span><br>        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>            breakBarrier();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br><br>        <span class="hljs-comment">//进来一个线程 count - 1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> --count;<br>        <span class="hljs-comment">//count == 0 表示所有线程均已到位，触发Runnable任务</span><br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// tripped</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">ranAction</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> barrierCommand;<br>                <span class="hljs-comment">//触发任务</span><br>                <span class="hljs-keyword">if</span> (command != <span class="hljs-literal">null</span>)<br>                    command.run();<br>                ranAction = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">//唤醒所有等待线程，并更新generation，比如我CyclicBarrier只能放2个，但是我一共四个甚至更多的线程，每次执行2个，然后就重新往CyclicBarrier塞，而且要重置generation</span><br>                nextGeneration();<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (!ranAction)<br>                    breakBarrier();<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//如果不是超时等待，则调用Condition.await()方法等待</span><br>                <span class="hljs-keyword">if</span> (!timed)<br>                    trip.await();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0L</span>)<br>                    <span class="hljs-comment">//超时等待，调用Condition.awaitNanos()方法等待</span><br>                    nanos = trip.awaitNanos(nanos);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>                <span class="hljs-keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;<br>                    breakBarrier();<br>                    <span class="hljs-keyword">throw</span> ie;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (g.broken)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();<br><br>            <span class="hljs-comment">//generation已经更新，返回index</span><br>            <span class="hljs-keyword">if</span> (g != generation)<br>                <span class="hljs-keyword">return</span> index;<br><br>            <span class="hljs-comment">//“超时等待”，并且时间已到,终止CyclicBarrier，并抛出异常</span><br>            <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>                breakBarrier();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中有个Generation对象，broken标识该当前CyclicBarrier是否已经处于中断状态。默认CyclicBarrier是没有损坏的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generation</span> &#123;<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">broken</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//broken标识该当前CyclicBarrier是否已经处于中断状态。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>   当barrier损坏了或者有一个线程中断了，则通过breakBarrier()来终止所有的线程，，还会调用signalAll将在CyclicBarrier处于等待状态的线程全部唤醒。：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breakBarrier</span><span class="hljs-params">()</span> &#123;<br>  generation.broken = <span class="hljs-literal">true</span>;<br>    count = parties;<br>    trip.signalAll();<br>&#125;<br></code></pre></td></tr></table></figure><p>  当一批次CyclicBarrier执行完毕（parties&#x3D;&#x3D;0），唤醒所有等待线程，并更新generation，然后进行下一批次（比如我CyclicBarrier只能放2个，但是我一共四个甚至更多的线程，每次执行2个，然后就重新往CyclicBarrier塞)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextGeneration</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// signal completion of last generation</span><br>    trip.signalAll();<br>    <span class="hljs-comment">// set up next generation</span><br>    count = parties;<br>    generation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><hr><p>CyclicBarrier试用与多线程结果合并的操作，用于多线程计算数据，最后合并计算结果的应用场景。比如我们需要统计多个Excel中的数据，然后等到一个总结果。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>,()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;任务集齐完毕&quot;</span>);<br>        &#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;任务&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;开始执行&quot;</span>);<br>                    cyclicBarrier.await();<br>                    System.out.println(<span class="hljs-string">&quot;任务&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;执行完毕&quot;</span>);<br>                &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br><br>                &#125;<span class="hljs-keyword">catch</span> (BrokenBarrierException e)&#123;<br><br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/images/JUC/JiShuQi/CyclicBarrier.png" alt="CyclicBarrier测试结果"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>JUC</category>
      
      <category>计数器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CountDownLatch</title>
    <link href="/2022/06/11/CountDownLatch/"/>
    <url>/2022/06/11/CountDownLatch/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">工具类CountDownLatch</font></div><blockquote><table><tr><td bgcolor="#6495ED"><font color="#FFF">CountDownLatch，字面意思倒计数，它的作用是允许1或N个线程等待其他线程完成后再执行，比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行。</font></td></tr></table></blockquote><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><em><strong>注意</strong></em>，CountDownlatch与CyclicBarrier有那么点相似，但是他们还是存在一些区别的：</p><ol><li>CountDownLatch的作用是允许1或N个线程等待其他线程完成后再执行；而CyclicBarrier则是实现让一组线程等待至某个状态之后再全部同时执行。</li><li>CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用（<code>reset()</code>）。</li></ol><h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><hr><p>CountDownLatch依赖内部类Sync实现，而Sync继承AQS。</p><p><img src="/images/JUC/JiShuQi/CountDownLatchStruct.png" alt="CountDownLatch类UML图"></p><p>提供了一个构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDownLatch</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;count &lt; 0&quot;</span>);<br>    <span class="hljs-built_in">this</span>.sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>(count);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">4982264981922014374L</span>;<br><br>    Sync(<span class="hljs-type">int</span> count) &#123;<br>        setState(count);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getState();<br>    &#125;<br>   <br>    <span class="hljs-comment">//获取共享状态</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//释放共享状态</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>        <span class="hljs-comment">// Decrement count; signal when transition to zero</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>                <span class="hljs-type">return</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span>= <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>CountDownLatch是采用<em><strong>共享锁</strong></em>来实现的。</p><p><kbd>await()</kbd>使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>await内部调用AQS的acquireSharedInterruptibly</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireSharedInterruptibly(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>tryAcquireShared由CountDownLatch内部类Sync重写实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>getState()获取同步状态，其值等于计数器的值，可以理解为重入锁的state数量，只不过初始化CountDownLatch的时候就由我们自己定义好了数值。</p><p>如果计数器值不等于0，则会调用doAcquireSharedInterruptibly(int arg)，该方法为一个自旋方法会尝试一直去获取同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//等待</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><kbd>countDown()</kbd>递减锁存器的计数，如果计数到达零，则释放所有等待的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;<br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>内部调用AQS的releaseShared(int arg)方法来释放共享锁同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>tryReleaseShared方法由CountDownLatch的内部类Sync重写实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//获取锁状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-comment">//c == 0 直接返回，释放锁成功</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//计算新“锁计数器”</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//更新锁状态（计数器）</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>            <span class="hljs-type">return</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span>= <span class="hljs-number">0</span>;<br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>CountDownLatch内部通过共享锁实现。在创建CountDownLatch实例时，需要传递一个int型的参数：count，该参数为计数器的初始值，也可以理解为该共享锁可获取的总次数。当某个线程调用await()方法，程序首先判断count的值是否为0，如果不会0的话则会一直等待，直到为0为止。当其他线程调用countDown()方法时，则执行释放共享锁状态，使count - 1，只到计数器count等于0（其他线程执行完毕），锁才会释放，前面等待的线程才会继续运行。注意CountDownLatch不能回滚重置。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    System.out.println(<span class="hljs-string">&quot;任务&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;开始执行&quot;</span>);<br>                    System.out.println(<span class="hljs-string">&quot;任务&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;执行完毕&quot;</span>);<br>                    countDownLatch.countDown();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;任务&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;正在等待子线程完成任务&quot;</span>);<br>            countDownLatch.await();<br>            System.out.println(<span class="hljs-string">&quot;任务&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;也执行完毕&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/images/JUC/JiShuQi/CountDownLatch.png" alt="CountDownLatch测试结果"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>JUC</category>
      
      <category>计数器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayBlockingQueue</title>
    <link href="/2022/06/11/ArrayBlockingQueue/"/>
    <url>/2022/06/11/ArrayBlockingQueue/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">ArrayBlockingQueue</font></div><blockquote><table><tr><td bgcolor="#6495ED"><font color="#FFF">ArrayBlockingQueue，一个由数组实现的有界阻塞队列。该队列采用FIFO的原则对元素进行排序添加的，（删除添加可以理解为循环的数组添加在前删除在后追赶）。 ArrayBlockingQueue为有界且固定，其大小在构造时由构造函数来决定，确认之后就不能再改变了。支持公平策略</font></td></tr></table></blockquote><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>ArrayBlockingQueue内部使用可重入锁ReentrantLock + Condition来完成多线程环境的并发操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">817911632652898426L</span>;<br>    <span class="hljs-keyword">final</span> Object[] items;<span class="hljs-comment">//一个定长数组，维护ArrayBlockingQueue的元素</span><br>    <span class="hljs-type">int</span> takeIndex;<span class="hljs-comment">//为ArrayBlockingQueue对首位置</span><br>    <span class="hljs-type">int</span> putIndex;<span class="hljs-comment">//为ArrayBlockingQueue对尾位置</span><br>    <span class="hljs-type">int</span> count;<span class="hljs-comment">//元素个数</span><br>    <span class="hljs-keyword">final</span> ReentrantLock lock;<span class="hljs-comment">//重入锁，ArrayBlockingQueue出列入列都必须获取该锁，公用一个锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<span class="hljs-comment">//出列条件，非空</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<span class="hljs-comment">//入列条件，未满</span><br>    <span class="hljs-keyword">transient</span> ArrayBlockingQueue.Itrs itrs;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="三个构造函数"><a href="#三个构造函数" class="headerlink" title="三个构造函数"></a>三个构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-built_in">this</span>(capacity, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span> &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair,</span><br><span class="hljs-params">                              Collection&lt;? extends E&gt; c)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="三个常用添加方法"><a href="#三个常用添加方法" class="headerlink" title="三个常用添加方法"></a>三个常用添加方法</h4><ol><li><p>add：添加元素到队列里，添加成功返回true，由于容量满了添加失败会抛出IllegalStateException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IllegalStateException: Queue full<br></code></pre></td></tr></table></figure></li><li><p>put：添加元素到队列里，如果容量满了会阻塞直到容量不满。内部直接调用的<code>enqueue</code></p></li><li><p>offer：添加元素到队列里，添加成功返回true，添加失败返回false，下边的逻辑依旧可以执行。</p><p><code>add</code>内部调用<code>offer(E e)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.add(e);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (offer(e))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Queue full&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>offer</code>核心是<code>enqueue</code>方法，做了真正的入队操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    checkNotNull(e);<span class="hljs-comment">//检查e是否为null，为null抛出异常。</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (count == items.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            enqueue(e);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(E x)</span> &#123;<br>    <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>    <span class="hljs-comment">// assert items[putIndex] == null;</span><br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    items[putIndex] = x;<br>    <span class="hljs-keyword">if</span> (++putIndex == items.length)<span class="hljs-comment">//队列已满</span><br>        putIndex = <span class="hljs-number">0</span>;<br>    count++;<br>    notEmpty.signal();<span class="hljs-comment">//唤醒出队</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="三个常用删除方法"><a href="#三个常用删除方法" class="headerlink" title="三个常用删除方法"></a>三个常用删除方法</h4><ol><li><p>remove：删除队列头部元素，删除成功返回该元素，队列为空删除会抛出NoSuchElementException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.util.NoSuchElementException<br></code></pre></td></tr></table></figure></li><li><p>take：删除队列头部元素，如果队列为空，一直阻塞到队列有元素并删除。</p></li><li><p>poll：删除队列头部元素，如果队列为空，返回null，否则返回元素，下边逻辑依旧可以执行。可以传入时间，等待n时间，没有元素就返回null。</p><p><code>remove</code>底层最后调用了<code>poll()</code>，<code>take</code>和<code>poll</code>底层最后执行的<code>dequeue</code>，二者区别仅在于<code>poll</code>返回null，<code>take</code>挂起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//take</span><br><span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>    notEmpty.await();<br><span class="hljs-keyword">return</span> dequeue();<br><br><span class="hljs-comment">//poll</span><br><span class="hljs-keyword">return</span> (count == <span class="hljs-number">0</span>) ? <span class="hljs-literal">null</span> : dequeue();<br><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (E) items[takeIndex];<br>    items[takeIndex] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (++takeIndex == items.length)<br>        takeIndex = <span class="hljs-number">0</span>;<br>    count--;<br>    <span class="hljs-keyword">if</span> (itrs != <span class="hljs-literal">null</span>)<br>        itrs.elementDequeued();<span class="hljs-comment">//内部迭代器需要移动元素位置，因为默认删除删的是头部，不处理迭代的话，迭代头部为null</span><br>    notFull.signal();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>JUC</category>
      
      <category>BlockingQueue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAS</title>
    <link href="/2022/06/11/CAS/"/>
    <url>/2022/06/11/CAS/</url>
    
    <content type="html"><![CDATA[<div align="center"><font color="#000" size="5rem">CAS</font></div><blockquote><table><tr><td bgcolor="#6495ED"><font color="#FFF">CAS，Compare And Swap，即比较并交换。整个AQS同步组件（例：ReentrantLock获取锁的时候）、Atomic原子类操作等等都是以CAS实现的，ConcurrentHashMap在1.8的版本中也调整为了CAS+Synchronized。</font></td></tr></table></blockquote><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img src="/images/JUC/CAS/CAS.png" alt="CAS是JUC的基础"></p><p>在CAS中有三个参数：内存值V、旧的预期值A、要更新的值B，当且仅当内存值V的值等于旧的预期值A时才会将内存值V的值修改为B，否则什么都不干。</p><p>ReentrantLock获取锁（AtomicInteger也用到了）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ReentrantLock内部类NonfairSync</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>        setExclusiveOwnerThread(Thread.currentThread());<br>    <span class="hljs-keyword">else</span><br>        acquire(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//ReentrantLock内部类FairSync</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    acquire(<span class="hljs-number">1</span>);<span class="hljs-comment">//最后调用了tryAcquire，内部用到了compareAndSetState(0, acquires)</span><br>&#125;<br><br><br><span class="hljs-comment">//AbstractQueuedSynchronizer</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> stateOffset;<span class="hljs-comment">//为变量值在内存中的偏移地址</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetState</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>    <span class="hljs-comment">// See below for intrinsics setup to support this</span><br>    <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, expect, update);<br>&#125;<br><span class="hljs-comment">//Unsafe</span><br><span class="hljs-comment">//该方法为本地方法，有四个参数，分别代表：对象、对象的地址、预期值、修改值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4, <span class="hljs-type">int</span> var5)</span>;<br></code></pre></td></tr></table></figure><p>Unsafe是CAS的核心类，提供了硬件级的原子操作，Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。</p><h4 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h4><p>如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。也可以自己设置可以使用<code>-XX:PreBlockSpin</code>来更改。</p><p>ABA问题，解决方案则是版本号，Java提供了AtomicStampedReference来解决。Pair为AtomicStampedReference的内部类，主要用于记录引用和版本戳信息（标识）。版本戳为int型，保持自增。同时Pair是一个不可变对象，其所有属性全部定义为final，对外提供一个of方法，该方法返回一个新建的Pari对象。pair对象定义为volatile，保证多线程环境下的可见性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ABA问题</span><br>ublic <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicStampedReference</span> <span class="hljs-variable">atomicStampedRef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>(<span class="hljs-number">100</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">intT1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>              atomicInt.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>);<br>              atomicInt.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>);<br>           &#125;<br>       &#125;);<br><br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">intT2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>              &#125;<br>              <span class="hljs-type">boolean</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> atomicInt.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>);<br>              System.out.println(c3); <span class="hljs-comment">// true</span><br>           &#125;<br>       &#125;);<br><br>       intT1.start();<br>       intT2.start();<br>       intT1.join();<br>       intT2.join();<br><br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">refT1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span><br>              <span class="hljs-keyword">try</span> &#123;<br>                  TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>              &#125;<br>              atomicStampedRef.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>, atomicStampedRef.getStamp(), atomicStampedRef.getStamp() + <span class="hljs-number">1</span>);<br>              atomicStampedRef.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>, atomicStampedRef.getStamp(), atomicStampedRef.getStamp() + <span class="hljs-number">1</span>);<br>           &#125;<br>       &#125;);<br><br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">refT2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>              <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> atomicStampedRef.getStamp();<br>              <span class="hljs-keyword">try</span> &#123;<br>                  TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>              &#125;<br>              <span class="hljs-type">boolean</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> atomicStampedRef.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>, stamp, stamp + <span class="hljs-number">1</span>);<br>              System.out.println(c3); <span class="hljs-comment">// false</span><br>           &#125;<br>       &#125;);<br><br>       refT1.start();<br>       refT2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只能保证一个共享变量的原子操作，Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>JUC</category>
      
      <category>基础理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/11/hello-world/"/>
    <url>/2022/06/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
